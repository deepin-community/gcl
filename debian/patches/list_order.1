Description: <short summary of the patch>
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 gcl (2.6.12-47) unstable; urgency=high
 .
   * pathnames1.13
Author: Camm Maguire <camm@debian.org>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: https://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: 2017-05-28

--- gcl-2.6.12.orig/clcs/sys-proclaim.lisp
+++ gcl-2.6.12/clcs/sys-proclaim.lisp
@@ -4,7 +4,9 @@
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
              COMMON-LISP::T)
-         CONDITIONS::COERCE-TO-FN CONDITIONS::SLOT-SYM)) 
+         COMMON-LISP::DEFINE-CONDITION COMMON-LISP::HANDLER-CASE
+         COMMON-LISP::IGNORE-ERRORS COMMON-LISP::HANDLER-BIND
+         CONDITIONS::SLOT-SYM CONDITIONS::COERCE-TO-FN)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::*)
@@ -20,27 +22,27 @@
          CONDITIONS::|(PCL::FAST-METHOD MAKE-LOAD-FORM (CONDITION))|)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::T)
-         CONDITIONS::IS-CONDITION CONDITIONS::DEFAULT-REPORT
-         CONDITIONS::IS-WARNING CONDITIONS::CONDITIONP)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
                  COMMON-LISP::T)
              COMMON-LISP::*)
-         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (PACKAGE-ERROR T))|
-         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (CASE-FAILURE T))|
-         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (ABORT-FAILURE T))|
+         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (STREAM-ERROR T))|
+         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (UNDEFINED-FUNCTION T))|
          CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (FILE-ERROR T))|
-         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (UNBOUND-VARIABLE T))|
-         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (ARITHMETIC-ERROR T))|
          CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (END-OF-FILE T))|
-         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (STREAM-ERROR T))|
+         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (PRINT-NOT-READABLE T))|
+         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (CASE-FAILURE T))|
+         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (PACKAGE-ERROR T))|
          CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (CELL-ERROR T))|
-         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (SIMPLE-CONDITION T))|
-         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (UNBOUND-SLOT T))|
-         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (UNDEFINED-FUNCTION T))|
          CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (INTERNAL-CONDITION T))|
-         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (PRINT-NOT-READABLE T))|
-         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (TYPE-ERROR T))|)) 
\ No newline at end of file
+         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (ABORT-FAILURE T))|
+         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (ARITHMETIC-ERROR T))|
+         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (UNBOUND-SLOT T))|
+         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (TYPE-ERROR T))|
+         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (SIMPLE-CONDITION T))|
+         CONDITIONS::|(PCL::FAST-METHOD PRINT-OBJECT (UNBOUND-VARIABLE T))|)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::T)
+         CONDITIONS::CONDITIONP CONDITIONS::DEFAULT-REPORT
+         CONDITIONS::IS-CONDITION CONDITIONS::IS-WARNING)) 
\ No newline at end of file
--- gcl-2.6.12.orig/cmpnew/gcl_cmpcall.lsp
+++ gcl-2.6.12/cmpnew/gcl_cmpcall.lsp
@@ -27,8 +27,7 @@
 (eval-when (compile eval)
 (defmacro link-arg-p (x)
   `(let ((.u ,x))
-     (not (member .u '(character boolean long-float short-float)))))
-)
+     (not (member .u '(character boolean long-float short-float) :test 'eq)))))
 
 (defun fast-link-proclaimed-type-p (fname &optional args)
   (and 
@@ -134,6 +133,7 @@
       (let ((*vs* *vs*) (form (caddr funob)))
            (declare (object form))
 	   (cond ((and (listp args)
+ 		       (< (length args) 12) ;FIXME fcalln1 limitation
 		       *use-sfuncall*
 		       ;;Determine if only one value at most is required:
 		       (or
@@ -167,8 +167,9 @@
 (defun fcalln-inline (&rest args)
   (wt-nl "({object _f=" (car args) ";enum type _t=type_of(_f);")
   (wt-nl "_f = _t==t_symbol && _f->s.s_gfdef!=OBJNULL ? (_t=type_of(_f->s.s_gfdef),_f->s.s_gfdef) : _f;")  
-  (wt-nl "_t==t_sfun ? _f->sfn.sfn_self : ")
-  (wt-nl "(fcall.argd= " (length (cdr args)) ",_t==t_vfun ? _f->vfn.vfn_self : ")
+  (wt-nl "_t==t_sfun&&(_f->sfn.sfn_argd&0xff)== " (length (cdr args)) " ? _f->sfn.sfn_self : ")
+  (wt-nl "(fcall.argd= " (length (cdr args))
+	 ",_t==t_vfun&&_f->vfn.vfn_minargs<= " (length (cdr args)) "&&" (length (cdr args)) "<=_f->vfn.vfn_maxargs  ? _f->vfn.vfn_self : ")
   (wt-nl "(fcall.fun=_f,fcalln));})")
   (wt-nl "(")
   (when (cdr args) (wt (cadr args))
--- gcl-2.6.12.orig/cmpnew/gcl_cmpenv.lsp
+++ gcl-2.6.12/cmpnew/gcl_cmpenv.lsp
@@ -376,9 +376,7 @@
                     doc form)
   (loop
     (when (endp body) (return))
-    (setq form (cmp-macroexpand (car body)))
-    (when (and (consp form) (eq (car form) 'load-time-value))
-      (setq form (cmp-eval form)))
+    (setq form (car body))
     (cond
      ((stringp form)
       (when (or (null doc-p) (endp (cdr body)) doc) (return))
--- gcl-2.6.12.orig/cmpnew/gcl_cmpfun.lsp
+++ gcl-2.6.12/cmpnew/gcl_cmpfun.lsp
@@ -603,7 +603,9 @@
 		  (t
 		   `(si::structure-subtype-p
 		     ,x ',type))))
-;	   ((and (print (list 'slow 'typep type)) nil))
+	   ((and (symbolp type) (setq tem (get type 'si::deftype-definition)))
+	    `(typep ,x ',(funcall tem)))
+	   ;; ((and (print (list 'slow 'typep type)) nil))
 	   (t nil)))
     (and new (c1expr `(the boolean , new)))))
 
@@ -877,36 +879,6 @@
 	 (c1expr (cmp-eval (cons f args))))))
 
 
-(si::putprop 'do 'co1special-fix-decl 'co1special)
-(si::putprop 'do* 'co1special-fix-decl 'co1special)
-(si::putprop 'prog 'co1special-fix-decl 'co1special)
-(si::putprop 'prog* 'co1special-fix-decl 'co1special)
-
-(defun co1special-fix-decl (f args)
-  (flet ((fixup (forms &aux decls )
-	  (block nil
-		 (tagbody
-		  top
-		  (or (consp forms) (go end))
-		  (let ((tem (car forms)))
-		    (if (and (consp tem)
-			     (setq tem  (cmp-macroexpand tem))
-			     (eq (car tem) 'declare))
-			(progn (push tem decls) (pop forms))
-		      (go end)))
-		      (go top)
-	      		; all decls made explicit.
-		      end
-		     (return  (nconc (nreverse decls) forms))))))
-	(c1expr
-	  (cmp-macroexpand
-	    (case f
-	      ((do do*) `(,f ,(car args)
-			     ,(second args)
-			     ,@ (fixup (cddr args))))
-	      ((prog prog*)
-	       `(,f ,(car args)
-		    ,@ (fixup (cdr args)))))))))
 (si::putprop 'sublis 'co1sublis 'co1)
 (defun co1sublis (f args &aux test) f
  (and (case (length args)
--- gcl-2.6.12.orig/cmpnew/gcl_cmpinline.lsp
+++ gcl-2.6.12/cmpnew/gcl_cmpinline.lsp
@@ -465,7 +465,7 @@
     (t . INLINE)))
 
 (defun inline-type (type)
-  (or (cdr (assoc type *inline-types*)) 'inline))
+  (or (cdr (assoc type *inline-types* :test 'eq)) 'inline))
 
 (defun get-inline-info (fname args return-type &aux x ii)
   (and  (fast-link-proclaimed-type-p fname args)
--- gcl-2.6.12.orig/cmpnew/gcl_cmplam.lsp
+++ gcl-2.6.12/cmpnew/gcl_cmplam.lsp
@@ -475,9 +475,9 @@
                (*unwind-exit* *unwind-exit*)
                (*ccb-vs* *ccb-vs*))
            (when rest
-             (wt-nl "vs_top[0]=Cnil;")
-             (wt-nl "{object *p=vs_top, *q=vs_base+" (length optionals) ";")
-             (wt-nl " for(;p>q;p--)p[-1]=MMcons(p[-1],p[0]);}"))
+             (wt-nl "{object *q=vs_base+" (length optionals) ",*l;")
+	     (wt-nl " for (l=q;q<vs_top;q++,l=&(*l)->c.c_cdr) *l=MMcons(*q,Cnil);")
+	     (wt-nl " *l=Cnil;}"))
            (do ((opts optionals (cdr opts)))
                ((endp opts))
                (declare (object opts))
@@ -510,11 +510,11 @@
 
              (wt-label label)))
         (rest
-         (wt-nl "vs_top[0]=Cnil;")
-         (wt-nl "{object *p=vs_top;")
-         (wt-nl " for(;p>vs_base;p--)p[-1]="
+	 (wt-nl "{object *q=vs_base,*l;")
+	 (wt-nl " for (l=q;q<vs_top;q++,l=&(*l)->c.c_cdr) *l="
 		(if *rest-on-stack* "ON_STACK_CONS" "MMcons")
-		"(p[-1],p[0]);}")
+		"(*q,Cnil);")
+	 (wt-nl " *l=Cnil;}")
          (c2bind rest)
          (wt-nl)
          (reset-top))
--- gcl-2.6.12.orig/cmpnew/gcl_cmpmulti.lsp
+++ gcl-2.6.12/cmpnew/gcl_cmpmulti.lsp
@@ -108,22 +108,11 @@
   (unwind-exit 'fun-val nil (if top-data (car top-data)))
   )
 
-(defun c1values (args &aux (info (make-info)))
-      (cond ((and args (not (cdr args))
-		  (or (not (consp (car args)))
-		      (and (symbolp (caar args))
-			   (let ((tem (get-return-type (caar args))))
-			     (and tem
-				  (or (atom tem)
-				      (and (consp tem)
-					   (null (cdr tem))
-					   (not (eq '* (car tem))))))))))
-	     ;;the compiler put in unnecessary code
-	     ;;if we just had say (values nil)
-	     ;; so if we know there's one value only:
-	     (c1expr (car args)))
-	    (t  (setq args (c1args args info))
-              (list 'values info args))))
+(defun c1values (args &aux (info (make-info))(s (si::sgen "VALUES")))
+  (cond ((and args (not (cdr args)))
+	 (c1expr `(let ((,s ,(car args))) ,s)))
+	(t  (setq args (c1args args info))
+	    (list 'values info args))))
 
 (defun c2values (forms &aux (base *vs*) (*vs* *vs*))
      (cond ((and (eq *value-to-go* 'return-object)
--- gcl-2.6.12.orig/cmpnew/gcl_cmpopt.lsp
+++ gcl-2.6.12/cmpnew/gcl_cmpopt.lsp
@@ -66,6 +66,10 @@
  (push '((t) boolean #.(flags)"type_of(#0)==t_longfloat")
    (get 'long-float-p 'inline-always))
 
+;;COMPLEX-P
+ (push '((t) boolean #.(flags)"type_of(#0)==t_complex")
+   (get 'si::complexp 'inline-always))
+
 ;;SFEOF
  (push '((object) boolean #.(flags set)"(gcl_feof((#0)->sm.sm_fp))")
    (get 'sfeof 'inline-unsafe))
@@ -479,21 +483,56 @@
    (get 'array-total-size 'inline-unsafe))
 
 ;;ARRAYP
- (push '((t) boolean #.(flags)
-  "@0;type_of(#0)==t_array||
-type_of(#0)==t_vector||
-type_of(#0)==t_string||
-type_of(#0)==t_bitvector")
-   (get 'arrayp 'inline-always))
+;;  (push '((t) boolean #.(flags)
+;;   "@0;type_of(#0)==t_array||
+;; type_of(#0)==t_vector||
+;; type_of(#0)==t_string||
+;; type_of(#0)==t_bitvector")
+;;    (get 'arrayp 'inline-always))
 
 ;;ATOM
- (push '((t) boolean #.(flags)"type_of(#0)!=t_cons")
+ (push '((t) boolean #.(flags)"atom(#0)")
    (get 'atom 'inline-always))
 
 ;;BIT-VECTOR-P
  (push '((t) boolean #.(flags)"(type_of(#0)==t_bitvector)")
    (get 'bit-vector-p 'inline-always))
 
+;;BIT-VECTOR-P
+ (push '((t) boolean #.(flags)"(type_of(#0)==t_bitvector)")
+   (get 'bit-vector-p 'inline-always))
+
+;;HASH-TABLE-P
+ (push '((t) boolean #.(flags)"(type_of(#0)==t_hashtable)")
+   (get 'hash-table-p 'inline-always))
+
+;;RANDOM-STATE-P
+ (push '((t) boolean #.(flags)"(type_of(#0)==t_random)")
+   (get 'random-state-p 'inline-always))
+
+;;RANDOM-STATE-P
+ (push '((t) boolean #.(flags)"(type_of(#0)==t_random)")
+   (get 'random-state-p 'inline-always))
+
+;;PACKAGEP
+ (push '((t) boolean #.(flags)"(type_of(#0)==t_package)")
+   (get 'packagep 'inline-always))
+
+;;STREAMP
+ (push '((t) boolean #.(flags)"(type_of(#0)==t_stream)")
+   (get 'streamp 'inline-always))
+
+;;READTABLEP
+ (push '((t) boolean #.(flags)"(type_of(#0)==t_readtable)")
+   (get 'readtablep 'inline-always))
+
+;;COMPOUND PREDICATES
+(dolist (l '(integerp rationalp floatp realp numberp vectorp arrayp compiled-function-p))
+  (push 
+   `((t) boolean #.(flags) ,(substitute #\_ #\- (concatenate 'string (string-downcase l) "(#0)")))
+   (get l 'inline-always)))
+
+
 ;;BOUNDP
  (push '((t) boolean #.(flags)"(#0)->s.s_dbind!=OBJNULL")
    (get 'boundp 'inline-unsafe))
@@ -739,7 +778,7 @@ type_of(#0)==t_bitvector")
    (get 'cons 'inline-always))
 
 ;;CONSP
- (push '((t) boolean #.(flags)"type_of(#0)==t_cons")
+ (push '((t) boolean #.(flags)"consp(#0)")
    (get 'consp 'inline-always))
 
 ;;COS
@@ -832,9 +871,9 @@ type_of(#0)==t_bitvector")
    (get 'float 'inline-always))
 
 ;;FLOATP
- (push '((t) boolean #.(flags)
-  "@0;type_of(#0)==t_shortfloat||type_of(#0)==t_longfloat")
-   (get 'floatp 'inline-always))
+ ;; (push '((t) boolean #.(flags)
+ ;;  "@0;type_of(#0)==t_shortfloat||type_of(#0)==t_longfloat")
+ ;;   (get 'floatp 'inline-always))
 
 ;;CEILING
 (push '((t t) t #.(compiler::flags) "immnum_ceiling(#0,#1)") (get 'ceiling 'compiler::inline-always))
@@ -861,9 +900,9 @@ type_of(#0)==t_bitvector")
    (get 'get 'inline-always))
 
 ;;INTEGERP
- (push '((t) boolean #.(flags)
-  "@0;type_of(#0)==t_fixnum||type_of(#0)==t_bignum")
-   (get 'integerp 'inline-always))
+ ;; (push '((t) boolean #.(flags)
+ ;;  "@0;type_of(#0)==t_fixnum||type_of(#0)==t_bignum")
+ ;;   (get 'integerp 'inline-always))
 (push '((fixnum) boolean #.(flags)
   "1")
    (get 'integerp 'inline-always))
@@ -940,7 +979,7 @@ type_of(#0)==t_bitvector")
    (get 'list* 'inline-always))
 
 ;;LISTP
- (push '((t) boolean #.(flags)"@0;type_of(#0)==t_cons||(#0)==Cnil")
+ (push '((t) boolean #.(flags)"listp(#0)")
    (get 'listp 'inline-always))
 
 ;;si::spice-p
@@ -1082,14 +1121,14 @@ type_of(#0)==t_bitvector")
    (get 'null 'inline-always))
 
 ;;NUMBERP
- (push '((t) boolean #.(flags)
-  "@0;type_of(#0)==t_fixnum||
-type_of(#0)==t_bignum||
-type_of(#0)==t_ratio||
-type_of(#0)==t_shortfloat||
-type_of(#0)==t_longfloat||
-type_of(#0)==t_complex")
-   (get 'numberp 'inline-always))
+;;  (push '((t) boolean #.(flags)
+;;   "@0;type_of(#0)==t_fixnum||
+;; type_of(#0)==t_bignum||
+;; type_of(#0)==t_ratio||
+;; type_of(#0)==t_shortfloat||
+;; type_of(#0)==t_longfloat||
+;; type_of(#0)==t_complex")
+;;    (get 'numberp 'inline-always))
 
 ;;PLUSP
  (push '((t) boolean #.(flags) "immnum_plusp(#0)");"number_compare(small_fixnum(0),#0)<0"
@@ -1175,7 +1214,7 @@ type_of(#0)==t_complex")
       (get 'si::pathname-designatorp 'inline-always))
 
 ;;PATHNAMEP
-(push '((t) boolean #.(flags)"pathnamep(#0)")
+(push '((t) boolean #.(flags)"type_of(#0)==t_pathname")
       (get 'pathnamep 'inline-always))
 
 ;;STRINGP
@@ -1235,11 +1274,11 @@ type_of(#0)==t_complex")
 
 
 ;;VECTORP
- (push '((t) boolean #.(flags)
-  "@0;type_of(#0)==t_vector||
-type_of(#0)==t_string||
-type_of(#0)==t_bitvector")
-   (get 'vectorp 'inline-always))
+;;  (push '((t) boolean #.(flags)
+;;   "@0;type_of(#0)==t_vector||
+;; type_of(#0)==t_string||
+;; type_of(#0)==t_bitvector")
+;;    (get 'vectorp 'inline-always))
 
 ;;WRITE-CHAR
  (push '((t) t #.(flags set)
--- gcl-2.6.12.orig/cmpnew/gcl_cmptop.lsp
+++ gcl-2.6.12/cmpnew/gcl_cmptop.lsp
@@ -135,7 +135,6 @@
 ;;; Pass 2 initializers.
 
 (si:putprop 'defun 't2defun 't2)
-(si:putprop 'defmacro 't2defmacro 't2)
 (si:putprop 'declare 't2declare 't2)
 (si:putprop 'defentry 't2defentry 't2)
 (si:putprop 'si:putprop 't2putprop 't2)
@@ -143,7 +142,6 @@
 ;;; Pass 2 C function generators.
 
 (si:putprop 'defun 't3defun 't3)
-(si:putprop 'defmacro 't3defmacro 't3)
 (si:putprop 'ordinary 't3ordinary 't3)
 (si:putprop 'sharp-comma 't3sharp-comma 't3)
 (si:putprop 'clines 't3clines 't3)
@@ -205,26 +203,20 @@
   (let ((new (copy-seq str)))
     (dash-to-underscore-int new 0 (length new))))
 
-(defun init-name (p &optional sp (gp t) (dc t) (nt t)) 
 
-  (cond ((not sp) "code")
-	((not (pathnamep p)) (init-name (pathname p) sp gp dc nt))
-	(gp (init-name (truename (merge-pathnames p #p".lsp")) sp nil dc nt))
-	((pathname-type p)
-	 (init-name (make-pathname
-                     :host (pathname-host p)
-                     :device (pathname-device p)
-                     :directory (pathname-directory p)
-                     :name (pathname-name p)
-                     :version (pathname-version p)) sp gp dc nt))
-;	#-aosvs(dc (string-downcase (init-name p sp gp nil nt)))
-	((and nt
-	      (let* ((pn (pathname-name p))
-		     (pp (make-pathname :name pn)))
-		(and (not (equal pp p)) 
-		     (eql 4 (string<= "gcl_" pn))
-		     (init-name pp sp gp dc nil)))))
-	((dash-to-underscore (namestring p)))))
+(defun init-name (p &optional sp)
+
+  (if sp
+      (let* ((p (truename (merge-pathnames p #p".lsp")))
+	     (pn (pathname-name p))
+	     (g (zerop (si::string-match #v"^gcl_" pn))))
+	(dash-to-underscore
+	 (namestring
+	  (make-pathname :host (unless g (pathname-host p))
+			 :device (unless g (pathname-device p))
+			 :directory (unless g (pathname-directory p))
+			 :name pn))))
+    "code"))
 
 ;; FIXME consider making this a macro
 (defun c-function-name (prefix num fname)
@@ -469,7 +461,7 @@
         (too-few-args 'defun 2 (length args)))
   (cmpck (not (symbolp (car args)))
          "The function name ~s is not a symbol." (car args))
-  (maybe-eval nil  (cons 'defun args))
+  (unless (macro-function (car args)) (maybe-eval nil (cons 'defun args)))
  (tagbody
    top
   (setq *non-package-operation* t)
@@ -615,8 +607,9 @@
      (setq type (f-type (pop args))))))
     
 
-(defun wt-if-proclaimed (fname cfun lambda-expr)
-  (cond ((fast-link-proclaimed-type-p fname)
+(defun wt-if-proclaimed (fname cfun lambda-expr macro-p)
+  (cond (macro-p (add-init `(si::MM ',fname ,(add-address (c-function-name "LI" cfun fname)))))
+	((fast-link-proclaimed-type-p fname)
 	 (cond ((unless (member '* (get fname 'proclaimed-arg-types)) (assoc fname *inline-functions*))
 		(add-init `(si::mfsfun ',fname ,(add-address (c-function-name "LI" cfun fname))
 				   ,(proclaimed-argd (get fname 'proclaimed-arg-types)
@@ -698,11 +691,11 @@
 (defun si::add-debug (fname x)
   (si::putprop fname x  'si::debugger))
 
-(defun t3init-fun (fname cfun lambda-expr doc)
+(defun t3init-fun (fname cfun lambda-expr doc macro-p)
 
   (when doc (add-init `(si::putprop ',fname ,doc 'si::function-documentation)))
   
-  (cond ((wt-if-proclaimed fname cfun lambda-expr))
+  (cond ((wt-if-proclaimed fname cfun lambda-expr macro-p))
 	((vararg-p fname)
 	 (let ((keyp (ll-keywords-p (lambda-list lambda-expr))))
 ;	   (wt-h "static object LI" cfun "();")
@@ -724,6 +717,7 @@
 	   (add-init `(si::mf ',fname ,(add-address (c-function-name "" cfun fname)))))))
 
 (defun t3defun (fname cfun lambda-expr doc sp &aux inline-info 
+		      (macro-p (equal `(mflag ,fname) (cadr (member *current-form* *top-level-forms*))))
 		      (*current-form* (list 'defun fname))
 		      (*volatile* (volatile (second lambda-expr)))
 		      *downward-closures*)
@@ -736,9 +730,9 @@
 		 (return (setq inline-info v))))
 
     ;;; Add global entry information.
-    (when (not (fast-link-proclaimed-type-p fname))
-	  (push (list fname cfun (cadr inline-info) (caddr inline-info))
-		*global-entries*))
+    (unless (or macro-p (fast-link-proclaimed-type-p fname))
+      (push (list fname cfun (cadr inline-info) (caddr inline-info))
+	    *global-entries*))
 
     ;;; Local entry
     (analyze-regs (cadr lambda-expr) 0)
@@ -761,7 +755,7 @@
   
   (wt-downward-closure-macro cfun)
 
-  (t3init-fun fname cfun lambda-expr doc)
+  (t3init-fun fname cfun lambda-expr doc macro-p)
 
   (add-debug-info fname lambda-expr))
 
@@ -1333,63 +1327,13 @@
              (long-float "double ")
              (otherwise "object ")))
 
-
-(defun t1defmacro (args)
-  (when (or (endp args) (endp (cdr args)))
-        (too-few-args 'defmacro 2 (length args)))
-  (cmpck (not (symbolp (car args)))
-         "The macro name ~s is not a symbol." (car args))
-  (maybe-eval t (cons 'defmacro args))
-  (setq *non-package-operation* t)
-  (let ((*vars* nil) (*funs* nil) (*blocks* nil) (*tags* nil)
-        (*sharp-commas* nil) (*special-binding* nil)
-        macro-lambda (cfun (next-cfun)))
-       (setq macro-lambda (c1dm (car args) (cadr args) (cddr args)))
-       (add-load-time-sharp-comma)
-       (push (list 'defmacro (car args) cfun (cddr macro-lambda)
-		   (car macro-lambda)   ;doc
-		   (cadr macro-lambda)  ; ppn
-                   *special-binding*)
-             *top-level-forms*))
-  )
-
-
-(defun t2defmacro (fname cfun macro-lambda doc ppn sp)
-
-  (declare (ignore macro-lambda doc ppn sp))
-  (wt-h "static void " (c-function-name "L" cfun fname) "();")
-  )
-
-(defun t3defmacro (fname cfun macro-lambda doc ppn sp
-                         &aux (*volatile* (if (get fname 'contains-setjmp)
-					      " VOL " "")))
-  (let-pass3
-   ((*exit* 'return))
-   (wt-comment "macro definition for " fname)
-   (wt-nl1 "static void " (c-function-name "L" cfun fname) "()")
-   (wt-nl1 "{register object *" *volatile* "base=vs_base;")
-   (assign-down-vars (nth 4 macro-lambda) cfun ;*dm-info*
-		     't3defun)
-   (wt-nl "register object *"*volatile* "sup=base+VM" *reservation-cmacro* ";")
-   (wt " VC" *reservation-cmacro*)
-   (if *safe-compile*
-       (wt-nl "vs_reserve(VM" *reservation-cmacro* ");")
-     (wt-nl "vs_check;"))
-   (when sp (wt-nl "bds_check;"))
-   (when *compiler-push-events* (wt-nl "ihs_check;"))
-   (c2dm (car macro-lambda) (cadr macro-lambda) (caddr macro-lambda)
-	 (cadddr macro-lambda))
-   (wt-nl1 "}")
-   (push (cons *reservation-cmacro* *max-vs*) *reservations*)
-   (wt-h "#define VC" *reservation-cmacro*)
-   (wt-cvars)
-
-   (when doc (add-init `(si::putprop ',fname ,doc 'si::function-documentation) ))
-   (when ppn
-     (add-init `(si::putprop ',fname ',ppn 'si::pretty-print-format) ))
-   (add-init `(si::MM ',fname ,(add-address (c-function-name "L" cfun fname))) )
-
-   ))
+(defun t1defmacro (args &aux (w args)(n (pop args))(l (symbol-plist n))
+			(macp (when (listp n) (eq 'macro (car n))))(n (if macp (cdr n) n)))
+  (proclaim `(ftype (function (t t) t) ,n))
+  (maybe-eval (not (macro-function n)) (cons 'defmacro w));FIXME?
+  (t1expr `(defun ,n ,@(if macp args (cddr (caddr (si::defmacro* n (pop args) args))))))
+  (setf (symbol-plist n) l)
+  (push `(mflag ,n) *top-level-forms*))
 
 (defun t1ordinary (form &aux tem )
   (setq *non-package-operation* t)
--- gcl-2.6.12.orig/cmpnew/gcl_cmputil.lsp
+++ gcl-2.6.12/cmpnew/gcl_cmputil.lsp
@@ -180,33 +180,27 @@
     (or (member-if (lambda (x) (when (consp x) (eq (car x) fname))) *funs*)
 	(macro-function fname))))
 
-(defun do-macro-expansion (how form &aux env)
-  (dolist (v *funs*)
+(defun macro-env (&aux env)
+  (dolist (v *funs* (when env (list nil (nreverse env) nil)))
     (when (consp v)
-      (push (list (car v) 'macro (cadr v)) env))) 
-  (when env (setq env (list nil (nreverse env) nil)))
-  (let ((x (multiple-value-list (cmp-toplevel-eval `(,@how ',form ',env)))))
-    (if (car x)
-        (let ((*print-case* :upcase))
-          (incf *error-count*)
-          (print-current-form)
-          (format t ";;; The macro form ~s was not expanded successfully.~%" form)
-          `(error "Macro-expansion of ~s failed at compile time." ',form))
-        (cadr x))))
+      (push (list (car v) 'macro (cadr v)) env))))
 
 (defun cmp-macroexpand (form)
   (if (macro-def-p form)
-      (do-macro-expansion '(macroexpand) form)
+      (macroexpand form (macro-env))
     form))
 
 (defun cmp-macroexpand-1 (form)
   (if (macro-def-p form)
-      (do-macro-expansion '(macroexpand-1) form)
+      (macroexpand-1 form (macro-env))
     form))
 
 (defun cmp-expand-macro (fd fname args &aux (form (cons fname args)))
   (if (macro-def-p form)
-      (do-macro-expansion `(funcall *macroexpand-hook* ',fd) form)
+      (let ((env (macro-env)))
+	(if (eq *macroexpand-hook* 'funcall)
+	    (funcall fd form env)
+	  (funcall *macroexpand-hook* fd form env)))
     form))
 
 (defvar *compiler-break-enable* nil)
--- gcl-2.6.12.orig/cmpnew/sys-proclaim.lisp
+++ gcl-2.6.12/cmpnew/sys-proclaim.lisp
@@ -2,24 +2,116 @@
 (COMMON-LISP::IN-PACKAGE "COMPILER") 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             ((COMMON-LISP::INTEGER -9223372036854775808
-                  9223372036854775807)
-              (COMMON-LISP::INTEGER -9223372036854775808
-                  9223372036854775807))
-             COMMON-LISP::T)
-         COMPILER::MLIN)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::T)
+         COMPILER::TAG-REF-CLB COMPILER::SET-TOP
+         COMPILER::C1MULTIPLE-VALUE-BIND COMPILER::C1LIST-NTH
+         COMPILER::C1RPLACA-NTHCDR COMPILER::C1DEFINE-STRUCTURE
+         COMPILER::BLK-REF-CLB COMPILER::WT-VV COMPILER::C1LENGTH
+         COMPILER::C1MAPC COMPILER::C1LOCAL-CLOSURE
+         COMPILER::CHECK-VREF COMPILER::WT-VAR-DECL COMPILER::C1TAGBODY
+         COMPILER::BLK-REF-CCB COMPILER::C1LOAD-TIME-VALUE
+         COMPILER::C1ASH COMPILER::FUN-LEVEL COMPILER::COPY-INFO
+         COMPILER::INLINE-POSSIBLE COMPILER::WT-VS-BASE
+         COMPILER::T1DEFENTRY COMPILER::CHARACTER-LOC-P
+         COMPILER::C2RPLACA COMPILER::RESET-INFO-TYPE
+         COMPILER::TYPE-FILTER COMPILER::TAG-SWITCH
+         COMPILER::DECL-BODY-SAFETY COMPILER::C1AND
+         COMPILER::C1FMLA-CONSTANT COMPILER::C2GO-CLB
+         COMPILER::C1FUNCTION COMPILER::C1MAPLIST COMPILER::VAR-TYPE
+         COMPILER::CLINK COMPILER::UNWIND-NO-EXIT COMPILER::VAR-LOC
+         COMPILER::C2RPLACD COMPILER::VERIFY-DATA-VECTOR
+         COMPILER::TAG-REF-CCB COMPILER::C1RETURN-FROM
+         COMPILER::T1DEFINE-STRUCTURE COMPILER::MDELETE-FILE
+         COMPILER::OBJECT-TYPE COMPILER::WT-CAR COMPILER::TAG-P
+         COMPILER::ADD-LOOP-REGISTERS COMPILER::C1MEMQ
+         COMPILER::C2FUNCTION COMPILER::CMP-MACRO-FUNCTION
+         COMPILER::C1BOOLE-CONDITION COMPILER::REP-TYPE COMPILER::C2GET
+         COMPILER::C2VAR COMPILER::C2EXPR* COMPILER::C1ADD-GLOBALS
+         COMPILER::WT1 COMPILER::C1BLOCK COMPILER::C1MAPL
+         COMPILER::C1MAPCAR COMPILER::FSET-FN-NAME COMPILER::C2GO-CCB
+         COMPILER::T1DEFLA COMPILER::C1NTH-CONDITION
+         COMPILER::ADD-OBJECT2 COMPILER::VAR-NAME COMPILER::C1EXPR
+         COMPILER::FUN-REF COMPILER::SCH-LOCAL-FUN
+         COMPILER::FIXNUM-LOC-P COMPILER::BLK-VAR
+         COMPILER::C1UNWIND-PROTECT COMPILER::C2BIND
+         COMPILER::PARSE-CVSPECS COMPILER::C1NTH
+         COMPILER::WT-SWITCH-CASE SYSTEM::UNDEF-COMPILER-MACRO
+         COMPILER::SET-UP-VAR-CVS COMPILER::C1ECASE
+         COMPILER::C1STRUCTURE-REF COMPILER::FUN-INFO
+         COMPILER::C1MEMBER COMPILER::C1GET COMPILER::WT-FUNCTION-LINK
+         COMPILER::C1ASH-CONDITION COMPILER::WT-CCB-VS COMPILER::INFO-P
+         COMPILER::REGISTER COMPILER::TAG-VAR COMPILER::C1VAR
+         COMPILER::C1TERPRI COMPILER::LTVP
+         COMPILER::WT-DOWNWARD-CLOSURE-MACRO COMPILER::C1MAPCON
+         COMPILER::PUSH-ARGS-LISPCALL COMPILER::C1SETQ
+         COMPILER::C2DOWNWARD-FUNCTION COMPILER::T3ORDINARY
+         COMPILER::C1VREF COMPILER::WT-VS COMPILER::CONSTANT-FOLD-P
+         COMPILER::C1MULTIPLE-VALUE-PROG1 COMPILER::BLK-EXIT
+         COMPILER::T1DEFUN COMPILER::C1LABELS COMPILER::C1FSET
+         COMPILER::T1MACROLET COMPILER::FUN-NAME COMPILER::C1APPLY
+         COMPILER::FUN-P COMPILER::WT-DATA-PACKAGE-OPERATION
+         COMPILER::C1FUNOB COMPILER::WT-SYMBOL-FUNCTION
+         COMPILER::GET-RETURN-TYPE COMPILER::ADD-CONSTANT
+         COMPILER::SAFE-SYSTEM COMPILER::BLK-VALUE-TO-GO
+         COMPILER::NEED-TO-SET-VS-POINTERS COMPILER::C2TAGBODY-LOCAL
+         COMPILER::C1DECLARE COMPILER::C1OR COMPILER::C1ASSOC
+         COMPILER::ADD-ADDRESS COMPILER::VAR-KIND
+         COMPILER::PROCLAMATION COMPILER::FIX-OPT COMPILER::WT-DATA1
+         COMPILER::INFO-SP-CHANGE COMPILER::ARGS-CAUSE-SIDE-EFFECT
+         COMPILER::WRITE-BLOCK-OPEN COMPILER::C2TAGBODY-BODY
+         COMPILER::CONS-TO-LISTA COMPILER::SAVE-FUNOB COMPILER::VAR-REF
+         COMPILER::C1LOCAL-FUN COMPILER::VAR-REP-LOC
+         COMPILER::SET-PUSH-CATCH-FRAME COMPILER::CTOP-WRITE
+         COMPILER::C2TAGBODY-CLB COMPILER::T1CLINES
+         COMPILER::ADD-OBJECT COMPILER::GET-LOCAL-RETURN-TYPE
+         COMPILER::DEFAULT-INIT COMPILER::FUNCTION-ARG-TYPES
+         COMPILER::C1STRUCTURE-SET COMPILER::CMP-MACROEXPAND-1
+         COMPILER::INLINE-TYPE COMPILER::VAR-REGISTER
+         COMPILER::DECLARATION-TYPE COMPILER::C1CATCH COMPILER::C1LET
+         COMPILER::T3CLINES COMPILER::UNDEFINED-VARIABLE COMPILER::C1GO
+         COMPILER::TAG-NAME COMPILER::SCH-GLOBAL COMPILER::C1IF
+         COMPILER::C1FLET COMPILER::INLINE-BOOLE3-STRING
+         COMPILER::INFO-CHANGED-ARRAY COMPILER::C2FUNCALL-AUX
+         COMPILER::FUN-REF-CCB COMPILER::WT-CADR COMPILER::FUN-CFUN
+         COMPILER::WT-VS* COMPILER::WT-DOWN COMPILER::C2GETHASH
+         COMPILER::ADD-REG1 COMPILER::REPLACE-CONSTANT
+         COMPILER::C2DM-RESERVE-V COMPILER::RESULT-TYPE
+         COMPILER::C1FUNCALL COMPILER::C1THE COMPILER::VARARG-P
+         COMPILER::INFO-REFERRED-ARRAY COMPILER::C1PROGV
+         COMPILER::T2DECLARE COMPILER::T1DEFCFUN COMPILER::C2VALUES
+         COMPILER::C1SWITCH COMPILER::C1MAPCAN
+         COMPILER::CMP-MACROEXPAND COMPILER::TAG-LABEL
+         COMPILER::TAG-UNWIND-EXIT COMPILER::C1PRINC COMPILER::C1THROW
+         COMPILER::SAVE-AVMA COMPILER::VOLATILE COMPILER::FLAGS-POS
+         COMPILER::INFO-TYPE COMPILER::C1NTHCDR-CONDITION
+         COMPILER::C1MULTIPLE-VALUE-SETQ COMPILER::WT-FUNCALL-C
+         COMPILER::PUSH-ARGS COMPILER::C1DM-BAD-KEY
+         COMPILER::T1ORDINARY COMPILER::C1PSETQ COMPILER::BLK-REF
+         COMPILER::C2DM-RESERVE-VL COMPILER::C1MACROLET
+         COMPILER::C1SHARP-COMMA COMPILER::C1RPLACA
+         COMMON-LISP::PROCLAIM COMPILER::PUSH-DATA-INCF
+         COMPILER::MACRO-DEF-P COMPILER::BLK-NAME COMPILER::C1VALUES
+         COMPILER::C1DOWNWARD-FUNCTION COMPILER::T1DEFMACRO
+         COMPILER::GET-ARG-TYPES COMPILER::ADD-SYMBOL
+         COMPILER::NAME-SD1 COMPILER::C2GO-LOCAL
+         COMPILER::C2TAGBODY-CCB COMPILER::WT-LIST
+         COMPILER::GET-LOCAL-ARG-TYPES COMPILER::C1BOOLE3
+         COMPILER::C1STACK-LET COMPILER::WT-CDR COMPILER::C1QUOTE
+         COMPILER::C1EVAL-WHEN COMPILER::VAR-P COMPILER::CHECK-DOWNWARD
+         COMPILER::T1PROGN COMPILER::BLK-P COMPILER::C2LOCATION
+         COMPILER::THE-PARAMETER COMPILER::C2VAR-KIND
+         COMPILER::C1GETHASH COMPILER::LTVP-EVAL COMPILER::C1RPLACD
+         COMPILER::INFO-VOLATILE COMPILER::LONG-FLOAT-LOC-P
+         COMPILER::FUNCTION-RETURN-TYPE COMPILER::SHORT-FLOAT-LOC-P
+         COMPILER::WT-H1 COMPILER::C1MULTIPLE-VALUE-CALL
+         COMPILER::NAME-TO-SD COMPILER::C1PROGN COMPILER::SET-RETURN
+         COMPILER::C1LET* COMPILER::AET-C-TYPE COMPILER::C1COMPILER-LET
+         COMPILER::MAXARGS COMPILER::VAR-REF-CCB COMPILER::VV-STR
+         COMPILER::C1NTHCDR COMPILER::TAG-REF COMPILER::GET-INCLUDED)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             ((COMMON-LISP::VECTOR COMMON-LISP::CHARACTER
-                  COMMON-LISP::*)
-              (COMMON-LISP::INTEGER -9223372036854775808
-                  9223372036854775807)
-              (COMMON-LISP::INTEGER -9223372036854775808
-                  9223372036854775807))
-             COMMON-LISP::T)
-         COMPILER::DASH-TO-UNDERSCORE-INT)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::*) COMMON-LISP::*)
+         COMPILER::INLINE-BOOLE3)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
@@ -29,332 +121,93 @@
          COMPILER::TS COMPILER::DASH-TO-UNDERSCORE)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION COMMON-LISP::NIL COMMON-LISP::T)
-         COMPILER::C1NIL COMPILER::WT-DATA-FILE
-         COMPILER::CLOSE-INLINE-BLOCKS COMPILER::WT-NEXT-VAR-ARG
-         COMPILER::RESET-TOP COMPILER::VS-PUSH COMPILER::BABOON
-         COMPILER::GAZONK-NAME COMPILER::PRINT-COMPILER-INFO
-         COMPILER::ADD-LOAD-TIME-SHARP-COMMA COMPILER::INIT-ENV
-         COMPILER::PRINT-CURRENT-FORM COMPILER::WT-C-PUSH COMPILER::C1T
-         COMPILER::WT-FIRST-VAR-ARG COMPILER::CCB-VS-PUSH
-         COMPILER::INC-INLINE-BLOCKS COMPILER::WT-CVARS
-         COMPILER::WT-FASD-DATA-FILE COMPILER::WFS-ERROR
-         COMPILER::WT-DATA-END COMPILER::TAIL-RECURSION-POSSIBLE
-         COMPILER::CVS-PUSH COMPILER::WT-DATA-BEGIN)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
-             COMMON-LISP::FIXNUM)
-         COMPILER::ANALYZE-REGS1 COMPILER::ANALYZE-REGS
-         COMPILER::PROCLAIMED-ARGD)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T)
              COMMON-LISP::T)
-         COMPILER::CHECK-FNAME-ARGS COMPILER::COERCE-LOC
-         COMPILER::TYPE>= COMPILER::C2BIND-LOC
-         COMPILER::RESULT-TYPE-FROM-ARGS COMPILER::ADD-DEBUG-INFO
-         COMPILER::MAKE-USER-INIT COMPILER::CO1EQL COMPILER::C2ASSOC!2
-         COMPILER::WT-VAR COMPILER::CFAST-WRITE COMPILER::C2STACK-LET
-         COMPILER::C2DM-BIND-INIT COMPILER::IS-REP-REFERRED
-         COMPILER::CO1CONS COMPILER::SHIFT<<
-         COMPILER::C2MULTIPLE-VALUE-SETQ COMPILER::C2CALL-LOCAL
-         COMPILER::CO1SCHAR COMPILER::C1CONSTANT-VALUE
-         COMPILER::WT-CHARACTER-VALUE COMPILER::CONVERT-CASE-TO-SWITCH
-         COMPILER::C2MULTIPLE-VALUE-CALL COMPILER::C2EXPR-TOP
-         COMPILER::CO1READ-BYTE COMPILER::PRIN1-CMP
-         COMPILER::STRUCT-TYPE-OPT COMPILER::C1DECL-BODY
-         COMPILER::COERCE-LOC-STRUCTURE-REF
-         COMPILER::CO1STRUCTURE-PREDICATE COMPILER::WT-MAKE-DCLOSURE
-         COMPILER::ARGS-INFO-CHANGED-VARS
-         COMPILER::C2LIST-NTH-IMMEDIATE COMPILER::CO1LDB
-         COMPILER::CO1WRITE-BYTE COMPILER::C1PROGN*
-         COMPILER::CO1CONSTANT-FOLD COMPILER::SET-JUMP-TRUE
-         COMPILER::C1SETQ1 COMPILER::CO1READ-CHAR COMPILER::C2BIND-INIT
-         COMPILER::CO1TYPEP COMPILER::WT-FIXNUM-VALUE
-         COMPILER::MULTIPLE-VALUE-CHECK COMPILER::SHIFT>>
-         COMPILER::CO1SUBLIS COMPILER::DO-MACRO-EXPANSION
-         COMPILER::C2UNWIND-PROTECT COMPILER::C2CALL-LAMBDA
-         COMPILER::C2MEMBER!2 COMPILER::GET-INLINE-LOC
-         COMPILER::C1LAMBDA-FUN COMPILER::JUMPS-TO-P COMPILER::C1EXPR*
-         COMPILER::C2SETQ COMPILER::C2APPLY COMPILER::UNWIND-BDS
-         COMPILER::SET-BDS-BIND COMPILER::NEED-TO-PROTECT
-         COMPILER::C1FMLA COMPILER::TYPE-AND COMPILER::CMPFIX-ARGS
-         COMPILER::MAYBE-EVAL COMPILER::C2BLOCK-CLB COMPILER::SET-DBIND
-         COMPILER::C2LAMBDA-EXPR-WITHOUT-KEY
-         COMPILER::WT-LONG-FLOAT-VALUE COMPILER::C2DM-BIND-VL
-         COMPILER::WT-SHORT-FLOAT-VALUE COMPILER::T3SHARP-COMMA
-         COMPILER::COMPILER-CLEAR-COMPILER-PROPERTIES COMPILER::C2CATCH
-         COMPILER::C2EXPR-TOP* COMPILER::SET-JUMP-FALSE
-         COMPILER::CO1VECTOR-PUSH COMPILER::WT-V*-MACROS
-         COMPILER::ARGS-INFO-REFERRED-VARS COMPILER::SET-VS
-         COMPILER::WT-REQUIREDS COMPILER::C2RETURN-CCB
-         COMPILER::C2THROW COMPILER::CHECK-END
-         COMPILER::PUSH-CHANGED-VARS COMPILER::C2BLOCK-CCB
-         SYSTEM::ADD-DEBUG COMPILER::C2PSETQ COMPILER::C1ARGS
-         COMPILER::COMPILER-CC COMPILER::INLINE-PROC
-         COMPILER::CO1WRITE-CHAR COMPILER::COMPILER-DEF-HOOK
-         COMPILER::CAN-BE-REPLACED COMPILER::C2MULTIPLE-VALUE-PROG1
-         COMPILER::C2DM-BIND-LOC COMPILER::ADD-INFO
-         COMPILER::CO1SPECIAL-FIX-DECL COMPILER::C2LAMBDA-EXPR-WITH-KEY
-         COMPILER::FAST-READ COMPILER::C2RETURN-CLB
-         COMPILER::PROCLAIM-VAR)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::*)
-             COMMON-LISP::*)
-         COMPILER::COMPILE-FILE1)) 
+         COMPILER::C2CALL-UNKNOWN-GLOBAL COMPILER::WT-IF-PROCLAIMED
+         COMPILER::MY-CALL COMPILER::WT-GLOBAL-ENTRY
+         COMPILER::T3DEFUN-NORMAL COMPILER::C2STRUCTURE-REF
+         COMPILER::C2SWITCH COMPILER::C2CALL-GLOBAL
+         COMPILER::T3DEFUN-VARARG COMPILER::C1MAKE-VAR)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
              COMMON-LISP::T)
-         COMPILER::MAKE-INLINE-STRING COMPILER::GET-INLINE-INFO
-         COMPILER::C1STRUCTURE-REF1 COMPILER::CJF COMPILER::SET-VAR
-         COMPILER::CHECK-FORM-TYPE COMPILER::AND-FORM-TYPE
-         COMPILER::SUBLIS1-INLINE COMPILER::T3DEFCFUN
-         COMPILER::WT-INLINE-INTEGER COMPILER::C-FUNCTION-NAME
-         COMPILER::FIX-DOWN-ARGS COMPILER::ASSIGN-DOWN-VARS
-         COMPILER::WT-INLINE-FIXNUM COMPILER::C2GO COMPILER::CJT
-         COMPILER::TOO-FEW-ARGS COMPILER::C2PRINC COMPILER::C2CASE
-         COMPILER::C2LET* COMPILER::BOOLE3 COMPILER::COMPILER-PASS2
-         COMPILER::C1DM COMPILER::CHECK-VDECL COMPILER::C2LET
-         COMPILER::MYSUB COMPILER::CAN-BE-REPLACED*
-         COMPILER::ADD-FUNCTION-PROCLAMATION COMPILER::WT-IF-PROCLAIMED
-         COMPILER::C1MAP-FUNCTIONS COMPILER::ADD-FAST-LINK
-         COMPILER::WT-INLINE-LONG-FLOAT COMPILER::TOO-MANY-ARGS
-         COMPILER::C2MULTIPLE-VALUE-BIND COMPILER::C2PROGV
-         COMPILER::WT-INLINE-CHARACTER
-         COMPILER::ADD-FUNCTION-DECLARATION COMPILER::CMP-EXPAND-MACRO
-         COMPILER::C2MAPCAR COMPILER::INLINE-TYPE-MATCHES
-         COMPILER::C2FUNCALL-SFUN COMPILER::WT-MAKE-CCLOSURE
-         COMPILER::C2MAPCAN COMPILER::C2TAGBODY
-         COMPILER::WT-INLINE-COND COMPILER::C2MAPC
-         COMPILER::WT-INLINE-SHORT-FLOAT)) 
+         COMPILER::LINK COMPILER::C2LAMBDA-EXPR COMPILER::C2FUNCALL
+         COMPILER::INLINE-ARGS)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
              COMMON-LISP::T)
-         COMPILER::T3LOCAL-FUN COMPILER::T3LOCAL-DCFUN)) 
+         COMPILER::WT-INLINE-INTEGER COMPILER::ADD-FUNCTION-DECLARATION
+         COMPILER::C1STRUCTURE-REF1 COMPILER::ADD-FAST-LINK
+         COMPILER::AND-FORM-TYPE COMPILER::C2PRINC COMPILER::C2MAPCAN
+         COMPILER::CJT COMPILER::C2CASE COMPILER::WT-INLINE-LONG-FLOAT
+         COMPILER::SUBLIS1-INLINE COMPILER::MYSUB
+         COMPILER::ADD-FUNCTION-PROCLAMATION COMPILER::FIX-DOWN-ARGS
+         COMPILER::TOO-MANY-ARGS COMPILER::CMP-EXPAND-MACRO
+         COMPILER::C2MULTIPLE-VALUE-BIND COMPILER::C2GO
+         COMPILER::WT-INLINE-FIXNUM COMPILER::WT-INLINE-COND
+         COMPILER::C1MAP-FUNCTIONS COMPILER::C1DM
+         COMPILER::WT-MAKE-CCLOSURE COMPILER::CAN-BE-REPLACED*
+         COMPILER::C-FUNCTION-NAME COMPILER::C2LET* COMPILER::CJF
+         COMPILER::TOO-FEW-ARGS COMPILER::BOOLE3 COMPILER::T3DEFCFUN
+         COMPILER::C2FUNCALL-SFUN COMPILER::C2MAPC
+         COMPILER::CHECK-FORM-TYPE COMPILER::SET-VAR
+         COMPILER::C2TAGBODY COMPILER::CHECK-VDECL
+         COMPILER::GET-INLINE-INFO COMPILER::ASSIGN-DOWN-VARS
+         COMPILER::C2LET COMPILER::INLINE-TYPE-MATCHES
+         COMPILER::COMPILER-PASS2 COMPILER::C2PROGV COMPILER::C2MAPCAR
+         COMPILER::MAKE-INLINE-STRING COMPILER::WT-INLINE-CHARACTER
+         COMPILER::WT-INLINE-SHORT-FLOAT)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
                  COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
              COMMON-LISP::T)
-         COMPILER::T3DEFMACRO COMPILER::T3DEFENTRY COMPILER::T2DEFENTRY
-         COMPILER::DEFSYSFUN COMPILER::T2DEFMACRO)) 
+         COMPILER::T2DEFENTRY COMPILER::DEFSYSFUN COMPILER::T3DEFENTRY)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
                  COMMON-LISP::T COMMON-LISP::T)
              COMMON-LISP::T)
-         COMPILER::T3DEFUN COMPILER::T3DEFUN-LOCAL-ENTRY
-         COMPILER::C2STRUCTURE-SET COMPILER::T2DEFUN
+         COMPILER::T3DEFUN-LOCAL-ENTRY COMPILER::T3INIT-FUN
+         COMPILER::T2DEFUN COMPILER::T3DEFUN COMPILER::C2STRUCTURE-SET
          COMPILER::C1APPLY-OPTIMIZE)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
-             COMMON-LISP::T)
-         COMPILER::C2LAMBDA-EXPR COMPILER::C2FUNCALL
-         COMPILER::INLINE-ARGS COMPILER::LINK)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T)
-             COMMON-LISP::T)
-         COMPILER::T3INIT-FUN COMPILER::C2STRUCTURE-REF
-         COMPILER::WT-GLOBAL-ENTRY COMPILER::T3DEFUN-NORMAL
-         COMPILER::T3DEFUN-VARARG COMPILER::C1MAKE-VAR
-         COMPILER::C2SWITCH COMPILER::MY-CALL COMPILER::C2CALL-GLOBAL
-         COMPILER::C2CALL-UNKNOWN-GLOBAL)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
                  COMMON-LISP::*)
              COMMON-LISP::T)
          COMPILER::GET-OUTPUT-PATHNAME COMPILER::WT-SIMPLE-CALL)) 
-(COMMON-LISP::MAPC
-    (COMMON-LISP::LAMBDA (COMPILER::X)
-      (COMMON-LISP::SETF
-          (COMMON-LISP::GET COMPILER::X 'COMPILER::PROCLAIMED-CLOSURE)
-          COMMON-LISP::T))
-    '(COMPILER::CMP-ANON COMMON-LISP::COMPILE COMPILER::CMP-TMP-MACRO
-         COMMON-LISP::DISASSEMBLE)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::*) COMMON-LISP::T)
-         COMPILER::MAKE-VAR COMPILER::COMPILER-COMMAND
-         COMPILER::LIST*-INLINE COMMON-LISP::COMPILE-FILE
-         COMPILER::CS-PUSH COMPILER::MAKE-INFO COMPILER::FCALLN-INLINE
-         COMPILER::C2FSET COMPILER::MAKE-TAG COMPILER::WT-CLINK
-         COMPILER::LIST-INLINE COMPILER::MAKE-FUN COMPILER::MAKE-BLK)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::*)
-         COMPILER::T1EVAL-WHEN COMPILER::T1EXPR
-         COMPILER::WT-CHARACTER-LOC COMPILER::SET-LOC
-         COMPILER::CMP-TOPLEVEL-EVAL COMPILER::C2PROGN
-         COMPILER::WT-TO-STRING COMPILER::MEXPAND-DEFTYPE
-         COMPILER::WT-SHORT-FLOAT-LOC COMPILER::CMP-EVAL
-         COMPILER::WT-LOC COMPILER::C2AND COMPILER::C2EXPR
-         COMPILER::WT-LONG-FLOAT-LOC COMPILER::C2OR
-         COMPILER::WT-FIXNUM-LOC)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::T)
-         COMPILER::LTVP-EVAL COMPILER::FSET-FN-NAME COMPILER::C1MAPCON
-         COMPILER::FUNCTION-ARG-TYPES COMPILER::C1SHARP-COMMA
-         COMPILER::SAVE-AVMA COMPILER::C2TAGBODY-CCB COMPILER::VAR-LOC
-         COMPILER::WT-DOWN COMPILER::C1SETQ COMPILER::TAG-REF-CCB
-         COMPILER::T1DEFINE-STRUCTURE COMPILER::SAVE-FUNOB
-         COMPILER::C1VAR COMPILER::VV-STR COMPILER::C1RPLACA
-         COMPILER::INFO-SP-CHANGE COMPILER::BLK-REF-CCB
-         COMPILER::T1ORDINARY COMPILER::FIXNUM-LOC-P
-         COMPILER::FUN-REF-CCB COMPILER::C2GET COMPILER::FUN-NAME
-         COMPILER::FUN-P COMPILER::SCH-GLOBAL COMPILER::C1LET
-         COMPILER::C2TAGBODY-CLB COMPILER::C1UNWIND-PROTECT
-         COMPILER::SET-RETURN COMPILER::WT-VAR-DECL
-         COMPILER::VAR-REGISTER COMPILER::C1DEFINE-STRUCTURE
-         COMPILER::LTVP COMPILER::INLINE-POSSIBLE COMPILER::CHECK-VREF
-         COMPILER::TAG-NAME COMPILER::C2DM-RESERVE-VL
-         COMPILER::VAR-TYPE COMPILER::WT-LIST COMPILER::C1LET*
-         COMPILER::VARARG-P COMPILER::C1LOAD-TIME-VALUE
-         COMPILER::C2FUNCALL-AUX COMPILER::INFO-TYPE COMPILER::C1GET
-         COMPILER::C1NTHCDR-CONDITION COMPILER::C1AND
-         COMPILER::C1MULTIPLE-VALUE-CALL COMPILER::C1RPLACA-NTHCDR
-         COMPILER::INFO-VOLATILE COMPILER::INLINE-TYPE
-         COMPILER::LONG-FLOAT-LOC-P COMPILER::INFO-CHANGED-ARRAY
-         SYSTEM::UNDEF-COMPILER-MACRO COMPILER::DECL-BODY-SAFETY
-         COMPILER::TAG-VAR COMPILER::CHARACTER-LOC-P COMPILER::C2BIND
-         COMPILER::C1DECLARE COMPILER::CONS-TO-LISTA
-         COMPILER::C1MULTIPLE-VALUE-SETQ COMPILER::NAME-SD1
-         COMPILER::BLK-NAME COMPILER::PARSE-CVSPECS COMPILER::C1MAPL
-         COMPILER::AET-C-TYPE COMPILER::C2VAR COMPILER::COPY-INFO
-         COMPILER::C1PSETQ COMPILER::C1VREF COMPILER::FUN-REF
-         COMPILER::WT-H1 COMPILER::T1DEFCFUN COMPILER::T1PROGN
-         COMPILER::C1EVAL-WHEN COMPILER::FLAGS-POS COMPILER::WT-VS
-         COMPILER::C2VAR-KIND COMPILER::C1LENGTH
-         COMPILER::C1MULTIPLE-VALUE-BIND COMPILER::C2LOCATION
-         COMPILER::C2DM-RESERVE-V COMPILER::C2FUNCTION
-         COMPILER::WT-SWITCH-CASE COMPILER::C2TAGBODY-LOCAL
-         COMPILER::CONSTANT-FOLD-P COMPILER::NEED-TO-SET-VS-POINTERS
-         COMPILER::C1MAPCAN COMPILER::WT-FUNCALL-C COMPILER::WT-CCB-VS
-         COMPILER::C1RETURN-FROM COMPILER::GET-INCLUDED
-         COMPILER::C1BLOCK COMPILER::ADD-CONSTANT COMPILER::WT-VS-BASE
-         COMPILER::C1NTH-CONDITION COMPILER::FUN-LEVEL
-         COMPILER::UNWIND-NO-EXIT COMMON-LISP::PROCLAIM
-         COMPILER::C1PRINC COMPILER::C2EXPR* COMPILER::RESULT-TYPE
-         COMPILER::TAG-REF COMPILER::C1FUNCALL COMPILER::C1PROGN
-         COMPILER::MAXARGS COMPILER::UNDEFINED-VARIABLE COMPILER::C1THE
-         COMPILER::CMP-MACROEXPAND COMPILER::C1MAPCAR
-         COMPILER::DEFAULT-INIT COMPILER::C1STRUCTURE-SET
-         COMPILER::WT-SYMBOL-FUNCTION COMPILER::T1DEFUN
-         COMPILER::WT-DATA1 COMPILER::PUSH-DATA-INCF COMPILER::C1IF
-         COMPILER::C1NTHCDR COMPILER::ADD-SYMBOL
-         COMPILER::C1MULTIPLE-VALUE-PROG1 COMPILER::BLK-REF
-         COMPILER::WT-FUNCTION-LINK COMPILER::INFO-P COMPILER::C1FSET
-         COMPILER::C1PROGV COMPILER::C1ASSOC COMPILER::VAR-REF
-         COMPILER::ARGS-CAUSE-SIDE-EFFECT COMPILER::MDELETE-FILE
-         COMPILER::CMP-MACRO-FUNCTION COMPILER::C2DOWNWARD-FUNCTION
-         COMPILER::C2GO-LOCAL COMPILER::T1DEFLA COMPILER::VAR-REF-CCB
-         COMPILER::C1FLET COMPILER::C1LIST-NTH
-         COMPILER::ADD-LOOP-REGISTERS COMPILER::INFO-REFERRED-ARRAY
-         COMPILER::BLK-VALUE-TO-GO COMPILER::WT-VS*
-         COMPILER::NAME-TO-SD COMPILER::C1RPLACD
-         COMPILER::WT-DATA-PACKAGE-OPERATION COMPILER::C1SWITCH
-         COMPILER::C1CATCH COMPILER::WT-CAR COMPILER::C1MACROLET
-         COMPILER::OBJECT-TYPE COMPILER::C1MAPC COMPILER::T1CLINES
-         COMPILER::C1COMPILER-LET COMPILER::CMP-MACROEXPAND-1
-         COMPILER::C1TAGBODY COMPILER::C1MAPLIST COMPILER::PUSH-ARGS
-         COMPILER::T3ORDINARY COMPILER::C1MEMBER COMPILER::T1MACROLET
-         COMPILER::WT-CDR COMPILER::C1BOOLE3 COMPILER::PROCLAMATION
-         COMPILER::GET-LOCAL-RETURN-TYPE COMPILER::C1LOCAL-FUN
-         COMPILER::VAR-KIND COMPILER::WT1 COMPILER::TAG-SWITCH
-         COMPILER::C1OR COMPILER::C1STRUCTURE-REF
-         COMPILER::THE-PARAMETER COMPILER::VAR-REP-LOC
-         COMPILER::DECLARATION-TYPE COMPILER::TAG-P COMPILER::C2GETHASH
-         COMPILER::C1EXPR COMPILER::REPLACE-CONSTANT COMPILER::C1ECASE
-         COMPILER::FUN-CFUN COMPILER::SET-TOP COMPILER::TAG-LABEL
-         COMPILER::C1DM-BAD-KEY COMPILER::C1THROW COMPILER::C2GO-CCB
-         COMPILER::REP-TYPE COMPILER::C2VALUES
-         COMPILER::SHORT-FLOAT-LOC-P COMPILER::FUNCTION-RETURN-TYPE
-         COMPILER::ADD-OBJECT COMPILER::CTOP-WRITE COMPILER::C1MEMQ
-         COMPILER::WT-DOWNWARD-CLOSURE-MACRO COMPILER::C1TERPRI
-         COMPILER::T1DEFMACRO COMPILER::T3CLINES COMPILER::ADD-REG1
-         COMPILER::C1NTH COMPILER::C1ASH COMPILER::C1FMLA-CONSTANT
-         COMPILER::C2GO-CLB COMPILER::WT-CADR
-         COMPILER::C1BOOLE-CONDITION COMPILER::CLINK COMPILER::VAR-NAME
-         COMPILER::PUSH-ARGS-LISPCALL COMPILER::GET-ARG-TYPES
-         COMPILER::BLK-VAR COMPILER::C1APPLY COMPILER::CHECK-DOWNWARD
-         COMPILER::C1QUOTE COMPILER::TAG-REF-CLB
-         COMPILER::GET-LOCAL-ARG-TYPES COMPILER::REGISTER
-         COMPILER::BLK-P COMPILER::FUN-INFO COMPILER::C2RPLACD
-         COMPILER::ADD-OBJECT2 COMPILER::C2TAGBODY-BODY
-         COMPILER::T1DEFENTRY COMPILER::C1FUNCTION
-         COMPILER::C1DOWNWARD-FUNCTION COMPILER::SAFE-SYSTEM
-         COMPILER::C1GO COMPILER::BLK-EXIT COMPILER::VERIFY-DATA-VECTOR
-         COMPILER::C2RPLACA COMPILER::T2DECLARE COMPILER::MACRO-DEF-P
-         COMPILER::C1LABELS COMPILER::C1GETHASH COMPILER::FIX-OPT
-         COMPILER::SCH-LOCAL-FUN COMPILER::C1FUNOB
-         COMPILER::SET-PUSH-CATCH-FRAME COMPILER::GET-RETURN-TYPE
-         COMPILER::SET-UP-VAR-CVS COMPILER::TAG-UNWIND-EXIT
-         COMPILER::VAR-P COMPILER::C1ADD-GLOBALS COMPILER::TYPE-FILTER
-         COMPILER::WT-VV COMPILER::C1ASH-CONDITION COMPILER::VOLATILE
-         COMPILER::INLINE-BOOLE3-STRING COMPILER::C1LOCAL-CLOSURE
-         COMPILER::WRITE-BLOCK-OPEN COMPILER::ADD-ADDRESS
-         COMPILER::RESET-INFO-TYPE COMPILER::C1VALUES
-         COMPILER::BLK-REF-CLB COMPILER::C1STACK-LET)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::*) COMMON-LISP::*)
-         COMPILER::INLINE-BOOLE3)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T
-                 (COMMON-LISP::INTEGER -9223372036854775808
-                     9223372036854775807))
-             COMMON-LISP::T)
-         COMPILER::MEMOIZED-HASH-EQUAL)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
-             COMMON-LISP::*)
-         COMPILER::WT-INLINE-LOC COMPILER::NCONC-FILES
-         COMPILER::COMPILER-BUILD COMPILER::C2BLOCK-LOCAL
-         COMPILER::C2DECL-BODY COMPILER::C1SYMBOL-FUN COMPILER::C2BLOCK
-         COMPILER::C1BODY COMPILER::C2RETURN-LOCAL)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::*)
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
              COMMON-LISP::T)
-         COMPILER::C1LAMBDA-EXPR COMPILER::CMPWARN COMPILER::ADD-INIT
-         COMPILER::UNWIND-EXIT COMPILER::CMPNOTE COMPILER::CMPERR
-         COMPILER::C1CASE COMPILER::WT-COMMENT COMPILER::INIT-NAME
-         COMPILER::FAST-LINK-PROCLAIMED-TYPE-P COMPILER::WT-INTEGER-LOC
-         COMPILER::WT-CVAR)) 
+         COMPILER::T3LOCAL-DCFUN COMPILER::T3LOCAL-FUN)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
              COMMON-LISP::*)
-         COMPILER::C2IF COMPILER::WT-INLINE COMPILER::C2COMPILER-LET
-         COMPILER::C2FLET COMPILER::C2LABELS)) 
+         COMPILER::C2LABELS COMPILER::C2FLET COMPILER::C2IF
+         COMPILER::WT-INLINE COMPILER::C2COMPILER-LET)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
                  COMMON-LISP::T)
              COMMON-LISP::*)
-         COMPILER::C2RETURN-FROM COMPILER::C2APPLY-OPTIMIZE
-         COMPILER::C2DM COMPILER::C1DM-V COMPILER::C1DM-VL)) 
+         COMPILER::C2RETURN-FROM COMPILER::C2DM COMPILER::C1DM-VL
+         COMPILER::C2APPLY-OPTIMIZE COMPILER::C1DM-V)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
@@ -363,6 +216,36 @@
          COMPILER::T3DEFUN-AUX)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::*)
+         COMPILER::C2PROGN COMPILER::WT-LONG-FLOAT-LOC
+         COMPILER::WT-CHARACTER-LOC COMPILER::WT-TO-STRING
+         COMPILER::WT-LOC COMPILER::MEXPAND-DEFTYPE
+         COMPILER::CMP-TOPLEVEL-EVAL COMPILER::T1EVAL-WHEN
+         COMPILER::T1EXPR COMPILER::C2OR COMPILER::WT-FIXNUM-LOC
+         COMPILER::C2EXPR COMPILER::C2AND COMPILER::CMP-EVAL
+         COMPILER::SET-LOC COMPILER::WT-SHORT-FLOAT-LOC)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::*) COMMON-LISP::T)
+         COMPILER::MAKE-INFO COMPILER::FCALLN-INLINE
+         COMPILER::LIST-INLINE COMPILER::LIST*-INLINE
+         COMPILER::COMPILER-COMMAND COMPILER::MAKE-BLK
+         COMPILER::MAKE-FUN COMPILER::WT-CLINK COMPILER::C2FSET
+         COMPILER::MAKE-TAG COMPILER::CS-PUSH COMPILER::MAKE-VAR
+         COMMON-LISP::COMPILE-FILE)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::FIXNUM)
+         COMPILER::F-TYPE)) 
+(COMMON-LISP::MAPC
+    (COMMON-LISP::LAMBDA (COMPILER::X)
+      (COMMON-LISP::SETF
+          (COMMON-LISP::GET COMPILER::X 'COMPILER::PROCLAIMED-CLOSURE)
+          COMMON-LISP::T))
+    '(COMMON-LISP::DISASSEMBLE COMPILER::CMP-TMP-MACRO
+         COMPILER::CMP-ANON COMMON-LISP::COMPILE)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              ((COMMON-LISP::ARRAY COMMON-LISP::T (COMMON-LISP::*)))
              COMMON-LISP::T)
@@ -374,11 +257,9 @@
                  (COMMON-LISP::ARRAY COMMON-LISP::T (COMMON-LISP::*))
                  (COMMON-LISP::INTEGER -9223372036854775808
                      9223372036854775807)
-                 (COMMON-LISP::INTEGER -9223372036854775808
-                     9223372036854775807)
                  COMMON-LISP::T)
              COMMON-LISP::FIXNUM)
-         COMPILER::BSEARCHLEQ)) 
+         COMPILER::PUSH-ARRAY)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
@@ -386,10 +267,148 @@
                  (COMMON-LISP::ARRAY COMMON-LISP::T (COMMON-LISP::*))
                  (COMMON-LISP::INTEGER -9223372036854775808
                      9223372036854775807)
+                 (COMMON-LISP::INTEGER -9223372036854775808
+                     9223372036854775807)
                  COMMON-LISP::T)
              COMMON-LISP::FIXNUM)
-         COMPILER::PUSH-ARRAY)) 
+         COMPILER::BSEARCHLEQ)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::FIXNUM)
-         COMPILER::F-TYPE)) 
\ No newline at end of file
+         (COMMON-LISP::FUNCTION
+             ((COMMON-LISP::VECTOR COMMON-LISP::CHARACTER
+                  COMMON-LISP::*)
+              (COMMON-LISP::INTEGER -9223372036854775808
+                  9223372036854775807)
+              (COMMON-LISP::INTEGER -9223372036854775808
+                  9223372036854775807))
+             COMMON-LISP::T)
+         COMPILER::DASH-TO-UNDERSCORE-INT)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION
+             ((COMMON-LISP::INTEGER -9223372036854775808
+                  9223372036854775807)
+              (COMMON-LISP::INTEGER -9223372036854775808
+                  9223372036854775807))
+             COMMON-LISP::T)
+         COMPILER::MLIN)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T
+                 (COMMON-LISP::INTEGER -9223372036854775808
+                     9223372036854775807))
+             COMMON-LISP::T)
+         COMPILER::MEMOIZED-HASH-EQUAL)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION COMMON-LISP::NIL COMMON-LISP::T)
+         COMPILER::MACRO-ENV COMPILER::C1T COMPILER::PRINT-CURRENT-FORM
+         COMPILER::CCB-VS-PUSH COMPILER::C1NIL
+         COMPILER::WT-FASD-DATA-FILE COMPILER::INIT-ENV
+         COMPILER::WT-CVARS COMPILER::CVS-PUSH
+         COMPILER::WT-FIRST-VAR-ARG COMPILER::WT-NEXT-VAR-ARG
+         COMPILER::WT-DATA-FILE COMPILER::WT-C-PUSH
+         COMPILER::GAZONK-NAME COMPILER::WT-DATA-END
+         COMPILER::INC-INLINE-BLOCKS COMPILER::TAIL-RECURSION-POSSIBLE
+         COMPILER::RESET-TOP COMPILER::CLOSE-INLINE-BLOCKS
+         COMPILER::PRINT-COMPILER-INFO COMPILER::WFS-ERROR
+         COMPILER::VS-PUSH COMPILER::BABOON COMPILER::WT-DATA-BEGIN
+         COMPILER::ADD-LOAD-TIME-SHARP-COMMA)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
+             COMMON-LISP::FIXNUM)
+         COMPILER::PROCLAIMED-ARGD COMPILER::ANALYZE-REGS1
+         COMPILER::ANALYZE-REGS)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::*)
+             COMMON-LISP::T)
+         COMPILER::UNWIND-EXIT COMPILER::WT-COMMENT COMPILER::CMPERR
+         COMPILER::WT-CVAR COMPILER::FAST-LINK-PROCLAIMED-TYPE-P
+         COMPILER::C1CASE COMPILER::CMPWARN COMPILER::ADD-INIT
+         COMPILER::INIT-NAME COMPILER::WT-INTEGER-LOC COMPILER::CMPNOTE
+         COMPILER::C1LAMBDA-EXPR)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
+             COMMON-LISP::*)
+         COMPILER::C2BLOCK COMPILER::C1SYMBOL-FUN
+         COMPILER::C2BLOCK-LOCAL COMPILER::C2DECL-BODY
+         COMPILER::COMPILER-BUILD COMPILER::NCONC-FILES
+         COMPILER::WT-INLINE-LOC COMPILER::C2RETURN-LOCAL
+         COMPILER::C1BODY)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
+             COMMON-LISP::T)
+         COMPILER::WT-FIXNUM-VALUE COMPILER::DOLIST** COMPILER::CO1LDB
+         COMPILER::PUSH-REFERRED-WITH-START COMPILER::C2ASSOC!2
+         COMPILER::ADD-DEBUG-INFO COMPILER::WT-CHARACTER-VALUE
+         COMPILER::MAYBE-WT-C2DM-BIND-VL COMPILER::C2BIND-LOC
+         COMPILER::C2CATCH COMPILER::DO-REFERRED COMPILER::C2BLOCK-CLB
+         COMPILER::CO1CONSTANT-FOLD COMPILER::C2CALL-LOCAL
+         COMPILER::SHIFT<< COMPILER::C2UNWIND-PROTECT
+         COMPILER::C2MULTIPLE-VALUE-SETQ COMPILER::C2DM-BIND-VL
+         COMPILER::DOTIMES* COMPILER::REFERRED-LENGTH COMPILER::C1ARGS
+         COMPILER::CK-SPEC COMPILER::C2MULTIPLE-VALUE-CALL
+         COMPILER::C2CALL-LAMBDA COMPILER::CO1READ-BYTE
+         COMPILER::CO1VECTOR-PUSH COMPILER::STACK-LET COMPILER::CMPCK
+         COMPILER::MAYBE-EVAL COMPILER::COERCE-LOC COMPILER::C2PSETQ
+         SYSTEM::DEFINE-INLINE-FUNCTION COMPILER::WT-MAKE-DCLOSURE
+         COMPILER::COMPILER-CC COMPILER::WT-GO COMPILER::C1LAMBDA-FUN
+         COMPILER::C2RETURN-CLB COMPILER::C1DECL-BODY
+         COMPILER::PUSH-CHANGED-VARS COMPILER::GET-INLINE-LOC
+         COMPILER::CO1SUBLIS COMPILER::CHANGED-LENGTH COMPILER::CO1CONS
+         COMPILER::ARGS-INFO-REFERRED-VARS COMPILER::SET-JUMP-FALSE
+         COMPILER::MAKE-USER-INIT COMPILER::NEXT-CVAR
+         COMPILER::CAN-BE-REPLACED COMPILER::WT-V*-MACROS
+         COMPILER::NEXT-CMACRO COMPILER::C2RETURN-CCB
+         COMPILER::CO1SCHAR COMPILER::IS-CHANGED
+         COMMON-LISP::DEFINE-COMPILER-MACRO COMPILER::SET-DBIND
+         COMPILER::WT-H COMPILER::COERCE-LOC-STRUCTURE-REF
+         COMPILER::C1EXPR* COMPILER::IS-REFERRED COMPILER::SHIFT>>
+         COMPILER::WT COMPILER::TYPE-AND COMPILER::PRIN1-CMP
+         COMPILER::C2BIND-INIT COMPILER::RESULT-TYPE-FROM-ARGS
+         COMPILER::EQL-NOT-NIL COMPILER::C2APPLY COMPILER::C2BLOCK-CCB
+         COMPILER::WT-NL1 COMPILER::CO1WRITE-CHAR COMPILER::CFAST-WRITE
+         COMPILER::NEED-TO-PROTECT COMPILER::T3SHARP-COMMA
+         SYSTEM::ADD-DEBUG COMPILER::BIGNUM-EXPANSION-STORAGE
+         COMPILER::C2SETQ COMPILER::FLAG-P
+         COMPILER::PUSH-CHANGED-WITH-START COMPILER::CMPFIX-ARGS
+         COMPILER::CO1STRUCTURE-PREDICATE COMPILER::FAST-READ
+         COMPILER::C1CONSTANT-VALUE COMPILER::BASE-USED
+         COMPILER::PROCLAIM-VAR COMPILER::CO1TYPEP
+         COMPILER::SET-JUMP-TRUE COMPILER::TYPE>= COMPILER::DOTIMES**
+         COMPILER::CONVERT-CASE-TO-SWITCH COMPILER::C2MEMBER!2
+         COMPILER::DO-CHANGED COMPILER::ADD-INFO COMPILER::SET-VS
+         COMPILER::CHECK-FNAME-ARGS
+         COMPILER::COMPILER-CLEAR-COMPILER-PROPERTIES
+         COMPILER::C2MULTIPLE-VALUE-PROG1 COMPILER::NEXT-LABEL*
+         COMPILER::WT-VAR COMPILER::C2THROW COMPILER::INLINE-PROC
+         COMPILER::PUSH-REFERRED COMPILER::C2LIST-NTH-IMMEDIATE
+         COMPILER::C1FMLA COMPILER::PUSH-CHANGED
+         COMPILER::MULTIPLE-VALUE-CHECK COMPILER::MIA
+         COMPILER::WT-LABEL COMPILER::WT-NL
+         COMPILER::WT-SHORT-FLOAT-VALUE COMPILER::SET-BDS-BIND
+         COMPILER::DO-ARRAY COMPILER::WT-REQUIREDS
+         COMPILER::C2EXPR-TOP* COMPILER::C2DM-BIND-LOC
+         COMPILER::DOLIST* SYSTEM::SWITCH-FINISH
+         COMPILER::IS-REP-REFERRED COMPILER::WT-LONG-FLOAT-VALUE
+         COMPILER::C1SETQ1 COMPILER::FLAGS COMPILER::CO1EQL
+         COMPILER::CHECK-END COMPILER::NEXT-LABEL COMPILER::CK-VL
+         COMPILER::ARGS-INFO-CHANGED-VARS COMPILER::C1PROGN*
+         COMPILER::C2DM-BIND-INIT COMPILER::STRUCT-TYPE-OPT
+         COMPILER::UNWIND-BDS COMPILER::SAFE-COMPILE
+         COMPILER::CO1READ-CHAR COMPILER::JUMPS-TO-P SYSTEM::SWITCH
+         COMPILER::NEXT-CFUN COMPILER::CO1WRITE-BYTE
+         COMPILER::DOWNWARD-FUNCTION COMPILER::COMPILER-DEF-HOOK
+         COMPILER::C2STACK-LET COMPILER::C2EXPR-TOP
+         COMPILER::C2LAMBDA-EXPR-WITH-KEY COMPILER::IN-ARRAY
+         COMPILER::C2LAMBDA-EXPR-WITHOUT-KEY)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::*)
+             COMMON-LISP::*)
+         COMPILER::COMPILE-FILE1)) 
\ No newline at end of file
--- gcl-2.6.12.orig/config.sub
+++ gcl-2.6.12/config.sub
@@ -1,8 +1,8 @@
 #! /bin/sh
 # Configuration validation subroutine script.
-#   Copyright 1992-2014 Free Software Foundation, Inc.
+#   Copyright 1992-2015 Free Software Foundation, Inc.
 
-timestamp='2014-05-01'
+timestamp='2015-08-20'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -25,7 +25,7 @@ timestamp='2014-05-01'
 # of the GNU General Public License, version 3 ("GPLv3").
 
 
-# Please send patches with a ChangeLog entry to config-patches@gnu.org.
+# Please send patches to <config-patches@gnu.org>.
 #
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
@@ -68,7 +68,7 @@ Report bugs and patches to <config-patch
 version="\
 GNU config.sub ($timestamp)
 
-Copyright 1992-2014 Free Software Foundation, Inc.
+Copyright 1992-2015 Free Software Foundation, Inc.
 
 This is free software; see the source for copying conditions.  There is NO
 warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
@@ -117,7 +117,7 @@ maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-
 case $maybe_os in
   nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
   linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
-  knetbsd*-gnu* | netbsd*-gnu* | \
+  knetbsd*-gnu* | netbsd*-gnu* | netbsd*-eabi* | \
   kopensolaris*-gnu* | \
   storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
@@ -255,12 +255,13 @@ case $basic_machine in
 	| arc | arceb \
 	| arm | arm[bl]e | arme[lb] | armv[2-8] | armv[3-8][lb] | armv7[arm] \
 	| avr | avr32 \
+	| ba \
 	| be32 | be64 \
 	| bfin \
 	| c4x | c8051 | clipper \
 	| d10v | d30v | dlx | dsp16xx \
-	| epiphany \
-	| fido | fr30 | frv \
+	| e2k | epiphany \
+	| fido | fr30 | frv | ft32 \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| hexagon \
 	| i370 | i860 | i960 | ia64 \
@@ -302,9 +303,10 @@ case $basic_machine in
 	| pdp10 | pdp11 | pj | pjl \
 	| powerpc | powerpc64 | powerpc64le | powerpcle \
 	| pyramid \
+	| riscv32 | riscv64 \
 	| rl78 | rx \
 	| score \
-	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[34]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
+	| sh | sh[1234] | sh[24]a | sh[24]aeb | sh[23]e | sh[234]eb | sheb | shbe | shle | sh[1234]le | sh3ele \
 	| sh64 | sh64le \
 	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
 	| sparcv8 | sparcv9 | sparcv9b | sparcv9v \
@@ -312,6 +314,7 @@ case $basic_machine in
 	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
 	| ubicom32 \
 	| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \
+	| visium \
 	| we32k \
 	| x86 | xc16x | xstormy16 | xtensa \
 	| z8k | z80)
@@ -326,6 +329,9 @@ case $basic_machine in
 	c6x)
 		basic_machine=tic6x-unknown
 		;;
+	leon|leon[3-9])
+		basic_machine=sparc-$basic_machine
+		;;
 	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)
 		basic_machine=$basic_machine-unknown
 		os=-none
@@ -371,12 +377,13 @@ case $basic_machine in
 	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* | arceb-* \
 	| arm-*  | armbe-* | armle-* | armeb-* | armv*-* \
 	| avr-* | avr32-* \
+	| ba-* \
 	| be32-* | be64-* \
 	| bfin-* | bs2000-* \
 	| c[123]* | c30-* | [cjt]90-* | c4x-* \
 	| c8051-* | clipper-* | craynv-* | cydra-* \
 	| d10v-* | d30v-* | dlx-* \
-	| elxsi-* \
+	| e2k-* | elxsi-* \
 	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
@@ -423,12 +430,13 @@ case $basic_machine in
 	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
 	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* \
 	| pyramid-* \
+	| riscv32-* | riscv64-* \
 	| rl78-* | romp-* | rs6000-* | rx-* \
 	| sh-* | sh[1234]-* | sh[24]a-* | sh[24]aeb-* | sh[23]e-* | sh[34]eb-* | sheb-* | shbe-* \
 	| shle-* | sh[1234]le-* | sh3ele-* | sh64-* | sh64le-* \
 	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
 	| sparclite-* \
-	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \
+	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx*-* \
 	| tahoe-* \
 	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
 	| tile*-* \
@@ -436,6 +444,7 @@ case $basic_machine in
 	| ubicom32-* \
 	| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \
 	| vax-* \
+	| visium-* \
 	| we32k-* \
 	| x86-* | x86_64-* | xc16x-* | xps100-* \
 	| xstormy16-* | xtensa*-* \
@@ -512,6 +521,9 @@ case $basic_machine in
 		basic_machine=i386-pc
 		os=-aros
 		;;
+        asmjs)
+		basic_machine=asmjs-unknown
+		;;
 	aux)
 		basic_machine=m68k-apple
 		os=-aux
@@ -773,6 +785,9 @@ case $basic_machine in
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
+	leon-*|leon[3-9]-*)
+		basic_machine=sparc-`echo $basic_machine | sed 's/-.*//'`
+		;;
 	m68knommu)
 		basic_machine=m68k-unknown
 		os=-linux
@@ -828,6 +843,10 @@ case $basic_machine in
 		basic_machine=powerpc-unknown
 		os=-morphos
 		;;
+	moxiebox)
+		basic_machine=moxie-unknown
+		os=-moxiebox
+		;;
 	msdos)
 		basic_machine=i386-pc
 		os=-msdos
@@ -1360,7 +1379,7 @@ case $os in
 	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
 	      | -sym* | -kopensolaris* | -plan9* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
-	      | -aos* | -aros* \
+	      | -aos* | -aros* | -cloudabi* | -sortix* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
@@ -1373,7 +1392,7 @@ case $os in
 	      | -cygwin* | -msys* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
 	      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
 	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
-	      | -uxpv* | -beos* | -mpeix* | -udk* \
+	      | -uxpv* | -beos* | -mpeix* | -udk* | -moxiebox* \
 	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
 	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
--- gcl-2.6.12.orig/h/att_ext.h
+++ gcl-2.6.12/h/att_ext.h
@@ -257,8 +257,8 @@ object cddddr();
 object nth();
 object nthcdr();
 object make_cons();
-object list(int,...);
-object listA(int,...);
+object list(fixnum,...);
+object listA(fixnum,...);
 object append();
 object copy_list();
 object make_list();
@@ -399,6 +399,8 @@ object coerce_to_namestring();
 EXTER object sKupcase;
 EXTER object sKdowncase;
 EXTER object sKcapitalize;
+EXTER object sKpreserve;
+EXTER object sKinvert;
 EXTER object sKstream;
 EXTER object sKreadably;
 EXTER object sKescape;
--- gcl-2.6.12.orig/h/compdefs.h
+++ gcl-2.6.12/h/compdefs.h
@@ -51,7 +51,6 @@ complex
 I
 NOT_SPECIAL
 VOL
-compiled_functionp(x)
 mpz_even_p(x)
 mpz_odd_p(x)
 mpz_sgn(x)
@@ -115,5 +114,12 @@ SIGNED_CHAR(x)
 FEerror(x,y...)
 FEwrong_type_argument(x,y)
 BIT_ENDIAN(x)
+integerp(x)
+rationalp(x)
+floatp(x)
+realp(x)
+numberp(x)
+vectorp(x)
+arrayp(x)
+compiled_function_p(x)
 pathname_designatorp(x)
-pathnamep(x)
--- gcl-2.6.12.orig/h/compprotos.h
+++ gcl-2.6.12/h/compprotos.h
@@ -27,8 +27,8 @@ object get_lcm(object,object);
 object integer_count(object);
 object integer_length(object);
 object integer_shift(object,object);
-object listA(int,...);
-object list(int,...);
+object listA(fixnum,...);
+object list(fixnum,...);
 object log_op2(fixnum,object,object);
 object make_cons(object,object);
 object make_fixnum1(long);
--- gcl-2.6.12.orig/h/elf64_mips_reloc.h
+++ gcl-2.6.12/h/elf64_mips_reloc.h
@@ -22,14 +22,33 @@
     case R_MIPS_GOT_DISP:
     case R_MIPS_CALL16:
     case R_MIPS_GOT_PAGE:
+    case R_MIPS_GOT_HI16:
+    case R_MIPS_GOT_LO16:
+    case R_MIPS_CALL_HI16:
+    case R_MIPS_CALL_LO16:
       recurse(s+a);
       gote=got+(a>>32)-1;
       a&=MASK(32);
-      store_val(where,MASK(16),((void *)gote-(void *)got));
       if (s>=ggot && s<ggote) {
         massert(!write_stub(s,got,gote));
       } else
         *gote=s+(a&~MASK(16))+((a&0x8000)<<1);
+      ((Rela *)r)->r_addend=((void *)gote-(void *)got)-s;
+      switch(tp) {
+        case R_MIPS_GOT_HI16:
+        case R_MIPS_CALL_HI16:
+	  r->r_info=((ul)R_MIPS_HI16<<56)|(r->r_info&MASK(32));
+	  relocate(sym1,r,((Rela *)r)->r_addend,start,got,gote);
+	  break;
+        case R_MIPS_GOT_LO16:
+        case R_MIPS_CALL_LO16:
+	  r->r_info=((ul)R_MIPS_LO16<<56)|(r->r_info&MASK(32));
+	  relocate(sym1,r,((Rela *)r)->r_addend,start,got,gote);
+	  break;
+        default:
+	  store_val(where,MASK(16),((void *)gote-(void *)got));
+	  break;
+      }
       break;
     case R_MIPS_GOT_OFST:
       recurse(s+a);
--- gcl-2.6.12.orig/h/elf64_mips_reloc_special.h
+++ gcl-2.6.12/h/elf64_mips_reloc_special.h
@@ -108,6 +108,10 @@ label_got_symbols(void *v1,Shdr *sec1,Sh
       for (v=v1+sec->sh_offset,ve=v+sec->sh_size,r=v;v<ve;v+=sec->sh_entsize,r=v)
 	if (ELF_R_TYPE(r->r_info)==R_MIPS_CALL16||
 	    ELF_R_TYPE(r->r_info)==R_MIPS_GOT_DISP||
+	    ELF_R_TYPE(r->r_info)==R_MIPS_GOT_HI16||
+	    ELF_R_TYPE(r->r_info)==R_MIPS_GOT_LO16||
+	    ELF_R_TYPE(r->r_info)==R_MIPS_CALL_HI16||
+	    ELF_R_TYPE(r->r_info)==R_MIPS_CALL_LO16||
 	    ELF_R_TYPE(r->r_info)==R_MIPS_GOT_PAGE) {
 
 	  sym=sym1+ELF_R_SYM(r->r_info);
--- gcl-2.6.12.orig/h/lu.h
+++ gcl-2.6.12/h/lu.h
@@ -143,7 +143,7 @@ struct hashtable {
   int ht_size;
   short ht_test;
   short ht_static;
-  SPAD;
+  struct htent *ht_cache;
 
 };
 
@@ -290,6 +290,8 @@ struct random {
 struct readtable {
   FIRSTWORD;
   struct rtent *rt_self;
+  object rt_case;
+  SPAD;
 };
 
 struct pathname {
--- gcl-2.6.12.orig/h/notcomp.h
+++ gcl-2.6.12/h/notcomp.h
@@ -373,3 +373,4 @@ typedef struct {void *a,*b,*c,*d;} gmp_r
 EXTER gmp_randfnptr_t Mersenne_Twister_Generator_Noseed;
 #endif
 
+#define collect(p_,f_) (p_)=&(*(p_)=(f_))->c.c_cdr
--- gcl-2.6.12.orig/h/object.h
+++ gcl-2.6.12/h/object.h
@@ -249,6 +249,9 @@ struct freelist {
 #define FL_LINK F_LINK
 #define SET_LINK(x,val) F_LINK(x) = (address_int) (val)
 #define OBJ_LINK(x) ((object) INT_TO_ADDRESS(F_LINK(x)))
+#define PHANTOM_FREELIST(x) ({struct freelist f;(object)((void *)&x+((void *)&f-(void *)&f.f_link));})
+#define FREELIST_TAIL(tm_) ({struct typemanager *_tm=tm_;\
+      _tm->tm_free==OBJNULL ? PHANTOM_FREELIST(_tm->tm_free) : _tm->tm_tail;})
 
 #define	FREE	(-1)		/*  free object  */
 
@@ -261,6 +264,8 @@ struct typemanager {
   long      tm_nppage;           /*  number per page  */
   object    tm_free;             /*  free list  */
 				 /*  Note that it is of type object.  */
+  object    tm_tail;             /*  free list tail  */
+				 /*  Note that it is of type object.  */
   long	    tm_nfree;            /*  number of free elements  */
   long	    tm_npage;            /*  number of pages  */
   long	    tm_maxpage;          /*  maximum number of pages  */
@@ -562,6 +567,9 @@ EXTER unsigned plong signals_allowed, si
 /* #define equal(a_,b_)  ({register object _a=(a_);register object _b=(b_);_a==_b || (!IMMNIL(_a)&&!IMMNIL(_b)&&equal1(_a,_b));}) */
 /* #define equalp(a_,b_) ({register object _a=(a_);register object _b=(b_);_a==_b || (_a!=Cnil&&_b!=Cnil&&equalp1(_a,_b));}) */
 
-#define eql(a_,b_)    ({register object _a=(a_);register object _b=(b_);_a==_b ? TRUE : (IMMNIL(_a)||IMMNIL(_b) ? FALSE : eql1(_a,_b));})
+#define eql_is_eq(a_) (is_imm_fixnum(a_)||valid_cdr(a_)||(a_->d.t>t_complex))
+
+#define eql(a_,b_)    ({register object _a=(a_);register object _b=(b_);\
+      _a==_b ? TRUE : (eql_is_eq(_a)||eql_is_eq(_b)||_a->d.t!=_b->d.t ? FALSE : eql1(_a,_b));})
 #define equal(a_,b_)  ({register object _a=(a_);register object _b=(b_);_a==_b ? TRUE : (IMMNIL(_a)||IMMNIL(_b) ? FALSE : equal1(_a,_b));})
 #define equalp(a_,b_) ({register object _a=(a_);register object _b=(b_);_a==_b ? TRUE : (_a==Cnil||_b==Cnil ? FALSE : equalp1(_a,_b));})
--- gcl-2.6.12.orig/h/protoize.h
+++ gcl-2.6.12/h/protoize.h
@@ -1961,3 +1961,6 @@ do_gcl_abort(void);
 
 int
 vsystem(const char *);
+
+object
+n_cons_from_x(fixnum,object);
--- gcl-2.6.12.orig/h/type.h
+++ gcl-2.6.12/h/type.h
@@ -134,7 +134,7 @@ enum smmode {			/*  stream mode  */
 #define fixnump(a_)    SPP(a_,fixnum)
 #define readtablep(a_) SPP(a_,readtable)
 #define functionp(a_)  ({enum type _t=type_of(a_);_t>=t_cfun && _t<=t_closure;})
-#define compiled_functionp(a_)  functionp(a_)
+#define compiled_function_p(a_)  functionp(a_)
 
 #define integerp(a_) ({enum type _tp=type_of(a_); _tp >= t_fixnum     && _tp <= t_bignum;})
 #define non_negative_integerp(a_) ({enum type _tp=type_of(a_); (_tp == t_fixnum && fix(a_)>=0) || (_tp==t_bignum && big_sign(a_)>=0);})
--- gcl-2.6.12.orig/lsp/gcl_arraylib.lsp
+++ gcl-2.6.12/lsp/gcl_arraylib.lsp
@@ -27,14 +27,14 @@
 (proclaim '(optimize (safety 2) (space 3)))
 
 (defvar *baet-hash* (make-hash-table :test 'equal))
-(defun best-array-element-type (type)
-  (or (gethash type *baet-hash*)
-      (setf (gethash type *baet-hash*)
-	    (if type
-		(car (member type '(character bit signed-char unsigned-char signed-short unsigned-short
-					fixnum short-float long-float t)
-			     :test 'subtypep)) t)))))
-	 
+(defun best-array-element-type (type &aux
+				     (tps '(character bit signed-char unsigned-char signed-short unsigned-short
+						      fixnum short-float long-float t)))
+  (if type
+    (or (car (member type tps))
+	(gethash type *baet-hash*)
+	(setf (gethash type *baet-hash*) (car (member type tps :test 'subtypep)))) t))
+
 (defun upgraded-array-element-type (type &optional environment)
   (declare (ignore environment))
   (best-array-element-type type))
--- gcl-2.6.12.orig/lsp/gcl_autoload.lsp
+++ gcl-2.6.12/lsp/gcl_autoload.lsp
@@ -267,7 +267,7 @@
                      (push (list (nth nfree *type-list*) typename)
                            link-alist))))))
     (terpri)
-    (dolist (info (reverse info-list))
+    (dolist (info (nreverse info-list))
       (apply #'format t "~8D/~D~19T~6,1F%~@[~8D~]~35T~{~A~^ ~}"
              (append (cdr info)
                      (if  (assoc (car info) link-alist)
--- gcl-2.6.12.orig/lsp/gcl_debug.lsp
+++ gcl-2.6.12/lsp/gcl_debug.lsp
@@ -167,7 +167,7 @@
      ,@ (do ((v (cdr lis) (cdr v))
 	     (i 0 (1+ i))
 	     (res))
-	    ((null v)(reverse res))
+	    ((null v)(nreverse res))
 	  (push `(setf ,(car v) (mv-ref ,i)) res))))
 
 (defmacro mv-values (&rest lis)
@@ -175,7 +175,7 @@
      ,@ (do ((v (cdr lis) (cdr v))
 	     (i 0 (1+ i))
 	     (res))
-	    ((null v)(reverse res))
+	    ((null v)(nreverse res))
 	  (push `(set-mv ,i ,(car v)) res))))
 
 ;;start a lisp debugger loop.   Exit it by using :step
--- gcl-2.6.12.orig/lsp/gcl_defmacro.lsp
+++ gcl-2.6.12/lsp/gcl_defmacro.lsp
@@ -103,7 +103,7 @@
           (push `(unless (endp ,(dm-nth-cdr (cdr ac) (car ac)))
                          (dm-too-many-arguments)) body))
   (unless envp (push `(declare (ignore ,env)) body))
-  (list doc ppn `(lambda-block ,name ,(reverse *dl*) ,@(append decls body)))
+  (list doc ppn `(lambda-block ,name ,(nreverse *dl*) ,@(append decls body)))
   )
 
 (defun dm-vl (vl whole top)
--- gcl-2.6.12.orig/lsp/gcl_directory.lsp
+++ gcl-2.6.12/lsp/gcl_directory.lsp
@@ -41,7 +41,7 @@
 	 (l (length yy))
 	 (y (link-expand (vector-push-string yy s) l))
 	 (y (if (eq y yy) y (make-frame y))))
-    (when (or (eq (stat z) :directory) (zerop (length z)))
+    (when (or (eq (stat1 z) :directory) (zerop (length z)))
       (cond ((eq (car x) :wild-inferiors) (recurse-dir z y f))
 	    (x (walk-dir z y (lambda (q e l)
 			       (declare (ignore l))
--- gcl-2.6.12.orig/lsp/gcl_evalmacros.lsp
+++ gcl-2.6.12/lsp/gcl_evalmacros.lsp
@@ -23,178 +23,146 @@
 (in-package :si)
 
 
-(eval-when (compile) (proclaim '(optimize (safety 2) (space 3))))
+;(eval-when (compile) (proclaim '(optimize (safety 2) (space 3))))
 ;(eval-when (eval compile) (defun si:clear-compiler-properties (symbol)))
-(eval-when (eval compile) (setq si:*inhibit-macro-special* nil))
-
-(defmacro sgen (&optional (pref "G"))
-  `(load-time-value (gensym ,pref)))
+(eval-when (eval compile)
+  (setq si:*inhibit-macro-special* nil)
+  (defmacro ?cons (f x &aux (s (sgen "?CONS"))) `(let ((,s ,x)) (if (cdr ,s) (cons ,f ,s) (car ,s))))
+  (defmacro ?list (x &aux (s (sgen "?LIST"))) `(let ((,s ,x)) (when ,s (list ,s))))
+  (defmacro collect (v r rp np &aux (s (sgen "COLLECT")))
+    `(let ((,s ,v)) (setf rp (if rp (rplacd rp (list ,s)) (setq r ,s)) rp np)))
+  (defmacro ?let (k kf r) `(let ((r ,r)) (if (eq ,k ,kf) r `(let ((,,k ,,kf)) (declare (ignorable ,,k)) ,r))))
+  (defmacro ?key (x &aux (s (sgen "?KEY"))) `(if (or (constantp ,x) (symbolp ,x)) ,x ',s)))
 
+(defmacro sgen (&optional (pref "G")) `(load-time-value (gensym ,pref)))
 
 (defmacro defvar (var &optional (form nil form-sp) doc-string)
-  `(progn (si:*make-special ',var)
-	  ,(if doc-string
-	       `(si:putprop ',var ,doc-string 'variable-documentation))
-	  ,(if form-sp
-	       `(or (boundp ',var)
-		    (setq ,var ,form)))
-	  ',var)
-	  )
+  (declare (optimize (safety 1)))
+  `(progn (*make-special ',var)
+	  ,@(when doc-string `((putprop ',var ,doc-string 'variable-documentation)))
+	  ,@(when form-sp `((unless (boundp ',var) (setq ,var ,form))))
+	  ',var))
 
 (defmacro defparameter (var form &optional doc-string)
-  (if doc-string
-      `(progn (si:*make-special ',var)
-              (si:putprop ',var ,doc-string 'variable-documentation)
-              (setq ,var ,form)
-              ',var)
-      `(progn (si:*make-special ',var)
-              (setq ,var ,form)
-              ',var)))
+  (declare (optimize (safety 1)))
+  `(progn (*make-special ',var)
+	  ,@(when doc-string `((putprop ',var ,doc-string 'variable-documentation)))
+	  (setq ,var ,form)
+	  ',var))
 
 (defmacro defconstant (var form &optional doc-string)
-  (if doc-string
-      `(progn (si:*make-constant ',var ,form)
-              (si:putprop ',var ,doc-string 'variable-documentation)
-              ',var)
-      `(progn (si:*make-constant ',var ,form)
-              ',var)))
+  (declare (optimize (safety 1)))
+  `(progn (*make-constant ',var ,form)
+	  ,@(when doc-string `((putprop ',var ,doc-string 'variable-documentation)))
+	  ',var))
 
 
 ;;; Each of the following macros is also defined as a special form.
 ;;; Thus their names need not be exported.
 
-(defmacro and (&rest forms)
-  (if (endp forms)
-      t
-      (let ((x (reverse forms)))
-           (do ((forms (cdr x) (cdr forms))
-                (form (car x) `(if ,(car forms) ,form)))
-               ((endp forms) form))))
-  )
-
-(defmacro or (&rest forms)
-  (if (endp forms)
-      nil
-      (let ((x (reverse forms)))
-           (do ((forms (cdr x) (cdr forms))
-                (form (car x)
-                      (let ((temp (gensym)))
-                           `(let ((,temp ,(car forms)))
-                                 (if ,temp ,temp ,form)))))
-               ((endp forms) form))))
-  )
-               
-(defun parse-body-header (x &optional doc decl ctps &aux (a (car x)))
-  (cond 
-   ((unless (or doc ctps) (and (stringp a) (cdr x))) (parse-body-header (cdr x) a decl ctps))
-   ((unless ctps (when (consp a) (eq (car a) 'declare)))  (parse-body-header (cdr x) doc (cons a decl) ctps))
-   ((when (consp a) (eq (car a) 'check-type)) (parse-body-header (cdr x) doc decl (cons a ctps)))
-   (t (values doc (nreverse decl) (nreverse ctps) x))))
+(defmacro and (&rest forms &aux r rp np)
+  (declare (optimize (safety 1)))
+  (do ((y forms))((endp y) (if forms r t))
+    (let ((x (pop y)))
+      (if (constantp x) (unless (if (eval x) y) (collect x r rp np) (setq y nil))
+	(if y (collect `(if ,@(setq np (list x))) r rp np)
+	  (collect x r rp np))))))
+
+(defmacro or (&rest forms &aux r rp np (s (sgen "OR")))
+  (declare (optimize (safety 1)))
+  (do ((y forms))((endp y) r)
+    (let ((x (pop y)))
+      (if (constantp x) (when (eval x) (collect x r rp np) (setq y nil))
+	(if (symbolp x) (collect `(if ,x ,@(setq np (list x))) r rp np)
+	  (if y (collect `(let ((,s ,x)) (if ,s ,@(setq np (list s)))) r rp np)
+	    (collect x r rp np)))))))
+
+(defun parse-body-header (x)
+  (let* ((doc x)(x (or (when (stringp (car x)) (cdr x)) x))
+	 (dec x)(x (member-if-not (lambda (x) (when (consp x) (eq (car x) 'declare))) x))
+	 (ctp x)(x (member-if-not (lambda (x) (when (consp x) (eq (car x) 'check-type))) x)))
+    (values (car (ldiff doc dec)) (ldiff dec ctp) (ldiff ctp x) x)))
 
 (defmacro locally (&rest body)
   (multiple-value-bind
-   (doc decls ctps body)
+   (doc dec)
    (parse-body-header body)
+   (declare (ignore doc))
    `(let (,@(mapcan (lambda (x &aux (z (pop x))(z (if (eq z 'type) (pop x) z)))
 		      (case z
 			    ((ftype inline notinline optimize) nil)
 			    (otherwise (mapcar (lambda (x) (list x x)) x))))
-		   (apply 'append (mapcar 'cdr decls))))
-      ,@(when doc (list doc))
-      ,@decls
-      ,@ctps
+		   (apply 'append (mapcar 'cdr dec))))
       ,@body)))
 
-(defmacro loop (&rest body &aux (tag (gensym)))
-  `(block nil (tagbody ,tag (progn ,@body) (go ,tag))))
+(defmacro loop (&rest body &aux (tag (sgen "LOOP")))
+  `(block nil (tagbody ,tag ,(?cons 'progn body) (go ,tag))))
 
-(import 'while 'user)
 (defmacro while (test &rest forms)
- `(loop (unless ,test (return)) ,@forms) )
+ `(loop (unless ,test (return)) ,@forms))
 
 (defmacro defmacro (name vl &rest body)
   `(si:define-macro ',name (si:defmacro* ',name ',vl ',body)))
 
 (defmacro defun (name lambda-list &rest body)
-  (multiple-value-bind (doc decl body)
-       (find-doc body nil)
-    (if doc
-        `(progn (setf (get ',name 'si:function-documentation) ,doc)
-                (setf (symbol-function ',name)
-                      #'(lambda ,lambda-list
-                          ,@decl (block ,name ,@body)))
-                ',name)
-        `(progn (setf (symbol-function ',name)
-                      #'(lambda ,lambda-list
-                          ,@decl (block ,name ,@body)))
-                ',name))))
+  (multiple-value-bind
+      (doc dec ctp body)
+      (parse-body-header body)
+    `(progn ,@(when doc `((setf (get ',name 'function-documentation) ,doc)))
+	    (setf (symbol-function ',name) (lambda ,lambda-list  ,@dec ,@ctp (block ,name ,@body)))
+	    ',name)))
 
 ; assignment
 
 (defmacro psetq (&rest args)
-   (do ((l args (cddr l))
-        (forms nil)
-        (bindings nil))
-       ((endp l) (list* 'let* (nreverse bindings) (nreverse (cons nil forms))))
-       (declare (object l))
-       (let ((sym (gensym)))
-            (push (list sym (cadr l)) bindings)
-            (push (list 'setq (car l) sym) forms)))
-   )
+  (declare (optimize (safety 1)))
+  (assert (evenp (length args)))
+  (let ((x (let ((i 0)) (mapcon (lambda (x) (when (oddp (incf i)) `((,(cadr x) ,(car x) ,(gensym))))) args))))
+    (when x
+      `(let* ,(mapcar (lambda (x) `(,(caddr x) ,(car x))) x)
+	 (setq ,@(mapcan 'cdr x))
+	 nil))))
 
 ; conditionals
+(defmacro cond (&rest clauses &aux r rp np (s (sgen "COND")))
+  (declare (optimize (safety 1)))
+  (do ((y clauses))((endp y) r)
+    (let* ((x (pop y))(z (pop x)))
+      (if (constantp z) (when (eval z) (collect (if x (?cons 'progn x) z) r rp np) (setq y nil))
+	(if x (collect `(if ,z ,@(setq np (list (?cons 'progn x)))) r rp np)
+	  (if (symbolp z) (collect `(if ,z ,@(setq np (list z))) r rp np)
+	    (if y (collect `(let ((,s ,z)) (if ,s ,@(setq np (list s)))) r rp np)
+	      (collect `(values ,z) r rp np))))))))
+
+(defmacro when (pred &rest body &aux (x (?cons 'progn body)))
+  (declare (optimize (safety 1)))
+  (if (constantp pred) (if (eval pred) x) `(if ,pred ,x)))
+
+(defmacro unless (pred &rest body &aux (x (?cons 'progn body)))
+  (declare (optimize (safety 1)))
+  (if (constantp pred) (if (not (eval pred)) x) `(if (not ,pred) ,x)))
 
-(defmacro cond (&rest clauses &aux (form nil))
-  (let ((x (reverse clauses)))
-    (dolist (l x form)
-      (cond ((endp (cdr l))
-	     (if (or (constantp (car l)) (eq l (car x)))
-		 (setq form (car l))
-	       (let ((sym (gensym)))
-		 (setq form `(let ((,sym ,(car l))) (if ,sym ,sym ,form))))))
-	    ((and (constantp (car l)) (car l))
-	     (setq form (if (endp (cddr l)) (cadr l) `(progn ,@(cdr l)))))
-	    ((setq form (if (endp (cddr l))
-			    `(if ,(car l) ,(cadr l) ,form)
-			  `(if ,(car l) (progn ,@(cdr l)) ,form))))))))
-
-
-(defmacro when (pred &rest body)
-  `(if ,pred (progn ,@body)))
+; program feature
 
-(defmacro unless (pred &rest body)
-  `(if (not ,pred) (progn ,@body)))
+(defun prog?* (let?* vl body)
+  (multiple-value-bind
+      (doc dec ctp body)
+      (parse-body-header body)
+    (declare (ignore doc))
+    `(block nil (,let?* ,vl ,@dec (tagbody ,@(append ctp body))))))
 
-; program feature
+(defmacro prog (vl &rest body)
+  (prog?* 'let vl body))
 
-(defmacro prog (vl &rest body &aux (decl nil))
-  (do ()
-      ((or (endp body)
-           (not (consp (car body)))
-           (not (eq (caar body) 'declare)))
-       `(block nil (let ,vl ,@decl (tagbody ,@body)))
-       )
-      (push (car body) decl)
-      (pop body))
-  )
-
-(defmacro prog* (vl &rest body &aux (decl nil))
-  (do ()
-      ((or (endp body)
-           (not (consp (car body)))
-           (not (eq (caar body) 'declare)))
-       `(block nil (let* ,vl ,@decl (tagbody ,@body)))
-       )
-      (push (car body) decl)
-      (pop body))
-  )
+(defmacro prog* (vl &rest body)
+  (prog?* 'let* vl body))
 
 ; sequencing
 
-(defmacro prog1 (first &rest body &aux (sym (gensym)))
+(defmacro prog1 (first &rest body &aux (sym (sgen "PROG1")))
   `(let ((,sym ,first)) ,@body ,sym))
 
-(defmacro prog2 (first second &rest body &aux (sym (gensym)))
+(defmacro prog2 (first second &rest body &aux (sym (sgen "PROG2")))
   `(progn ,first (let ((,sym ,second)) ,@body ,sym)))
 
 ; multiple values
@@ -203,115 +171,79 @@
   `(multiple-value-call 'list ,form))
 
 (defmacro multiple-value-setq (vars form)
-  (do ((vl vars (cdr vl))
-       (sym (gensym))
-       (forms nil)
-       (n 0 (1+ n)))
-      ((endp vl) `(let ((,sym (multiple-value-list ,form))) ,@forms))
-      (declare (fixnum n) (object vl))
-      (push `(setq ,(car vl) (nth ,n ,sym)) forms))
-  )
-
-(defmacro multiple-value-bind (vars form &rest body)
-  (do ((vl vars (cdr vl))
-       (sym (gensym))
-       (bind nil)
-       (n 0 (1+ n)))
-      ((endp vl) `(let* ((,sym (multiple-value-list ,form)) ,@(nreverse bind))
-                        ,@body))
-      (declare (fixnum n) (object vl))
-      (push `(,(car vl) (nth ,n ,sym)) bind))
-  )
-
-(defmacro do (control (test . result) &rest body
-              &aux (decl nil) (label (gensym)) (vl nil) (step nil))
-  (do ()
-      ((or (endp body)
-           (not (consp (car body)))
-           (not (eq (caar body) 'declare))))
-      (push (car body) decl)
-      (pop body))
-  (dolist (c control)
-          (declare (object c))
-    (if(symbolp  c) (setq c (list c)))
-        (push (list (car c) (cadr c)) vl)
-    (unless (endp (cddr c))
-            (push (car c) step)
-            (push (caddr c) step)))
-  `(block nil
-          (let ,(nreverse vl)
-               ,@decl
-               (tagbody
-                ,label (if ,test (return (progn ,@result)))
-                       (tagbody ,@body)
-                       (psetq ,@(nreverse step))
-                       (go ,label)))))
-
-(defmacro do* (control (test . result) &rest body
-               &aux (decl nil) (label (gensym)) (vl nil) (step nil))
-  (do ()
-      ((or (endp body)
-           (not (consp (car body)))
-           (not (eq (caar body) 'declare))))
-      (push (car body) decl)
-      (pop body))
-  (dolist (c control)
-          (declare (object c))
-    (if(symbolp  c) (setq c (list c)))
-        (push (list (car c) (cadr c)) vl)
-    (unless (endp (cddr c))
-            (push (car c) step)
-            (push (caddr c) step)))
-  `(block nil
-          (let* ,(nreverse vl)
-                ,@decl
-                (tagbody
-                 ,label (if ,test (return (progn ,@result)))
-                        (tagbody ,@body)
-                        (setq ,@(nreverse step))
-                        (go ,label))))
-  )
-
-(defmacro case (keyform &rest clauses &aux (key (load-time-value (gensym "CASE"))) (c (reverse clauses)))
-  (declare (optimize (safety 2)))
-  (labels ((sw (x) `(eql ,key ',x))(dfp (x) (or (eq x t) (eq x 'otherwise)))
-	   (v (x) (if (when (listp x) (not (cdr x))) (car x) x))
-	   (m (x c &aux (v (v x))) (if (eq v x) (cons c v) v)))
-	  `(let ((,key ,keyform))
-	     (declare (ignorable ,key))
-	     ,(let ((df (when (dfp (caar c)) (m (cdr (pop c)) 'progn))))
-		(reduce (lambda (y c &aux (a (pop c))(v (v a)))
-			  (when (dfp a) (error "default case must be last"))
-			  `(if ,(if (when (eq a v) (listp v)) (m (mapcar #'sw v) 'or) (sw v)) ,(m c 'progn) ,y))
-			c :initial-value df)))))
-
-(defmacro ecase (keyform &rest clauses &aux (key (sgen "ECASE")))
-  (declare (optimize (safety 2)))
-  `(let ((,key ,keyform))
-     (declare (ignorable ,key))
-     (case ,key
+  (declare (optimize (safety 1)))
+  (let ((syms (mapcar (lambda (x) (declare (ignore x)) (gensym)) (or vars (list nil)))))
+    `(multiple-value-bind ,syms ,form ,@(?list (?cons 'setq (mapcan 'list vars syms))) ,(car syms))))
+
+(defmacro multiple-value-bind (vars form &rest body &aux (sym (sgen "MULTIPLE-VALUE-BIND")))
+  (declare (optimize (safety 1)))
+  `(let* ((,sym (multiple-value-list ,form))
+	  ,@(mapcon (lambda (x) `((,(car x) (car ,sym)) ,@(when (cdr x) `((,sym (cdr ,sym)))))) vars))
+     (declare (ignorable ,sym))
+     ,@body))
+
+(defun do?* (?* control test result body &aux (label (sgen "DO")))
+  (multiple-value-bind
+      (doc dec ctp body)
+      (parse-body-header body)
+    (declare (ignore doc))
+    (labels ((?let (vl dec body) (if (or vl dec) `(,(if ?* 'let* 'let) ,vl ,@dec ,body) body))
+	     (?tagbody (l x y &aux (x (macroexpand x))) (if x `(tagbody ,l ,x ,@(?list (when (eq (car x) 'if) y))) y)))
+      `(block nil
+	 ,(?let
+	   (mapcar (lambda (x) (if (listp x) (ldiff x (cddr x)) x)) control)
+	   dec
+	   (?tagbody
+	    label
+	    `(unless ,test
+	       ,@(?list (?cons 'tagbody (append ctp body)))
+	       ,@(?list (?cons (if ?* 'setq 'psetq) (mapcan (lambda (x) (when (and (listp x) (cddr x)) (list (car x) (caddr x)))) control)))
+	       (go ,label))
+	    `(return ,(?cons 'progn result))))))))
+
+(defmacro do (control (test . result) &rest body)
+  (do?* nil control test result body))
+
+(defmacro do* (control (test . result) &rest body)
+  (do?* t control test result body))
+
+(defmacro case (keyform &rest clauses &aux r rp np (key (?key keyform)))
+  (declare (optimize (safety 1)))
+  (labels ((sw (x) `(eql ,key ,(if (constantp x) x `',x))))
+    (do ((y clauses))((endp y) (?let key keyform r))
+      (let* ((x (pop y))(z (pop x)))
+	(if (member z '(t otherwise))
+	    (if y (error "default case must be last") (collect (?cons 'progn x) r rp np))
+	  (when z
+	    (if (constantp key)
+		(let ((key (eval key))) (when (if (listp z) (member key z) (eql key z)) (collect (?cons 'progn x) r rp np) (setq y nil)))
+	      (collect `(if ,(if (listp z) (?cons 'or (mapcar #'sw z)) (sw z))
+			    ,@(setq np (list (?cons 'progn x)))) r rp np))))))))
+
+(defmacro ecase (keyform &rest clauses &aux (key (?key keyform)))
+  (declare (optimize (safety 1)))
+  (?let key keyform
+	`(case ,key
 	   ,@(mapcar (lambda (x) (if (member (car x) '(t otherwise)) (cons (list (car x)) (cdr x)) x)) clauses)
 	   (otherwise
 	    (error 'type-error :datum ,key
 		   :expected-type '(member ,@(apply 'append (mapcar (lambda (x &aux (x (car x))) (if (listp x) x (list x))) clauses))))))))
 
+(defmacro ccase (keyform &rest clauses &aux (key (?key keyform)))
+  (declare (optimize (safety 1)))
+  (?let key keyform
+	`(do nil (nil)
+	   (case ,key
+	     ,@(mapcar (lambda (x &aux (k (pop x)))
+			 `(,(if (member k '(t otherwise)) (list k) k) (return ,(?cons 'progn x)))) clauses)
+	     (otherwise
+	      (check-type ,key (member ,@(apply 'append (mapcar (lambda (x &aux (x (car x))) (if (listp x) x (list x))) clauses)))))))))
 
-(defmacro ccase (keyform &rest clauses &aux (key (sgen "CCASE")))
-  (declare (optimize (safety 2)))
-  `(let ((,key ,keyform))
-     (declare (ignorable ,key))
-     (do nil (nil)
-      (case ,key
-	    ,@(mapcar (lambda (x &aux (k (pop x)))
-			`(,(if (member k '(t otherwise)) (list k) k) (return ,(if (cdr x) (cons 'progn x) (car x))))) clauses)
-	    (otherwise 
-	     (check-type ,key (member ,@(apply 'append (mapcar (lambda (x &aux (x (car x))) (if (listp x) x (list x))) clauses)))))))))
-
-(defmacro return (&optional (val nil)) `(return-from nil ,val))
-
-(defmacro dolist ((var form &optional (val nil)) &rest body
-                                                 &aux (temp (gensym)))
-  `(do* ((,temp ,form (cdr ,temp)) (,var (car ,temp) (car ,temp)))
+
+(defmacro return (&optional val) `(return-from nil ,val))
+
+(defmacro dolist ((var form &optional (val nil)) &rest body &aux (temp (sgen "DOLIST")))
+  `(do* ((,temp ,form (cdr ,temp))(,var (car ,temp) (car ,temp)))
 	((endp ,temp) ,val)
 	,@body))
 
@@ -327,59 +259,19 @@
 ;; appears to treat this as positive or negative depending on the sign
 ;; of the other argument in the comparison, apparently to symmetrize
 ;; the long integer range.  20040403 CM.
-(defmacro dotimes ((var form &optional (val nil)) &rest body)
-  (cond
-   ((symbolp form)
-    (let ((temp (gensym)))
-      `(cond ((< ,form 0)
-	      (let ((,var 0))
-		(declare (fixnum ,var) (ignorable ,var))
-		,val))
-	     ((<= ,form most-positive-fixnum)
-                 (let ((,temp ,form))
-                   (declare (fixnum ,temp))
-                   (do* ((,var 0 (1+ ,var))) ((>= ,var ,temp) ,val)
-                     (declare (fixnum ,var))
-                     ,@body)))
-                (t 
-		 (let ((,temp ,form))
-		   (do* ((,var 0 (1+ ,var))) ((>= ,var ,temp) ,val)
-		     ,@body))))))
-	((constantp form)
-	 (cond ((< form 0)
-		`(let ((,var 0))
-		   (declare (fixnum ,var) (ignorable ,var))
-		   ,val))
-	       ((<= form most-positive-fixnum)
-		`(do* ((,var 0 (1+ ,var))) ((>= ,var ,form) ,val)
-		   (declare (fixnum ,var))
-		   ,@body))
-	       (t
-		`(do* ((,var 0 (1+ ,var))) ((>= ,var ,form) ,val)
-		   ,@body))))
-	(t
-	 (let ((temp (gensym)))
-	 `(let ((,temp ,form))
-	    (cond ((< ,temp 0)
-		   (let ((,var 0))
-		     (declare (fixnum ,var) (ignorable ,var))
-		     ,val))
-		  ((<= ,temp most-positive-fixnum)
-		   (let ((,temp ,temp))
-		     (declare (fixnum ,temp))
-		     (do* ((,var 0 (1+ ,var))) ((>= ,var ,temp) ,val)
-		       (declare (fixnum ,var))
-		       ,@body)))
-		  (t 
-		   (do* ((,var 0 (1+ ,var))) ((>= ,var ,temp) ,val)
-		     ,@body))))))))
-
+(defmacro dotimes ((var form &optional val) &rest body &aux (s (sgen "DOTIMES"))(m (sgen "DOTIMES")))
+  `(let* ((,s (block nil ,form))(,m (min ,s most-positive-fixnum)))
+     (declare (fixnum ,m))
+     (do ((,var 0 (1+ ,var)))
+	 ((>= ,var ,m) (if (eql ,s ,m) ,val (do ((,var ,m (1+ ,var)))((>= ,var ,s) ,val) ,@body)))
+	   (declare (fixnum ,var))
+	   ,@body)))
 
 (defmacro declaim (&rest l)
- `(eval-when (compile eval load)
-	     ,@(mapcar #'(lambda (x) `(proclaim ',x)) l)))
+  `(eval-when (compile eval load)
+     ,@(mapcar (lambda (x) `(proclaim ',x)) l)))
 
-(defmacro lambda ( &rest l) `(function (lambda ,@l)))
+(defmacro lambda (&rest l) `(function (lambda ,@l)))
 
 (defun compiler-macro-function (name)
   (get name 'compiler-macro-prop))
--- gcl-2.6.12.orig/lsp/gcl_iolib.lsp
+++ gcl-2.6.12/lsp/gcl_iolib.lsp
@@ -380,7 +380,7 @@
 
 (defun get-byte-stream-nchars (s)
   (let* ((tp (stream-element-type s)))
-    (ceiling (if (consp tp) (cadr tp) char-length) char-length)))
+    (values (ceiling (if (consp tp) (cadr tp) char-length) char-length))))
 
 ;; (defun parse-integer (s &key start end (radix 10) junk-allowed)
 ;;   (declare (optimize (safety 1)))
@@ -488,21 +488,19 @@
 	(stream (load-stream p print)))
     (when verbose (format t ";; Finished loading ~s~%" p))))
 
-(defun ensure-directories-exist (ps &key verbose &aux created)
+(defun ensure-directories-exist (ps &key verbose)
   (declare (optimize (safety 1)))
   (check-type ps pathname-designator)
   (when (wild-pathname-p ps)
     (error 'file-error :pathname ps :format-control "Pathname is wild"))
-  (labels ((d (x y &aux (z (ldiff x y)) (n (namestring (make-pathname :directory z))))
-	      (when (when z (stringp (car (last z))))
-		(unless (eq :directory (stat n))
-		  (mkdir n)
-		  (setq created t)
-		  (when verbose (format *standard-output* "Creating directory ~s~%" n))))
-	      (when y (d x (cdr y)))))
-    (let ((pd (pathname-directory ps)))
-      (d pd (cdr pd)))
-    (values ps created)))
+  (let ((pd (pathname-directory ps)) ls)
+    (dotimes (i (length pd))
+      (let ((s (namestring (make-pathname :directory (if (zerop i) pd (ldiff pd (last pd i)))))))
+	(if (eq (stat1 s) :directory) (return) (push s ls))))
+    (dolist (s ls)
+      (mkdir s)
+      (when verbose (format *standard-output* "Creating directory ~s~%" s)))
+    (values ps (if ls t))))
 
 (defun file-length (x)
   (declare (optimize (safety 1)))
@@ -511,7 +509,7 @@
       (let ((s (broadcast-stream-streams x))) (if s (file-length (car (last s))) 0))
     (multiple-value-bind (tp sz) (stat x)
       (declare (ignore tp))
-      (/ sz (get-byte-stream-nchars x)))))
+      (values (truncate sz (get-byte-stream-nchars x))))))
 
 (defun file-position (x &optional (pos :start pos-p))
   (declare (optimize (safety 1)))
--- gcl-2.6.12.orig/lsp/gcl_loop.lsp
+++ gcl-2.6.12/lsp/gcl_loop.lsp
@@ -793,6 +793,8 @@ a LET-like macro, and a SETQ-like macro,
   (unless (= (length before-loop) (length after-loop))
     (error "LOOP-BODY called with non-synched before- and after-loop lists."))
   ;;All our work is done from these copies, working backwards from the end:
+  (when (equal before-loop after-loop)
+    (setq main-body (append before-loop main-body) before-loop nil after-loop nil));accelerator
   (setq rbefore (reverse before-loop) rafter (reverse after-loop))
   (labels ((psimp (l)
 	     (let ((ans nil))
--- gcl-2.6.12.orig/lsp/gcl_parse_namestring.lsp
+++ gcl-2.6.12/lsp/gcl_parse_namestring.lsp
@@ -2,15 +2,6 @@
 
 (deftype seqind nil `fixnum)
 
-(defun match-beginning (i &aux (v *match-data*))
-  (declare ((vector fixnum) v)(seqind i))
-  (the (or (integer -1 -1 ) seqind) (aref v i)))
-(defun match-end (i &aux (v *match-data*))
-  (declare ((vector fixnum) v)(seqind i))
-  (the (or (integer -1 -1 ) seqind) (aref v (+ i (ash (length v) -1)))))
-
-(declaim (inline match-beginning match-end))
-
 (defun dir-conj (x) (if (eq x :relative) :absolute :relative))
 
 (defvar *up-key* :up)
--- gcl-2.6.12.orig/lsp/gcl_predlib.lsp
+++ gcl-2.6.12/lsp/gcl_predlib.lsp
@@ -348,8 +348,7 @@
 ;; FIXME this needs to be more robust
 (defun known-type-p (type)
   (when (consp type) (setq type (car type)))
-  (if (or (equal (string type) "ERROR")
-	  (member type
+  (if (or (member type
                   '(t nil boolean null symbol keyword atom cons list sequence
 		      signed-char unsigned-char signed-short unsigned-short
 		      number integer bignum rational ratio float method-combination
@@ -370,8 +369,9 @@
 		      storage-condition stream-error string-stream structure-class
 		      style-warning synonym-stream two-way-stream structure-object
 		      type-error unbound-slot unbound-variable undefined-function
-		      warning ))
-          (get type 's-data))
+		      warning) :test 'eq)
+          (get type 's-data)
+	  (equal (string type) "ERROR"))
       t
       nil))
 
--- gcl-2.6.12.orig/lsp/gcl_rename_file.lsp
+++ gcl-2.6.12/lsp/gcl_rename_file.lsp
@@ -26,7 +26,7 @@
 (defun delete-file (f &aux (pf (truename f))(nf (namestring pf)))
   (declare (optimize (safety 1)))
   (check-type f pathname-designator)
-  (unless (if (eq :directory (stat nf)) (rmdir nf) (unlink nf))
+  (unless (if (eq :directory (stat1 nf)) (rmdir nf) (unlink nf))
     (error 'file-error :pathname (pathname nf) :format-control "Cannot delete pathname."))
   t)
 
--- gcl-2.6.12.orig/lsp/gcl_seqlib.lsp
+++ gcl-2.6.12/lsp/gcl_seqlib.lsp
@@ -25,7 +25,7 @@
 (in-package :si)
 
 
-(proclaim '(optimize (safety 2) (space 3)))
+;(proclaim '(optimize (safety 2) (space 3)))
 
 
 (proclaim '(function seqtype (t) t))
@@ -274,40 +274,87 @@
         (list 'quote f)))
 
 (defmacro eval-body () *body*)
+(defmacro mcf (x) `(when ,x (coerce ,x 'function)))
+(deftype function-designator nil `(or (and symbol (not boolean)) function))
+(defmacro rcollect (r rp form)
+  `(let ((tmp ,form))
+     (setq ,rp (last (if ,rp (rplacd ,rp tmp) (setq ,r tmp))))))
+
+ (defmacro dcollect (r rp form)
+   `(let ((tmp ,form))
+      (declare (dynamic-extent tmp))
+      (setq ,rp (cond (,rp (rplacd ,rp tmp) tmp) ((setq ,r tmp))))))
+
 )
 
+(defun remove (item sequence &key key test test-not from-end count (start 0) end 
+		 &aux (kf (mcf key))(tf (mcf test))(tnf (mcf test-not)) r rp q qp xz (from-end (when count from-end))
+		 (l (listp sequence))(ln (if l array-dimension-limit (length sequence)))
+		 (e (if end (min ln (max 0 end)) ln))
+		 (c (if count (min ln (max 0 count)) ln)))
+
+  (declare (optimize (safety 1))(dynamic-extent q)(fixnum c e))
+
+  (check-type sequence sequence)
+  (check-type start seqind)
+  (check-type end (or null seqind))
+  (check-type count (or null integer))
+  (check-type key (or null function-designator))
+  (check-type test (or null function-designator))
+  (check-type test-not (or null function-designator))
+
+  (cond ((unless from-end l)
+	 (do ((i start (1+ i))(j 0)(s (if (zerop start) sequence (nthcdr start sequence)) (cdr s)))
+	     ((or (endp s) (>= i e) (>= j c)) (rcollect r rp sequence) r)
+	   (declare (fixnum i j))
+	   (let* ((x (car s))(kx (if kf (funcall kf x) x)))
+	     (when (cond (tf (funcall tf item kx))(tnf (not (funcall tnf item kx)))((eql item kx)))
+	       (do nil ((eq sequence s) (setq sequence (cdr sequence))) (rcollect r rp (cons (pop sequence) nil)))
+	       (incf j)))))
+	(t
+	 (do* ((j 0 (1+ j)))
+	       ((not (when (< j c)
+		       (setq xz (position item sequence
+					  :start (if (unless from-end xz) (1+ xz) start)
+					  :end (if (when from-end xz) xz end)
+					  :key kf :test tf :test-not tnf :from-end from-end)))))
+	   (declare (fixnum j))
+	   (if from-end (push xz q) (dcollect q qp (cons xz nil))))
+;	 (print q)
+	 (cond ((not q) sequence)
+	       (l (do* ((lq -1 (car q))(q q (cdr q))(v sequence (cdr v)))((not q) (rcollect r rp v) r)
+		    (declare (fixnum lq))
+		    (dotimes (i (the fixnum (- (car q) lq 1))) (declare (fixnum i))(rcollect r rp (cons (pop v) nil)))))
+	       ((let ((r (make-array (- (length sequence) (length q)) :element-type (array-element-type sequence))))
+		  (do* ((j 0 (+ j (- (car q) lq 1)))(lq -1 (car q))(q q (cdr q)))
+		      ((when (replace r sequence :start1 j :start2 (1+ lq) :end2 (car q)) (not q)) r)))))))
+)
 
-(defseq remove () t nil
-  (if (not from-end)
-      `(if (listp sequence)
-           (let ((l sequence) (l1 nil))
-             (do ((i 0 (f+ 1  i)))
-                 ((>= i start))
-               (declare (fixnum i))
-               (push (car l) l1)
-               (pop l))
-             (do ((i start (f+ 1  i)) (j 0))
-                 ((or (>= i end) (>= j count) (endp l))
-                  (nreconc l1 l))
-               (declare (fixnum i j))
-               (cond ((call-test test test-not item (funcall key (car l)))
-                      (setf  j (f+ 1  j))
-                      (pop l))
-                     (t
-                      (push (car l) l1)
-                      (pop l)))))
-           (delete item sequence
-                   :from-end from-end
-                   :test test :test-not test-not
-                   :start start :end end
-                   :count count
-                   :key key))
-      `(delete item sequence
-               :from-end from-end
-               :test test :test-not test-not
-               :start start :end end
-               :count count
-               :key key)))
+(defun remove-if (p s &key key from-end count (start 0) end &aux (kf (mcf key)))
+
+  (declare (optimize (safety 1)))
+
+  (check-type p function-designator)
+  (check-type s sequence)
+  (check-type start seqind)
+  (check-type end (or null seqind))
+  (check-type count (or null integer))
+  (check-type key (or null function-designator))
+
+  (remove p s :key kf :test #'funcall :start start :end end :count count :from-end from-end))
+
+(defun remove-if-not (p s &key key from-end count (start 0) end &aux (kf (mcf key)))
+
+  (declare (optimize (safety 1)))
+
+  (check-type p function-designator)
+  (check-type s sequence)
+  (check-type start seqind)
+  (check-type end (or null seqind))
+  (check-type count (or null integer))
+  (check-type key (or null function-designator))
+
+  (remove p s :key kf :test-not #'funcall :start start :end end :count count :from-end from-end))
 
 
 (defseq delete () t t
--- gcl-2.6.12.orig/lsp/gcl_setf.lsp
+++ gcl-2.6.12/lsp/gcl_setf.lsp
@@ -197,6 +197,7 @@
 (defsetf symbol-plist si:set-symbol-plist)
 (defsetf gethash (k h &optional d) (v) `(si:hash-set ,k ,h ,v))
 (defsetf row-major-aref si:aset1)
+(defsetf readtable-case si::set-readtable-case)
 (defsetf documentation (s d) (v)
   `(case ,d
      (variable (si:putprop ,s ,v 'variable-documentation))
--- gcl-2.6.12.orig/lsp/gcl_top.lsp
+++ gcl-2.6.12/lsp/gcl_top.lsp
@@ -582,7 +582,7 @@ First directory is checked for first nam
 (defvar *tmp-dir*)
 
 (defun ensure-dir-string (str)
-  (if (eq (stat str) :directory)
+  (if (eq (stat1 str) :directory)
       (coerce-slash-terminated str)
     str))
 
@@ -590,7 +590,7 @@ First directory is checked for first nam
   (dolist (x `(,@(mapcar 'si::getenv '("TMPDIR" "TMP" "TEMP")) "/tmp" ""))
     (when x
       (let ((x (coerce-slash-terminated x)))
-	(when (eq (stat x) :directory)
+	(when (eq (stat1 x) :directory)
 	  (return-from get-temp-dir x))))))
 
 
--- gcl-2.6.12.orig/lsp/gcl_translate_pathname.lsp
+++ gcl-2.6.12/lsp/gcl_translate_pathname.lsp
@@ -51,7 +51,7 @@
 
 (defun list-toggle-case (x f)
   (typecase x
-    (string (funcall f x))
+    (string (values (funcall f x)))
     (cons (mapcar (lambda (x) (list-toggle-case x f)) x))
     (otherwise x)))
 
--- gcl-2.6.12.orig/lsp/gcl_truename.lsp
+++ gcl-2.6.12/lsp/gcl_truename.lsp
@@ -6,7 +6,7 @@
 	   (set-fr (fr e &aux (fr (or fr (frame 0 b)))) (setf (fill-pointer fr) e) fr))
     (let* ((i (string-match +dirsep+ str b))
 	   (fr (set-fr fr (if (eql i -1) n i)))
-	   (l (when (eq (stat fr) :link) (readlinkat 0 fr))))
+	   (l (when (eq (stat1 fr) :link) (readlinkat 0 fr))))
       (cond (l (let ((b (if (eql #\/ (aref l 0)) 0 b)))
 		 (link-expand (string-concatenate (set-fr fr b) l (frame (if (eql i -1) n i) n)) b)))
 	    ((eql i -1) str)
@@ -25,7 +25,7 @@
     (error 'file-error :pathname pd :format-control "Pathname is wild"))
   (let* ((ns (ensure-dir-string (link-expand ns)))
 	 (ppd (if (eq (namestring pd) ns) pd (pathname ns))))
-    (unless (or (zerop (length ns)) (stat ns))
+    (unless (or (zerop (length ns)) (stat1 ns))
       (error 'file-error :pathname ns :format-control "Pathname does not exist"))
     (let* ((d (pathname-directory ppd))
 	   (d1 (subst :back :up d))
@@ -38,5 +38,5 @@
   (check-type pd pathname-designator)
   (when (wild-pathname-p pn)
     (error 'file-error :pathname pn :format-control "Pathname is wild"))
-  (when (eq (stat (link-expand (namestring pn))) :file)
+  (when (eq (stat1 (link-expand (namestring pn))) :file)
     (truename pn)))
--- gcl-2.6.12.orig/lsp/sys-proclaim.lisp
+++ gcl-2.6.12/lsp/sys-proclaim.lisp
@@ -3,239 +3,282 @@
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
-             ((COMMON-LISP::VECTOR COMMON-LISP::CHARACTER
-                  COMMON-LISP::*))
-             COMMON-LISP::T)
-         SYSTEM::RESET-SYS-PATHS)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
-             (COMMON-LISP::VECTOR COMMON-LISP::T))
-         SYSTEM::CONTEXT-VEC)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
              ((COMMON-LISP::INTEGER -9223372036854775808
-                  9223372036854775807))
+                  9223372036854775807)
+              COMMON-LISP::T)
              COMMON-LISP::T)
-         SYSTEM::PUSH-CONTEXT SYSTEM::GET-CONTEXT)) 
+         SYSTEM::SMALLNTHCDR)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION COMMON-LISP::NIL COMMON-LISP::T)
-         SLOOP::PARSE-LOOP-DO ANSI-LOOP::LOOP-WHEN-IT-VARIABLE
-         SYSTEM::GET-INDEX-NODE SLOOP::LOOP-PEEK
-         ANSI-LOOP::LOOP-POP-SOURCE SYSTEM::STEP-READ-LINE
-         SYSTEM::SET-UP-TOP-LEVEL SLOOP::LOOP-POP SYSTEM::SET-ENV
-         SYSTEM::DBL COMMON-LISP::TYPE-ERROR SYSTEM::INSPECT-INDENT
-         SLOOP::PARSE-LOOP-COLLECT SYSTEM::CLEANUP
-         SYSTEM::DEFAULT-SYSTEM-BANNER
-         SYSTEM::CURRENT-DIRECTORY-PATHNAME ANSI-LOOP::LOOP-DO-WITH
-         SYSTEM::INIT-BREAK-POINTS SYSTEM::TEST-ERROR
-         SYSTEM::GET-SIG-FN-NAME SLOOP::PARSE-ONE-WHEN-CLAUSE
-         ANSI-LOOP::LOOP-DO-DO SYSTEM::READ-EVALUATED-FORM
-         SYSTEM::INSPECT-INDENT-1 ANSI-LOOP::LOOP-DO-NAMED
-         SLOOP::PARSE-LOOP-FOR SYSTEM::ALL-TRACE-DECLARATIONS
-         ANSI-LOOP::LOOP-GET-FORM ANSI-LOOP::LOOP-BIND-BLOCK
-         SLOOP::PARSE-LOOP-WHEN SYSTEM::TOP-LEVEL
-         SYSTEM::DM-TOO-FEW-ARGUMENTS SYSTEM::KCL-TOP-RESTARTS
-         SYSTEM::DEFAULT-INFO-HOTLIST SYSTEM::SHOW-RESTARTS
-         SYSTEM::DM-TOO-MANY-ARGUMENTS SYSTEM::SETUP-LINEINFO
-         SYSTEM::GET-TEMP-DIR ANSI-LOOP::LOOP-ITERATION-DRIVER
-         SLOOP::PARSE-LOOP1 SLOOP::LOOP-UN-POP
-         ANSI-LOOP::LOOP-DO-FINALLY SYSTEM::INSPECT-READ-LINE
-         ANSI-LOOP::LOOP-CONTEXT SYSTEM::SET-CURRENT
-         ANSI-LOOP::LOOP-DO-REPEAT SYSTEM::ILLEGAL-BOA
-         COMMON-LISP::LISP-IMPLEMENTATION-VERSION
-         ANSI-LOOP::LOOP-DO-RETURN ANSI-LOOP::LOOP-DO-INITIALLY
-         ANSI-LOOP::LOOP-GET-PROGN)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::T)
+         SYSTEM::NORMALIZE-TYPE SYSTEM::PNL1
+         ANSI-LOOP::LOOP-UNIVERSE-PATH-KEYWORDS SYSTEM::DM-BAD-KEY
+         SYSTEM::S-DATA-INCLUDES
+         ANSI-LOOP::LOOP-UNIVERSE-ITERATION-KEYWORDS
+         COMMON-LISP::HOST-NAMESTRING
+         COMMON-LISP::TWO-WAY-STREAM-INPUT-STREAM COMMON-LISP::LOGNOT
+         SYSTEM::BREAK-FORWARD-SEARCH-STACK
+         SLOOP::SUBSTITUTE-SLOOP-BODY
+         COMMON-LISP::CONCATENATED-STREAM-STREAMS
+         ANSI-LOOP::LOOP-MINIMAX-OPERATIONS SYSTEM::ADD-TO-HOTLIST
+         SYSTEM::RESTART-REPORT-FUNCTION COMMON-LISP::THIRD
+         SYSTEM::DWIM SYSTEM::GET-INSTREAM SYSTEM::TOGGLE-CASE
+         SYSTEM::INSTREAM-P COMMON-LISP::DELETE-FILE
+         SYSTEM::BEST-ARRAY-ELEMENT-TYPE COMMON-LISP::ISQRT
+         SYSTEM::INSERT-BREAK-POINT SYSTEM::WILD-DIR-ELEMENT-P
+         COMMON-LISP::ABS SYSTEM::WHICH COMMON-LISP::ACOS
+         SYSTEM::COERCE-SLASH-TERMINATED
+         COMMON-LISP::LOAD-LOGICAL-PATHNAME-TRANSLATIONS
+         ANSI-LOOP::LOOP-CODE-DUPLICATION-THRESHOLD
+         COMMON-LISP::ECHO-STREAM-OUTPUT-STREAM SYSTEM::DIR-P
+         SYSTEM::SETUP-INFO SYSTEM::S-DATA-TYPE
+         ANSI-LOOP::LOOP-PATH-PREPOSITION-GROUPS
+         SYSTEM::PRINT-SYMBOL-APROPOS SYSTEM::S-DATA-FROZEN
+         SYSTEM::REAL-ASINH ANSI-LOOP::LOOP-UNIVERSE-TYPE-SYMBOLS
+         SLOOP::PARSE-NO-BODY SYSTEM::INSPECT-STRING SYSTEM::PRINT-FRS
+         SYSTEM::LEAP-YEAR-P SYSTEM::RESTRICT-STREAM-ELEMENT-TYPE
+         SYSTEM::RESTART-INTERACTIVE-FUNCTION
+         SYSTEM::S-DATA-SLOT-DESCRIPTIONS SYSTEM::S-DATA-STATICP
+         SYSTEM::INSPECT-STRUCTURE COMMON-LISP::ASINH
+         ANSI-LOOP::LOOP-PATH-USER-DATA SYSTEM::RE-QUOTE-STRING
+         SYSTEM::MLP SYSTEM::GET-STRING-INPUT-STREAM-INDEX
+         SYSTEM::INFO-GET-FILE COMMON-LISP::EIGHTH
+         SYSTEM::SHOW-BREAK-POINT SYSTEM::SIMPLE-ARRAY-P
+         COMMON-LISP::RESTART-NAME SLOOP::POINTER-FOR-COLLECT
+         COMMON-LISP::PHASE SYSTEM::LNP
+         SYSTEM::REWRITE-RESTART-CASE-CLAUSE
+         SLOOP::LOOP-COLLECT-KEYWORD-P SYSTEM::S-DATA-HAS-HOLES
+         SYSTEM::EVAL-FEATURE ANSI-LOOP::DESTRUCTURING-SIZE
+         COMMON-LISP::BROADCAST-STREAM-STREAMS
+         ANSI-LOOP::LOOP-PATH-FUNCTION COMMON-LISP::BYTE-POSITION
+         ANSI-LOOP::LOOP-MINIMAX-TYPE COMMON-LISP::TANH
+         SYSTEM::BKPT-FILE SYSTEM::FRS-KIND
+         SYSTEM::S-DATA-PRINT-FUNCTION SYSTEM::UNIQUE-ID
+         SYSTEM::IHS-NOT-INTERPRETED-ENV SYSTEM::INSPECT-PACKAGE
+         ANSI-LOOP::LOOP-MINIMAX-INFINITY-DATA SYSTEM::BKPT-FILE-LINE
+         ANSI-LOOP::LOOP-EMIT-BODY SYSTEM::PATCH-SHARP
+         ANSI-LOOP::LOOP-COLLECTOR-P SYSTEM::DIR-CONJ
+         SYSTEM::CHECK-TRACE-SPEC ANSI-LOOP::LOOP-COLLECTOR-HISTORY
+         ANSI-LOOP::LOOP-UNIVERSE-KEYWORDS SYSTEM::FIX-LOAD-PATH
+         ANSI-LOOP::LOOP-COLLECTOR-NAME SYSTEM::PATH-STREAM-NAME
+         SLOOP::LOOP-LET-BINDINGS ANSI-LOOP::LOOP-TYPED-INIT
+         FPE::ST-LOOKUP SYSTEM::IHS-VISIBLE SYSTEM::INFO-GET-TAGS
+         SYSTEM::EXPAND-HOME-DIR SYSTEM::DM-KEY-NOT-ALLOWED
+         ANSI-LOOP::LOOP-UNIVERSE-P
+         SYSTEM::CANONICALIZE-PATHNAME-DIRECTORY
+         COMMON-LISP::CONSTANTLY SYSTEM::WILD-NAMESTRING-P
+         SYSTEM::INSPECT-NUMBER SYSTEM::LOGICAL-PATHNAME-DESIGNATOR-P
+         COMMON-LISP::FOURTH SYSTEM::NODES-FROM-INDEX
+         SYSTEM::LOGICAL-PATHNAME-HOST-P SYSTEM::S-DATA-NAMED
+         COMMON-LISP::INVOKE-DEBUGGER SYSTEM::INSPECT-VECTOR
+         SYSTEM::VERSION-PARSE SYSTEM::WILD-PATH-ELEMENT-P
+         SLOOP::RETURN-SLOOP-MACRO SYSTEM::REGEXP-CONV
+         SYSTEM::NUMBER-OF-DAYS-FROM-1900
+         COMMON-LISP::ECHO-STREAM-INPUT-STREAM SYSTEM::CHDIR
+         SYSTEM::DBL-RPL-LOOP COMMON-LISP::ASIN COMMON-LISP::RATIONAL
+         ANSI-LOOP::LOOP-PATH-INCLUSIVE-PERMITTED
+         COMMON-LISP::NAMESTRING SYSTEM::TRACE-ONE-PREPROCESS
+         SYSTEM::TERMINAL-INTERRUPT SYSTEM::SEQTYPE SYSTEM::S-DATA-RAW
+         SYSTEM::GET-NEXT-VISIBLE-FUN FPE::XMM-LOOKUP
+         SYSTEM::MAKE-KCL-TOP-RESTART ANSI-LOOP::LOOP-MINIMAX-P
+         ANSI-LOOP::LOOP-MAXMIN-COLLECTION
+         COMMON-LISP::COMPILER-MACRO-FUNCTION SYSTEM::BKPT-FUNCTION
+         SYSTEM::DIRECTORY-LIST-CHECK SYSTEM::S-DATA-SLOT-POSITION
+         SYSTEM::SHORT-NAME SYSTEM::DBL-EVAL
+         ANSI-LOOP::LOOP-COLLECTOR-DATA SYSTEM::S-DATA-DOCUMENTATION
+         ANSI-LOOP::LOOP-EMIT-FINAL-VALUE COMMON-LISP::NINTH
+         SYSTEM::CHECK-DECLARATIONS ANSI-LOOP::LOOP-PATH-NAMES
+         COMMON-LISP::LOGICAL-PATHNAME COMMON-LISP::SIGNUM
+         COMMON-LISP::FIND-ALL-SYMBOLS COMMON-LISP::FIFTH
+         SYSTEM::S-DATA-P ANSI-LOOP::LOOP-CONSTANTP SYSTEM::IDESCRIBE
+         SYSTEM::BKPT-FORM ANSI-LOOP::MAKE-ANSI-LOOP-UNIVERSE
+         SLOOP::SLOOP-SLOOP-MACRO SYSTEM::NEXT-STACK-FRAME
+         SYSTEM::INSPECT-CONS SYSTEM::KNOWN-TYPE-P
+         SYSTEM::RESET-TRACE-DECLARATIONS COMMON-LISP::SINH
+         ANSI-LOOP::LOOP-PATH-P COMMON-LISP::PROVIDE
+         SYSTEM::INSPECT-SYMBOL SYSTEM::FIND-DOCUMENTATION
+         ANSI-LOOP::LOOP-MAKE-DESETQ COMMON-LISP::TENTH
+         SYSTEM::MAKE-DEFPACKAGE-FORM COMMON-LISP::FILE-WRITE-DATE
+         COMMON-LISP::TWO-WAY-STREAM-OUTPUT-STREAM
+         COMMON-LISP::TRUENAME COMMON-LISP::COMPLEMENT
+         COMMON-LISP::FIRST ANSI-LOOP::LOOP-COLLECTOR-CLASS
+         ANSI-LOOP::LOOP-COLLECTOR-TEMPVARS COMMON-LISP::ATANH
+         SYSTEM::LOGICAL-PATHNAMEP COMMON-LISP::DIRECTORY-NAMESTRING
+         SYSTEM::RESTART-P ANSI-LOOP::LOOP-MINIMAX-ANSWER-VARIABLE
+         SYSTEM::FIND-KCL-TOP-RESTART COMMON-LISP::FILE-NAMESTRING
+         COMMON-LISP::STREAM-EXTERNAL-FORMAT COMMON-LISP::SECOND
+         COMMON-LISP::FILE-LENGTH SYSTEM::INSTREAM-STREAM
+         ANSI-LOOP::LOOP-MINIMAX-TEMP-VARIABLE COMMON-LISP::PATHNAME
+         SYSTEM::DO-F COMMON-LISP::FILE-AUTHOR
+         SYSTEM::LOAD-PATHNAME-EXISTS SLOOP::AVERAGING-SLOOP-MACRO
+         ANSI-LOOP::LOOP-CONSTRUCT-RETURN ANSI-LOOP::LOOP-UNIVERSE-ANSI
+         ANSI-LOOP::LOOP-PSEUDO-BODY SLOOP::PARSE-LOOP
+         ANSI-LOOP::LOOP-HACK-ITERATION SYSTEM::S-DATA-CONC-NAME
+         SYSTEM::SEARCH-STACK ANSI-LOOP::LOOP-DO-THEREIS
+         COMMON-LISP::BYTE-SIZE ANSI-LOOP::LOOP-MINIMAX-FLAG-VARIABLE
+         COMMON-LISP::ACOSH SYSTEM::GET-PATH
+         COMMON-LISP::LOGICAL-PATHNAME-TRANSLATIONS
+         SYSTEM::S-DATA-CONSTRUCTORS SYSTEM::ENSURE-DIR-STRING
+         SYSTEM::FREEZE-DEFSTRUCT SYSTEM::PRINT-IHS
+         SYSTEM::INSPECT-CHARACTER COMMON-LISP::ARRAY-DIMENSIONS
+         SLOOP::PARSE-LOOP-INITIALLY SYSTEM::COMPUTING-ARGS-P
+         SYSTEM::INSTREAM-STREAM-NAME SYSTEM::PROCESS-ARGS FPE::GREF
+         SYSTEM::S-DATA-NAME ANSI-LOOP::LOOP-UNIVERSE-TYPE-KEYWORDS
+         SYSTEM::GET-BYTE-STREAM-NCHARS SYSTEM::S-DATA-INCLUDED
+         SYSTEM::WALK-THROUGH SYSTEM::RESTART-FUNCTION
+         SLOOP::TRANSLATE-NAME
+         ANSI-LOOP::LOOP-UNIVERSE-IMPLICIT-FOR-REQUIRED
+         COMMON-LISP::SEVENTH COMMON-LISP::CIS FPE::LOOKUP
+         COMMON-LISP::COSH COMMON-LISP::VECTOR-POP SYSTEM::IHS-FNAME
+         SYSTEM::BREAK-BACKWARD-SEARCH-STACK SLOOP::REPEAT-SLOOP-MACRO
+         COMMON-LISP::PROBE-FILE ANSI-LOOP::LOOP-LIST-COLLECTION
+         SYSTEM::CONTEXT-P COMMON-LISP::SIXTH SYSTEM::NC
+         SYSTEM::MAKE-FRAME COMMON-LISP::COMPILE-FILE-PATHNAME
+         SYSTEM::INFO-NODE-FROM-POSITION SYSTEM::NODE-OFFSET
+         SYSTEM::RESTART-TEST-FUNCTION SYSTEM::ALOAD
+         ANSI-LOOP::LOOP-UNIVERSE-FOR-KEYWORDS
+         ANSI-LOOP::LOOP-COLLECTOR-DTYPE SYSTEM::S-DATA-OFFSET
+         SYSTEM::SHOW-ENVIRONMENT COMMON-LISP::SYNONYM-STREAM-SYMBOL
+         SYSTEM::INSPECT-ARRAY ANSI-LOOP::LOOP-MAKE-PSETQ)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
-             COMMON-LISP::HASH-TABLE)
-         SYSTEM::CONTEXT-SPICE)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::*) COMMON-LISP::*)
+         SYSTEM::BREAK-QUIT SYSTEM::DBL-BACKTRACE
+         SYSTEM::BREAK-PREVIOUS SYSTEM::INFO-ERROR SYSTEM::BREAK-VS
+         SYSTEM::BREAK-LOCAL SYSTEM::IHS-BACKTRACE
+         ANSI-LOOP::LOOP-OPTIONAL-TYPE SYSTEM::BREAK-NEXT
+         COMMON-LISP::MUFFLE-WARNING SYSTEM::BREAK-BDS
+         COMMON-LISP::CONTINUE SYSTEM::SHOW-BREAK-VARIABLES)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION (COMMON-LISP::T)
-             (COMMON-LISP::OR COMMON-LISP::NULL
-                 COMMON-LISP::HASH-TABLE))
-         SYSTEM::CONTEXT-HASH)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
-             COMMON-LISP::FIXNUM)
-         ANSI-LOOP::DUPLICATABLE-CODE-P SYSTEM::RELATIVE-LINE
-         SYSTEM::LENEL SYSTEM::GET-NODE-INDEX SYSTEM::FASLINK
-         SYSTEM::THE-END)) 
+             (COMMON-LISP::VECTOR COMMON-LISP::T))
+         SYSTEM::CONTEXT-VEC)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
+         (COMMON-LISP::FUNCTION
+             ((COMMON-LISP::VECTOR COMMON-LISP::CHARACTER
+                  COMMON-LISP::*))
              COMMON-LISP::T)
-         SLOOP::IN-PACKAGE-SLOOP-MAP SLOOP::DESETQ1
-         COMMON-LISP::LOGANDC2 ANSI-LOOP::MAKE-LOOP-MINIMAX
-         COMMON-LISP::WRITE-BYTE SYSTEM::MATCH-DIMENSIONS
-         SLOOP::IN-CAREFULLY-SLOOP-FOR SLOOP::SUM-SLOOP-COLLECT
-         SYSTEM::DOT-DIR-P SLOOP::IN-FRINGE-SLOOP-MAP
-         SLOOP::COLLATE-SLOOP-COLLECT ANSI-LOOP::LOOP-TMEMBER
-         FPE::READ-OPERANDS SYSTEM::IN-INTERVAL-P SYSTEM::SUBSTRINGP
-         FPE::PAREN-READER ANSI-LOOP::HIDE-VARIABLE-REFERENCES
-         SYSTEM::QUOTATION-READER SYSTEM::ALL-MATCHES SYSTEM::GET-MATCH
-         SYSTEM::ADD-FILE ANSI-LOOP::LOOP-DO-ALWAYS SLOOP::THE-TYPE
-         SYSTEM::?PUSH SYSTEM::INCREMENT-CURSOR
-         SYSTEM::CHECK-SEQ-START-END SLOOP::MAKE-VALUE
-         SLOOP::THEREIS-SLOOP-COLLECT ANSI-LOOP::LOOP-DO-WHILE
-         COMMON-LISP::COERCE ANSI-LOOP::LOOP-TEQUAL
-         ANSI-LOOP::LOOP-DECLARE-VARIABLE COMMON-LISP::LOGNAND
-         COMMON-LISP::LOGORC1 SYSTEM::BREAK-STEP-NEXT
-         SLOOP::LOGXOR-SLOOP-COLLECT COMMON-LISP::LOGNOR
-         COMPILER::COMPILER-DEF-HOOK ANSI-LOOP::LOOP-TASSOC
-         SYSTEM::GET-LINE-OF-FORM SLOOP::MAXIMIZE-SLOOP-COLLECT
-         ANSI-LOOP::LOOP-DO-IF SYSTEM::SETF-EXPAND SYSTEM::DM-V
-         SYSTEM::ITERATE-OVER-BKPTS COMMON-LISP::NTHCDR
-         SYSTEM::CONDITION-PASS SYSTEM::DISPLAY-COMPILED-ENV
-         COMMON-LISP::LDB-TEST ANSI-LOOP::LOOP-MAYBE-BIND-FORM
-         SYSTEM::SUPER-GO SYSTEM::SETF-LOGICAL-PATHNAME-TRANSLATIONS
-         FPE::RF SYSTEM::SUB-INTERVAL-P SYSTEM::LEFT-PARENTHESIS-READER
-         COMMON-LISP::FILE-STRING-LENGTH SYSTEM::OBJLT SYSTEM::MSUB
-         SYSTEM::COERCE-TO-STRING SYSTEM::SAFE-EVAL
-         SYSTEM::SET-PATH-STREAM-NAME SYSTEM::SET-BACK
-         ANSI-LOOP::LOOP-NOTE-MINIMAX-OPERATION COMMON-LISP::LOGTEST
-         SYSTEM::*BREAK-POINTS* SLOOP::=-SLOOP-FOR
-         SLOOP::MINIMIZE-SLOOP-COLLECT SYSTEM::KEYWORD-SUPPLIED-P
-         SLOOP::COUNT-SLOOP-COLLECT FPE::%-READER COMMON-LISP::LOGORC2
-         SYSTEM::SEQUENCE-CURSOR SYSTEM::LOOKUP-KEYWORD
-         COMMON-LISP::BYTE SYSTEM::PARSE-SLOT-DESCRIPTION
-         COMMON-LISP::LOGANDC1 SYSTEM::DM-NTH-CDR FPE::0-READER
-         SLOOP::L-EQUAL SYSTEM::LIST-DELQ SYSTEM::DM-NTH
-         COMMON-LISP::LDB SYSTEM::SETF-HELPER
-         SLOOP::NEVER-SLOOP-COLLECT SLOOP::PARSE-LOOP-MAP
-         COMMON-LISP::NTH SYSTEM::BREAK-STEP-INTO
-         SYSTEM::GET-INFO-CHOICES SLOOP::IN-TABLE-SLOOP-MAP
-         SYSTEM::GET-NODES COMMON-LISP::VECTOR-PUSH
-         COMMON-LISP::PATHNAME-MATCH-P SYSTEM::DBL-UP
-         ANSI-LOOP::LOOP-LOOKUP-KEYWORD FPE::READ-INSTRUCTION
-         SLOOP::ALWAYS-SLOOP-COLLECT SYSTEM::SET-DIR SYSTEM::INFO-AUX
-         SYSTEM::DISPLAY-ENV COMMON-LISP::DOCUMENTATION
-         SYSTEM::OVERWRITE-SLOT-DESCRIPTIONS)) 
+         SYSTEM::RESET-SYS-PATHS)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::*)
-             COMMON-LISP::*)
-         COMMON-LISP::APROPOS ANSI-LOOP::LOOP-CONSTANT-FOLD-IF-POSSIBLE
-         COMMON-LISP::FFLOOR SYSTEM::PRINT-DOC SYSTEM::INFO
-         SYSTEM::PARSE-BODY-HEADER COMMON-LISP::INVOKE-RESTART
-         SYSTEM::BREAK-FUNCTION SYSTEM::SHOW-INFO COMMON-LISP::FROUND
-         COMMON-LISP::GET-SETF-EXPANSION COMMON-LISP::PARSE-NAMESTRING
-         SYSTEM::APROPOS-DOC COMMON-LISP::ENSURE-DIRECTORIES-EXIST
-         COMMON-LISP::USE-VALUE COMMON-LISP::READ-FROM-STRING
-         COMMON-LISP::FTRUNCATE COMMON-LISP::STORE-VALUE
-         SYSTEM::STEPPER SYSTEM::GET-SETF-METHOD-MULTIPLE-VALUE
-         COMMON-LISP::APROPOS-LIST COMMON-LISP::FCEILING
-         COMMON-LISP::WRITE-TO-STRING
-         COMMON-LISP::DECODE-UNIVERSAL-TIME)) 
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T)
+             COMMON-LISP::T)
+         SYSTEM::MAYBE-BREAK SYSTEM::MME3 SYSTEM::FIND-LINE-IN-FUN
+         SYSTEM::SETF-STRUCTURE-ACCESS SYSTEM::EXPAND-RANGE
+         SYSTEM::MINMAX SYSTEM::COERCE-TO-CONDITION
+         SLOOP::FIRST-SLOOP-FOR SLOOP::FIRST-USE-SLOOP-FOR
+         SYSTEM::DO-BREAK-LEVEL SYSTEM::ELSUB
+         ANSI-LOOP::LOOP-FOR-ARITHMETIC SYSTEM::CALL-TEST
+         SYSTEM::ELEMENT SYSTEM::LOAD-PATHNAME)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
              COMMON-LISP::T)
-         SYSTEM::SETF-EXPAND-1 SLOOP::LOOP-PARSE-ADDITIONAL-COLLECTIONS
-         SYSTEM::WARN-VERSION ANSI-LOOP::LOOP-TRANSLATE
-         ANSI-LOOP::LOOP-FOR-IN ANSI-LOOP::PRINT-LOOP-UNIVERSE
-         ANSI-LOOP::LOOP-STANDARD-EXPANSION
-         ANSI-LOOP::LOOP-ANSI-FOR-EQUALS SYSTEM::DM-VL
-         SYSTEM::SHARP-A-READER COMMON-LISP::DEPOSIT-FIELD
-         SYSTEM::RESTART-CASE-EXPRESSION-CONDITION
-         SYSTEM::APPLY-DISPLAY-FUN ANSI-LOOP::HIDE-VARIABLE-REFERENCE
-         SYSTEM::FLOATING-POINT-ERROR SYSTEM::GET-SLOT-POS
+         SYSTEM::SHARP-P-READER ANSI-LOOP::HIDE-VARIABLE-REFERENCE
+         SYSTEM::CHECK-TRACE-ARGS SYSTEM::SHARP-U-READER
+         SYSTEM::FLOATING-POINT-ERROR ANSI-LOOP::LOOP-FOR-IN
+         COMMON-LISP::DEPOSIT-FIELD SYSTEM::GET-SLOT-POS
+         SYSTEM::SHARP-A-READER SYSTEM::SHARP-V-READER
+         SYSTEM::PATHNAME-PARSE
+         SLOOP::LOOP-PARSE-ADDITIONAL-COLLECTIONS SYSTEM::SETF-EXPAND-1
+         COMMON-LISP::DPB SYSTEM::RESTART-CASE-EXPRESSION-CONDITION
+         SYSTEM::CHECK-S-DATA ANSI-LOOP::LOOP-FOR-BEING
+         SYSTEM::TO-REGEXP-OR-NAMESTRING SYSTEM::APPLY-DISPLAY-FUN
+         ANSI-LOOP::LOOP-ANSI-FOR-EQUALS ANSI-LOOP::LOOP-SUM-COLLECTION
+         ANSI-LOOP::LOOP-FOR-ON SYSTEM::MFR
+         ANSI-LOOP::LOOP-STANDARD-EXPANSION SYSTEM::PROG?*
          ANSI-LOOP::LOOP-MAKE-ITERATION-VARIABLE
-         SYSTEM::MAKE-BREAK-POINT SYSTEM::SHARP-V-READER
-         SYSTEM::TO-REGEXP-OR-NAMESTRING ANSI-LOOP::LOOP-FOR-ON
-         SYSTEM::SHARP-U-READER ANSI-LOOP::LOOP-SUM-COLLECTION
-         SYSTEM::SHARP-P-READER SYSTEM::MAKE-T-TYPE
-         ANSI-LOOP::LOOP-FOR-ACROSS SYSTEM::MFR SYSTEM::RECURSE-DIR
-         SYSTEM::PATHNAME-PARSE ANSI-LOOP::LOOP-FOR-BEING
-         COMMON-LISP::DPB SYSTEM::SHARP-DQ-READER
-         SYSTEM::CHECK-TRACE-ARGS SYSTEM::DEFMACRO*
-         SYSTEM::CHECK-S-DATA FPE::REF)) 
+         SYSTEM::SHARP-DQ-READER SYSTEM::RECURSE-DIR SYSTEM::DM-VL
+         ANSI-LOOP::LOOP-FOR-ACROSS ANSI-LOOP::PRINT-LOOP-UNIVERSE
+         SYSTEM::WARN-VERSION ANSI-LOOP::LOOP-TRANSLATE
+         SYSTEM::DEFMACRO* SYSTEM::MAKE-BREAK-POINT SYSTEM::MAKE-T-TYPE
+         FPE::REF)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::*)
+             COMMON-LISP::T)
+         SYSTEM::MME2 COMMON-LISP::SUBSTITUTE-IF-NOT
+         ANSI-LOOP::LOOP-HASH-TABLE-ITERATION-PATH
+         COMMON-LISP::SUBSTITUTE SYSTEM::WALK-DIR
+         SYSTEM::CHECK-TYPE-SYMBOL COMMON-LISP::TRANSLATE-PATHNAME
+         ANSI-LOOP::LOOP-PACKAGE-SYMBOLS-ITERATION-PATH
+         COMMON-LISP::MAP ANSI-LOOP::LOOP-SEQUENCE-ELEMENTS-PATH
+         ANSI-LOOP::ADD-LOOP-PATH SLOOP::LOOP-DECLARE-BINDING
+         SYSTEM::COMPLETE-PROP SYSTEM::MATCH-COMPONENT
+         COMMON-LISP::NSUBSTITUTE COMMON-LISP::NSUBSTITUTE-IF
+         COMMON-LISP::SUBSTITUTE-IF COMMON-LISP::NSUBSTITUTE-IF-NOT
+         SYSTEM::PUSH-LET-BINDING ANSI-LOOP::LOOP-MAKE-VARIABLE)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
              COMMON-LISP::T)
-         SYSTEM::FIND-IHS COMMON-LISP::NSET-DIFFERENCE
-         COMMON-LISP::BIT-NAND SYSTEM::BREAK-CALL
-         COMMON-LISP::COUNT-IF-NOT COMMON-LISP::DELETE
-         SYSTEM::INTERNAL-COUNT COMMON-LISP::BIT-ORC1
-         COMMON-LISP::DELETE-IF COMMON-LISP::BIT-ANDC1
-         SYSTEM::VECTOR-PUSH-STRING COMMON-LISP::MISMATCH
-         COMMON-LISP::NOTEVERY SYSTEM::PROCESS-ERROR COMMON-LISP::TYPEP
-         COMMON-LISP::BIT-IOR COMMON-LISP::BIT-EQV
-         COMMON-LISP::COUNT-IF COMMON-LISP::REMOVE-IF
-         COMMON-LISP::EVERY COMMON-LISP::POSITION-IF-NOT
-         COMMON-LISP::ADJUST-ARRAY COMMON-LISP::VECTOR-PUSH-EXTEND
-         SYSTEM::INTERNAL-COUNT-IF-NOT COMMON-LISP::COUNT
-         COMMON-LISP::DELETE-IF-NOT COMMON-LISP::NINTERSECTION
-         COMMON-LISP::FIND-IF-NOT COMMON-LISP::BIT-ORC2
-         COMMON-LISP::SUBSETP COMMON-LISP::SOME SYSTEM::WREADDIR
-         COMMON-LISP::SET-DIFFERENCE COMMON-LISP::UNION
-         COMMON-LISP::BIT-XOR SLOOP::PARSE-LOOP-MACRO
-         COMMON-LISP::REPLACE COMMON-LISP::REMOVE
-         SLOOP::LOOP-ADD-BINDING COMMON-LISP::BIT-ANDC2
-         COMMON-LISP::READ-SEQUENCE COMMON-LISP::CERROR
-         COMMON-LISP::INTERSECTION COMMON-LISP::POSITION-IF
-         ANSI-LOOP::LOOP-CHECK-DATA-TYPE SYSTEM::INTERNAL-COUNT-IF
-         COMMON-LISP::NUNION COMMON-LISP::WRITE-SEQUENCE
-         COMMON-LISP::MAP-INTO COMMON-LISP::MAKE-SEQUENCE
-         COMMON-LISP::SET-EXCLUSIVE-OR SLOOP::IN-ARRAY-SLOOP-FOR
-         COMMON-LISP::FIND-IF COMMON-LISP::SEARCH COMMON-LISP::FILL
-         COMMON-LISP::FIND COMMON-LISP::NOTANY
-         COMMON-LISP::NSET-EXCLUSIVE-OR COMMON-LISP::BIT-NOR
-         COMMON-LISP::REMOVE-IF-NOT COMMON-LISP::POSITION
-         COMMON-LISP::BIT-AND)) 
+         COMMON-LISP::DELETE-IF-NOT COMMON-LISP::FILL
+         COMMON-LISP::SET-EXCLUSIVE-OR ANSI-LOOP::LOOP-CHECK-DATA-TYPE
+         SYSTEM::INTERNAL-COUNT-IF-NOT COMMON-LISP::SOME
+         COMMON-LISP::COUNT COMMON-LISP::NOTANY SYSTEM::INTERNAL-COUNT
+         COMMON-LISP::POSITION-IF-NOT COMMON-LISP::SET-DIFFERENCE
+         SLOOP::IN-ARRAY-SLOOP-FOR COMMON-LISP::NUNION
+         COMMON-LISP::BIT-NAND SYSTEM::PROCESS-ERROR
+         COMMON-LISP::BIT-ANDC2 COMMON-LISP::POSITION-IF
+         COMMON-LISP::NSET-DIFFERENCE COMMON-LISP::WRITE-SEQUENCE
+         COMMON-LISP::BIT-XOR COMMON-LISP::READ-SEQUENCE
+         COMMON-LISP::DELETE-IF COMMON-LISP::MAP-INTO
+         COMMON-LISP::SUBSETP COMMON-LISP::REMOVE-IF-NOT
+         COMMON-LISP::FIND-IF COMMON-LISP::INTERSECTION
+         COMMON-LISP::REPLACE COMMON-LISP::VECTOR-PUSH-EXTEND
+         COMMON-LISP::BIT-ORC2 COMMON-LISP::POSITION
+         COMMON-LISP::CERROR COMMON-LISP::FIND COMMON-LISP::BIT-ORC1
+         SYSTEM::BREAK-CALL SLOOP::PARSE-LOOP-MACRO COMMON-LISP::EVERY
+         COMMON-LISP::COUNT-IF-NOT COMMON-LISP::ADJUST-ARRAY
+         COMMON-LISP::SEARCH COMMON-LISP::REMOVE-IF
+         COMMON-LISP::NOTEVERY COMMON-LISP::TYPEP COMMON-LISP::COUNT-IF
+         SYSTEM::WREADDIR SYSTEM::INTERNAL-COUNT-IF COMMON-LISP::DELETE
+         COMMON-LISP::NSET-EXCLUSIVE-OR COMMON-LISP::UNION
+         COMMON-LISP::BIT-EQV COMMON-LISP::NINTERSECTION
+         COMMON-LISP::MISMATCH SYSTEM::FIND-IHS COMMON-LISP::REMOVE
+         SYSTEM::VECTOR-PUSH-STRING COMMON-LISP::BIT-IOR
+         COMMON-LISP::FIND-IF-NOT COMMON-LISP::MAKE-SEQUENCE
+         COMMON-LISP::BIT-ANDC1 SLOOP::LOOP-ADD-BINDING
+         COMMON-LISP::BIT-NOR COMMON-LISP::BIT-AND)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T)
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
              COMMON-LISP::T)
-         SYSTEM::FIND-LINE-IN-FUN ANSI-LOOP::LOOP-FOR-ARITHMETIC
-         SYSTEM::EXPAND-RANGE SYSTEM::MAYBE-BREAK SYSTEM::MINMAX
-         SLOOP::FIRST-USE-SLOOP-FOR SLOOP::FIRST-SLOOP-FOR
-         SYSTEM::SETF-STRUCTURE-ACCESS SYSTEM::DO-BREAK-LEVEL
-         SYSTEM::CALL-TEST SYSTEM::ELEMENT SYSTEM::LOAD-PATHNAME
-         SYSTEM::COERCE-TO-CONDITION SYSTEM::ELSUB)) 
+         SYSTEM::DO-ARG-COUNT-ERROR SYSTEM::PUSH-SUB-LIST-BINDING)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::*)
+                 COMMON-LISP::T COMMON-LISP::T)
              COMMON-LISP::T)
-         SLOOP::DEF-LOOP-INTERNAL COMMON-LISP::MERGE
-         SYSTEM::PRINT-STACK-FRAME)) 
+         SYSTEM::MAKE-PREDICATE SYSTEM::DO?* SYSTEM::MAKE-CONSTRUCTOR)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
                  COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::*)
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T)
              COMMON-LISP::T)
-         COMMON-LISP::ENCODE-UNIVERSAL-TIME)) 
+         ANSI-LOOP::LOOP-SEQUENCER)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::*)
+                 COMMON-LISP::T COMMON-LISP::*)
              COMMON-LISP::T)
-         ANSI-LOOP::LOOP-PACKAGE-SYMBOLS-ITERATION-PATH
-         SYSTEM::COMPLETE-PROP SYSTEM::CHECK-TYPE-SYMBOL
-         COMMON-LISP::NSUBSTITUTE
-         ANSI-LOOP::LOOP-SEQUENCE-ELEMENTS-PATH COMMON-LISP::SUBSTITUTE
-         COMMON-LISP::TRANSLATE-PATHNAME COMMON-LISP::NSUBSTITUTE-IF
-         COMMON-LISP::MAP SLOOP::LOOP-DECLARE-BINDING SYSTEM::WALK-DIR
-         SYSTEM::MATCH-COMPONENT ANSI-LOOP::LOOP-MAKE-VARIABLE
-         ANSI-LOOP::ADD-LOOP-PATH COMMON-LISP::SUBSTITUTE-IF
-         COMMON-LISP::NSUBSTITUTE-IF-NOT SYSTEM::MME2
-         ANSI-LOOP::LOOP-HASH-TABLE-ITERATION-PATH
-         COMMON-LISP::SUBSTITUTE-IF-NOT SYSTEM::PUSH-LET-BINDING)) 
+         SYSTEM::EXPAND-WILD-DIRECTORY SLOOP::DEF-LOOP-INTERNAL
+         COMMON-LISP::MERGE SYSTEM::PRINT-STACK-FRAME)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
@@ -243,88 +286,120 @@
                  (COMMON-LISP::INTEGER -9223372036854775808
                      9223372036854775807))
              COMMON-LISP::T)
-         SYSTEM::SHARP-SHARP-READER SYSTEM::SHARP-EQ-READER)) 
+         SYSTEM::SHARP-EQ-READER SYSTEM::SHARP-SHARP-READER)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::*)
              COMMON-LISP::T)
-         SYSTEM::DO-ARG-COUNT-ERROR SYSTEM::PUSH-SUB-LIST-BINDING)) 
+         COMMON-LISP::ENCODE-UNIVERSAL-TIME)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T)
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
              COMMON-LISP::T)
-         SYSTEM::MAKE-CONSTRUCTOR SYSTEM::MAKE-PREDICATE)) 
+         SYSTEM::UNIVERSAL-ERROR-HANDLER)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
+             COMMON-LISP::*)
+         SYSTEM::PARSE-DEFMACRO SYSTEM::PARSE-DEFMACRO-LAMBDA-LIST)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::*)
+             COMMON-LISP::*)
+         COMMON-LISP::SUBST COMMON-LISP::SUBST-IF-NOT
+         COMMON-LISP::SUBST-IF SYSTEM::MASET)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
+             COMMON-LISP::*)
+         SYSTEM::READ-INSPECT-COMMAND SYSTEM::RESTART-PRINT
+         ANSI-LOOP::LOOP-GET-COLLECTION-INFO SYSTEM::SHARP-+-READER
+         SYSTEM::VERIFY-KEYWORDS SYSTEM::SHARP-S-READER
+         SYSTEM::LIST-MERGE-SORT SYSTEM::SHARP---READER)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
+             COMMON-LISP::*)
+         SYSTEM::PARSE-BODY COMMON-LISP::SORT
+         SLOOP::FIND-IN-ORDERED-LIST COMMON-LISP::REDUCE
+         COMMON-LISP::STABLE-SORT COMMON-LISP::SUBTYPEP)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
                  COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
                  COMMON-LISP::T)
-             COMMON-LISP::T)
-         ANSI-LOOP::LOOP-SEQUENCER)) 
+             COMMON-LISP::*)
+         SYSTEM::TRACE-CALL)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
-             COMMON-LISP::T)
-         SYSTEM::UNIVERSAL-ERROR-HANDLER)) 
-(COMMON-LISP::MAPC
-    (COMMON-LISP::LAMBDA (COMPILER::X)
-      (COMMON-LISP::SETF
-          (COMMON-LISP::GET COMPILER::X 'COMPILER::PROCLAIMED-CLOSURE)
-          COMMON-LISP::T))
-    '(SYSTEM::SI-FIND-CLASS SYSTEM::WARNINGP SYSTEM::SI-CLASS-OF
-         SYSTEM::CONDITION-CLASS-P SYSTEM::UNTRACE-ONE
-         SYSTEM::MAKE-ACCESS-FUNCTION SYSTEM::SIMPLE-CONDITION-CLASS-P
-         SYSTEM::CONDITIONP SYSTEM::AUTOLOAD
-         SYSTEM::SI-CLASS-PRECEDENCE-LIST SYSTEM::SI-CLASSP
-         FPE::BREAK-ON-FLOATING-POINT-EXCEPTIONS SYSTEM::TRACE-ONE
-         SYSTEM::AUTOLOAD-MACRO SYSTEM::DEFINE-STRUCTURE
-         SYSTEM::SI-CLASS-NAME)) 
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::T)
+             COMMON-LISP::*)
+         SYSTEM::PUSH-OPTIONAL-BINDING)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::*)
-         SYSTEM::INSTREAM-NAME ANSI-LOOP::LOOP-LIST-STEP
-         COMMON-LISP::PRIN1-TO-STRING ANSI-LOOP::NAMED-VARIABLE
-         SYSTEM::WAITING SYSTEM::FIND-DECLARATIONS COMMON-LISP::INSPECT
-         SYSTEM::END-WAITING SYSTEM::BREAK-GO SYSTEM::INFO-SUBFILE
-         COMMON-LISP::INVOKE-RESTART-INTERACTIVELY
-         ANSI-LOOP::LOOP-OPTIMIZATION-QUANTITIES SYSTEM::INSPECT-OBJECT
-         SYSTEM::BREAK-LEVEL-INVOKE-RESTART SYSTEM::EXPAND-RANGES
-         SYSTEM::GET-&ENVIRONMENT COMMON-LISP::DESCRIBE
-         COMMON-LISP::PRINC-TO-STRING)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::*) COMMON-LISP::T)
+         SYSTEM::MAKE-CONTEXT ANSI-LOOP::MAKE-STANDARD-LOOP-UNIVERSE
+         ANSI-LOOP::MAKE-LOOP-UNIVERSE SYSTEM::MAKE-S-DATA
+         SYSTEM::NEXT-MATCH COMMON-LISP::USER-HOMEDIR-PATHNAME
+         SYSTEM::STEP-NEXT ANSI-LOOP::LOOP-DISALLOW-CONDITIONAL
+         COMMON-LISP::VECTOR SLOOP::PARSE-LOOP-WITH
+         COMMON-LISP::COMPUTE-RESTARTS COMMON-LISP::BREAK
+         ANSI-LOOP::MAKE-LOOP-PATH ANSI-LOOP::LOOP-GENTEMP
+         COMMON-LISP::ABORT COMMON-LISP::YES-OR-NO-P
+         SYSTEM::MAKE-INSTREAM SYSTEM::DBL-READ
+         SYSTEM::MAYBE-CLEAR-INPUT SYSTEM::MAKE-RESTART
+         ANSI-LOOP::MAKE-LOOP-MINIMAX-INTERNAL COMMON-LISP::Y-OR-N-P
+         SLOOP::PARSE-LOOP-DECLARE ANSI-LOOP::MAKE-LOOP-COLLECTOR
+         SYSTEM::DESCRIBE-ENVIRONMENT SYSTEM::STEP-INTO
+         SYSTEM::CURRENT-STEP-FUN COMMON-LISP::DRIBBLE
+         COMMON-LISP::MAKE-PATHNAME SYSTEM::BREAK-LOCALS SYSTEM::LOC
+         SYSTEM::TRANSFORM-KEYWORDS)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::*) COMMON-LISP::T)
-         COMMON-LISP::ABORT ANSI-LOOP::MAKE-STANDARD-LOOP-UNIVERSE
-         SYSTEM::MAKE-S-DATA ANSI-LOOP::MAKE-LOOP-MINIMAX-INTERNAL
-         ANSI-LOOP::MAKE-LOOP-PATH SYSTEM::CURRENT-STEP-FUN SYSTEM::LOC
-         SYSTEM::DBL-READ SYSTEM::MAKE-RESTART
-         SYSTEM::TRANSFORM-KEYWORDS COMMON-LISP::Y-OR-N-P
-         SYSTEM::NEXT-MATCH COMMON-LISP::COMPUTE-RESTARTS
-         SLOOP::PARSE-LOOP-WITH COMMON-LISP::VECTOR SYSTEM::STEP-NEXT
-         ANSI-LOOP::MAKE-LOOP-COLLECTOR
-         COMMON-LISP::USER-HOMEDIR-PATHNAME SLOOP::PARSE-LOOP-DECLARE
-         COMMON-LISP::YES-OR-NO-P SYSTEM::STEP-INTO
-         SYSTEM::MAKE-CONTEXT SYSTEM::BREAK-LOCALS
-         SYSTEM::DESCRIBE-ENVIRONMENT COMMON-LISP::DRIBBLE
-         ANSI-LOOP::LOOP-DISALLOW-CONDITIONAL SYSTEM::MAYBE-CLEAR-INPUT
-         COMMON-LISP::BREAK ANSI-LOOP::LOOP-GENTEMP
-         ANSI-LOOP::MAKE-LOOP-UNIVERSE SYSTEM::MAKE-INSTREAM
-         COMMON-LISP::MAKE-PATHNAME)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::*)
+         ANSI-LOOP::LOOP-OPTIMIZATION-QUANTITIES
+         COMMON-LISP::PRIN1-TO-STRING SYSTEM::GET-&ENVIRONMENT
+         COMMON-LISP::INSPECT SYSTEM::BREAK-GO
+         SYSTEM::PARSE-BODY-HEADER COMMON-LISP::PRINC-TO-STRING
+         SYSTEM::EXPAND-RANGES ANSI-LOOP::NAMED-VARIABLE
+         ANSI-LOOP::LOOP-LIST-STEP SYSTEM::INSTREAM-NAME
+         SYSTEM::WAITING SYSTEM::END-WAITING COMMON-LISP::DESCRIBE
+         SYSTEM::INFO-SUBFILE SYSTEM::FIND-DECLARATIONS
+         SYSTEM::INSPECT-OBJECT SYSTEM::BREAK-LEVEL-INVOKE-RESTART
+         COMMON-LISP::INVOKE-RESTART-INTERACTIVELY)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             ((COMMON-LISP::INTEGER -9223372036854775808
-                  9223372036854775807))
-             COMMON-LISP::FIXNUM)
-         FPE::FE-ENABLE SYSTEM::DBL-WHAT-FRAME)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::FIXNUM)
+         SYSTEM::S-DATA-SIZE FPE::REG-LOOKUP SYSTEM::INSTREAM-LINE
+         SYSTEM::S-DATA-LENGTH SYSTEM::THE-START)) 
+(COMMON-LISP::MAPC
+    (COMMON-LISP::LAMBDA (COMPILER::X)
+      (COMMON-LISP::SETF
+          (COMMON-LISP::GET COMPILER::X 'COMPILER::PROCLAIMED-CLOSURE)
+          COMMON-LISP::T))
+    '(SYSTEM::SI-CLASS-PRECEDENCE-LIST SYSTEM::AUTOLOAD
+         SYSTEM::UNTRACE-ONE SYSTEM::TRACE-ONE SYSTEM::CONDITIONP
+         SYSTEM::MAKE-ACCESS-FUNCTION SYSTEM::SI-CLASS-NAME
+         SYSTEM::SI-CLASSP SYSTEM::SI-CLASS-OF SYSTEM::SI-FIND-CLASS
+         SYSTEM::CONDITION-CLASS-P SYSTEM::AUTOLOAD-MACRO
+         SYSTEM::WARNINGP SYSTEM::DEFINE-STRUCTURE
+         FPE::BREAK-ON-FLOATING-POINT-EXCEPTIONS
+         SYSTEM::SIMPLE-CONDITION-CLASS-P)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
@@ -336,155 +411,9 @@
          SYSTEM::ROUND-UP)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             ((COMMON-LISP::VECTOR COMMON-LISP::CHARACTER
-                  COMMON-LISP::*)
-              (COMMON-LISP::INTEGER -9223372036854775808
-                  9223372036854775807))
-             COMMON-LISP::FIXNUM)
-         SYSTEM::ATOI)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::T)
-         SYSTEM::REGEXP-CONV SYSTEM::DIR-CONJ SYSTEM::DIR-P
-         ANSI-LOOP::LOOP-LIST-COLLECTION COMMON-LISP::COSH
-         SYSTEM::GET-BYTE-STREAM-NCHARS SYSTEM::INSPECT-CONS
-         SYSTEM::KNOWN-TYPE-P SYSTEM::LNP COMMON-LISP::SEVENTH
-         SYSTEM::BKPT-FUNCTION SYSTEM::WILD-DIR-ELEMENT-P
-         COMMON-LISP::COMPILER-MACRO-FUNCTION
-         ANSI-LOOP::LOOP-HACK-ITERATION
-         COMMON-LISP::ECHO-STREAM-OUTPUT-STREAM
-         SYSTEM::DIRECTORY-LIST-CHECK COMMON-LISP::FILE-WRITE-DATE
-         SYSTEM::NORMALIZE-TYPE COMMON-LISP::EIGHTH SYSTEM::TOGGLE-CASE
-         SYSTEM::SHOW-ENVIRONMENT
-         COMMON-LISP::TWO-WAY-STREAM-INPUT-STREAM SYSTEM::GET-PATH
-         COMMON-LISP::ASINH SYSTEM::FIND-KCL-TOP-RESTART
-         SYSTEM::RESTART-P SYSTEM::EVAL-FEATURE SYSTEM::ALOAD
-         COMMON-LISP::PHASE SLOOP::SUBSTITUTE-SLOOP-BODY
-         COMMON-LISP::ASIN SYSTEM::NODES-FROM-INDEX
-         SYSTEM::MAKE-DEFPACKAGE-FORM ANSI-LOOP::LOOP-COLLECTOR-DTYPE
-         SYSTEM::LOGICAL-PATHNAMEP SYSTEM::INSPECT-VECTOR
-         ANSI-LOOP::LOOP-UNIVERSE-TYPE-KEYWORDS
-         SYSTEM::RESTART-REPORT-FUNCTION SYSTEM::IHS-VISIBLE
-         SLOOP::LOOP-COLLECT-KEYWORD-P ANSI-LOOP::LOOP-TYPED-INIT
-         COMMON-LISP::VECTOR-POP SYSTEM::UNIQUE-ID
-         ANSI-LOOP::LOOP-UNIVERSE-ITERATION-KEYWORDS
-         SYSTEM::SIMPLE-ARRAY-P COMMON-LISP::ACOS SYSTEM::DBL-EVAL
-         SYSTEM::INSPECT-STRING SYSTEM::MLP
-         SYSTEM::INSTREAM-STREAM-NAME SYSTEM::WILD-NAMESTRING-P
-         ANSI-LOOP::LOOP-PATH-FUNCTION
-         SYSTEM::GET-STRING-INPUT-STREAM-INDEX
-         ANSI-LOOP::LOOP-MINIMAX-TEMP-VARIABLE SYSTEM::SEQTYPE
-         ANSI-LOOP::LOOP-UNIVERSE-KEYWORDS
-         SYSTEM::BEST-ARRAY-ELEMENT-TYPE
-         ANSI-LOOP::LOOP-MINIMAX-INFINITY-DATA SYSTEM::S-DATA-FROZEN
-         SYSTEM::S-DATA-DOCUMENTATION SYSTEM::DWIM COMMON-LISP::SIGNUM
-         SYSTEM::FIND-DOCUMENTATION ANSI-LOOP::LOOP-COLLECTOR-HISTORY
-         ANSI-LOOP::LOOP-MAKE-PSETQ FPE::GREF SYSTEM::S-DATA-OFFSET
-         SYSTEM::WILD-PATH-ELEMENT-P SYSTEM::INSTREAM-P
-         COMMON-LISP::DIRECTORY-NAMESTRING SYSTEM::INSPECT-ARRAY
-         COMMON-LISP::ARRAY-DIMENSIONS
-         ANSI-LOOP::LOOP-COLLECTOR-TEMPVARS ANSI-LOOP::LOOP-MINIMAX-P
-         SLOOP::RETURN-SLOOP-MACRO SYSTEM::WALK-THROUGH
-         SYSTEM::NEXT-STACK-FRAME SYSTEM::S-DATA-NAME COMMON-LISP::TANH
-         SYSTEM::BREAK-BACKWARD-SEARCH-STACK COMMON-LISP::TENTH
-         SYSTEM::INFO-NODE-FROM-POSITION FPE::ST-LOOKUP
-         COMMON-LISP::RESTART-NAME SYSTEM::S-DATA-TYPE
-         SYSTEM::BKPT-FILE-LINE COMMON-LISP::FIND-ALL-SYMBOLS
-         COMMON-LISP::FIFTH SLOOP::LOOP-LET-BINDINGS
-         COMMON-LISP::ECHO-STREAM-INPUT-STREAM
-         ANSI-LOOP::LOOP-UNIVERSE-IMPLICIT-FOR-REQUIRED
-         COMMON-LISP::PROBE-FILE SYSTEM::MAKE-FRAME
-         SYSTEM::IHS-NOT-INTERPRETED-ENV SYSTEM::SEARCH-STACK
-         COMMON-LISP::COMPILE-FILE-PATHNAME
-         SYSTEM::PRINT-SYMBOL-APROPOS COMMON-LISP::LOGNOT
-         SYSTEM::INFO-GET-TAGS SYSTEM::SHORT-NAME
-         ANSI-LOOP::LOOP-MINIMAX-TYPE COMMON-LISP::SIXTH
-         COMMON-LISP::SECOND ANSI-LOOP::LOOP-UNIVERSE-TYPE-SYMBOLS
-         COMMON-LISP::TWO-WAY-STREAM-OUTPUT-STREAM
-         SYSTEM::S-DATA-INCLUDES SYSTEM::RESTART-INTERACTIVE-FUNCTION
-         SLOOP::TRANSLATE-NAME SYSTEM::PATCH-SHARP COMMON-LISP::ABS
-         ANSI-LOOP::LOOP-CONSTANTP SYSTEM::LEAP-YEAR-P
-         ANSI-LOOP::LOOP-UNIVERSE-ANSI ANSI-LOOP::LOOP-EMIT-BODY
-         COMMON-LISP::HOST-NAMESTRING COMMON-LISP::FIRST
-         SYSTEM::INSERT-BREAK-POINT
-         COMMON-LISP::LOAD-LOGICAL-PATHNAME-TRANSLATIONS
-         COMMON-LISP::DELETE-FILE ANSI-LOOP::LOOP-PSEUDO-BODY
-         SYSTEM::GET-NEXT-VISIBLE-FUN SYSTEM::S-DATA-HAS-HOLES
-         ANSI-LOOP::LOOP-COLLECTOR-NAME COMMON-LISP::FOURTH
-         SYSTEM::BKPT-FILE SYSTEM::CANONICALIZE-PATHNAME-DIRECTORY
-         SYSTEM::INSTREAM-STREAM SYSTEM::PNL1 SYSTEM::IHS-FNAME
-         SYSTEM::S-DATA-SLOT-POSITION SLOOP::PARSE-LOOP
-         SYSTEM::CHECK-TRACE-SPEC SYSTEM::S-DATA-CONSTRUCTORS
-         SYSTEM::S-DATA-STATICP SYSTEM::CONTEXT-P
-         COMMON-LISP::LOGICAL-PATHNAME-TRANSLATIONS
-         SYSTEM::INFO-GET-FILE COMMON-LISP::COMPLEMENT
-         SYSTEM::INSPECT-NUMBER SYSTEM::RESET-TRACE-DECLARATIONS
-         ANSI-LOOP::LOOP-PATH-P SLOOP::REPEAT-SLOOP-MACRO SYSTEM::DO-F
-         SYSTEM::INSPECT-PACKAGE SYSTEM::PATH-STREAM-NAME
-         SYSTEM::GET-INSTREAM COMMON-LISP::BYTE-SIZE
-         SYSTEM::RESTART-FUNCTION FPE::LOOKUP SYSTEM::S-DATA-CONC-NAME
-         COMMON-LISP::PROVIDE SYSTEM::S-DATA-NAMED SYSTEM::PRINT-FRS
-         ANSI-LOOP::LOOP-MINIMAX-ANSWER-VARIABLE SYSTEM::NODE-OFFSET
-         ANSI-LOOP::MAKE-ANSI-LOOP-UNIVERSE SYSTEM::PRINT-IHS
-         ANSI-LOOP::LOOP-UNIVERSE-PATH-KEYWORDS COMMON-LISP::TRUENAME
-         SYSTEM::BREAK-FORWARD-SEARCH-STACK
-         COMMON-LISP::CONCATENATED-STREAM-STREAMS SYSTEM::VERSION-PARSE
-         SYSTEM::INSPECT-CHARACTER SYSTEM::LOGICAL-PATHNAME-HOST-P
-         SYSTEM::DM-BAD-KEY SYSTEM::EXPAND-HOME-DIR
-         ANSI-LOOP::LOOP-PATH-USER-DATA
-         ANSI-LOOP::LOOP-PATH-PREPOSITION-GROUPS SYSTEM::INSPECT-SYMBOL
-         COMMON-LISP::INVOKE-DEBUGGER
-         SYSTEM::LOGICAL-PATHNAME-DESIGNATOR-P
-         COMMON-LISP::BYTE-POSITION COMMON-LISP::ISQRT COMMON-LISP::CIS
-         ANSI-LOOP::LOOP-COLLECTOR-CLASS
-         COMMON-LISP::SYNONYM-STREAM-SYMBOL ANSI-LOOP::LOOP-PATH-NAMES
-         SYSTEM::RE-QUOTE-STRING SYSTEM::INSPECT-STRUCTURE
-         COMMON-LISP::RATIONAL FPE::XMM-LOOKUP
-         SYSTEM::REWRITE-RESTART-CASE-CLAUSE
-         SYSTEM::S-DATA-PRINT-FUNCTION
-         SYSTEM::RESTRICT-STREAM-ELEMENT-TYPE SLOOP::SLOOP-SLOOP-MACRO
-         COMMON-LISP::NAMESTRING SYSTEM::ENSURE-DIR-STRING
-         COMMON-LISP::CONSTANTLY SLOOP::PARSE-LOOP-INITIALLY
-         SYSTEM::S-DATA-RAW SYSTEM::ADD-TO-HOTLIST SYSTEM::FRS-KIND
-         ANSI-LOOP::LOOP-MAXMIN-COLLECTION
-         ANSI-LOOP::LOOP-COLLECTOR-DATA SYSTEM::PROCESS-ARGS
-         SYSTEM::COERCE-SLASH-TERMINATED SYSTEM::MAKE-KCL-TOP-RESTART
-         COMMON-LISP::ATANH ANSI-LOOP::LOOP-CODE-DUPLICATION-THRESHOLD
-         COMMON-LISP::SINH ANSI-LOOP::LOOP-UNIVERSE-P
-         ANSI-LOOP::LOOP-PATH-INCLUSIVE-PERMITTED
-         SYSTEM::S-DATA-INCLUDED COMMON-LISP::STREAM-EXTERNAL-FORMAT
-         SYSTEM::COMPUTING-ARGS-P SYSTEM::REAL-ASINH
-         ANSI-LOOP::LOOP-CONSTRUCT-RETURN
-         SYSTEM::S-DATA-SLOT-DESCRIPTIONS SYSTEM::FIX-LOAD-PATH
-         SYSTEM::CHECK-DECLARATIONS
-         ANSI-LOOP::LOOP-UNIVERSE-FOR-KEYWORDS
-         SLOOP::POINTER-FOR-COLLECT COMMON-LISP::LOGICAL-PATHNAME
-         SYSTEM::CHDIR SYSTEM::IDESCRIBE
-         ANSI-LOOP::LOOP-MINIMAX-OPERATIONS COMMON-LISP::ACOSH
-         COMMON-LISP::NINTH ANSI-LOOP::LOOP-MINIMAX-FLAG-VARIABLE
-         ANSI-LOOP::LOOP-COLLECTOR-P SYSTEM::S-DATA-P SYSTEM::BKPT-FORM
-         COMMON-LISP::FILE-NAMESTRING SYSTEM::TERMINAL-INTERRUPT
-         SYSTEM::SETUP-INFO SLOOP::PARSE-NO-BODY
-         SYSTEM::DM-KEY-NOT-ALLOWED ANSI-LOOP::LOOP-EMIT-FINAL-VALUE
-         SYSTEM::FREEZE-DEFSTRUCT SYSTEM::DBL-RPL-LOOP
-         SYSTEM::TRACE-ONE-PREPROCESS
-         COMMON-LISP::BROADCAST-STREAM-STREAMS COMMON-LISP::THIRD
-         SLOOP::AVERAGING-SLOOP-MACRO SYSTEM::SHOW-BREAK-POINT
-         COMMON-LISP::PATHNAME ANSI-LOOP::LOOP-DO-THEREIS
-         COMMON-LISP::FILE-AUTHOR ANSI-LOOP::LOOP-MAKE-DESETQ
-         SYSTEM::NC SYSTEM::NUMBER-OF-DAYS-FROM-1900
-         SYSTEM::RESTART-TEST-FUNCTION SYSTEM::WHICH
-         ANSI-LOOP::DESTRUCTURING-SIZE COMMON-LISP::FILE-LENGTH)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::*) COMMON-LISP::*)
-         SYSTEM::BREAK-VS ANSI-LOOP::LOOP-OPTIONAL-TYPE
-         SYSTEM::BREAK-BDS SYSTEM::IHS-BACKTRACE SYSTEM::INFO-ERROR
-         SYSTEM::BREAK-LOCAL SYSTEM::SHOW-BREAK-VARIABLES
-         COMMON-LISP::MUFFLE-WARNING SYSTEM::BREAK-PREVIOUS
-         SYSTEM::BREAK-QUIT SYSTEM::DBL-BACKTRACE COMMON-LISP::CONTINUE
-         SYSTEM::BREAK-NEXT)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
+             COMMON-LISP::HASH-TABLE)
+         SYSTEM::CONTEXT-SPICE)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION (COMMON-LISP::T)
@@ -512,124 +441,227 @@
          SYSTEM::BIGNTHCDR)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::*)
-             COMMON-LISP::T)
-         COMMON-LISP::FIND-RESTART COMMON-LISP::PATHNAME-HOST
-         SYSTEM::LINK-EXPAND COMMON-LISP::CONCATENATE COMMON-LISP::WARN
-         COMMON-LISP::FILE-POSITION ANSI-LOOP::LOOP-WARN
-         COMMON-LISP::PATHNAME-DIRECTORY COMMON-LISP::SBIT
-         COMMON-LISP::BIT ANSI-LOOP::LOOP-COLLECT-PREPOSITIONAL-PHRASES
-         COMMON-LISP::PATHNAME-TYPE COMMON-LISP::MAKE-ARRAY
-         ANSI-LOOP::LOOP-ERROR COMMON-LISP::DIRECTORY SYSTEM::DIR-PARSE
-         COMMON-LISP::TRANSLATE-LOGICAL-PATHNAME
-         SYSTEM::NTH-STACK-FRAME COMMON-LISP::REQUIRE COMMON-LISP::LOAD
-         SYSTEM::MGLIST COMMON-LISP::DELETE-DUPLICATES
-         COMMON-LISP::PATHNAME-VERSION COMMON-LISP::ENOUGH-NAMESTRING
-         SYSTEM::BAD-SEQ-LIMIT COMMON-LISP::REMOVE-DUPLICATES
-         COMMON-LISP::PATHNAME-NAME
-         COMMON-LISP::MAKE-STRING-INPUT-STREAM SLOOP::LOOP-ADD-TEMPS
-         SYSTEM::NLOAD SYSTEM::LIST-MATCHES
-         COMMON-LISP::ARRAY-ROW-MAJOR-INDEX
-         COMMON-LISP::ARRAY-IN-BOUNDS-P SYSTEM::BREAK-LEVEL
-         SYSTEM::PROCESS-SOME-ARGS SYSTEM::TO-REGEXP
-         COMMON-LISP::UPGRADED-ARRAY-ELEMENT-TYPE COMMON-LISP::OPEN
-         SYSTEM::FILE-SEARCH COMMON-LISP::READ-BYTE
-         SYSTEM::FILE-TO-STRING SLOOP::ADD-FROM-DATA COMMON-LISP::ERROR
-         COMMON-LISP::SIGNAL SYSTEM::MGSUB COMMON-LISP::WILD-PATHNAME-P
-         COMMON-LISP::PATHNAME-DEVICE SYSTEM::LOGICAL-PATHNAME-PARSE
-         COMMON-LISP::MERGE-PATHNAMES SYSTEM::INFO-SEARCH
-         COMMON-LISP::BIT-NOT)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
-             COMMON-LISP::*)
-         ANSI-LOOP::ESTIMATE-CODE-SIZE-1 SYSTEM::DO-REPL
-         SYSTEM::SOURCE-PORTION SYSTEM::RESTART-REPORT
-         SYSTEM::NEW-SEMI-COLON-READER SYSTEM::FIND-DOC
-         ANSI-LOOP::ESTIMATE-CODE-SIZE SYSTEM::NEWLINE
-         COMMON-LISP::RENAME-FILE SYSTEM::LIST-TOGGLE-CASE)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
-             COMMON-LISP::*)
-         COMMON-LISP::REDUCE COMMON-LISP::STABLE-SORT
-         SYSTEM::PARSE-BODY SLOOP::FIND-IN-ORDERED-LIST
-         COMMON-LISP::SUBTYPEP COMMON-LISP::SORT)) 
+             ((COMMON-LISP::VECTOR COMMON-LISP::CHARACTER
+                  COMMON-LISP::*)
+              (COMMON-LISP::INTEGER -9223372036854775808
+                  9223372036854775807))
+             COMMON-LISP::FIXNUM)
+         SYSTEM::ATOI)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
-             COMMON-LISP::*)
-         SYSTEM::LIST-MERGE-SORT ANSI-LOOP::LOOP-GET-COLLECTION-INFO
-         SYSTEM::SHARP---READER SYSTEM::SHARP-S-READER
-         SYSTEM::VERIFY-KEYWORDS SYSTEM::RESTART-PRINT
-         SYSTEM::SHARP-+-READER SYSTEM::READ-INSPECT-COMMAND)) 
+         (COMMON-LISP::FUNCTION COMMON-LISP::NIL COMMON-LISP::T)
+         ANSI-LOOP::LOOP-DO-INITIALLY SYSTEM::GET-INDEX-NODE
+         SLOOP::PARSE-ONE-WHEN-CLAUSE SYSTEM::STEP-READ-LINE
+         SYSTEM::DM-TOO-MANY-ARGUMENTS SYSTEM::READ-EVALUATED-FORM
+         SYSTEM::DM-TOO-FEW-ARGUMENTS SYSTEM::KCL-TOP-RESTARTS
+         ANSI-LOOP::LOOP-ITERATION-DRIVER
+         SYSTEM::CURRENT-DIRECTORY-PATHNAME SYSTEM::INSPECT-INDENT
+         SYSTEM::CLEANUP ANSI-LOOP::LOOP-WHEN-IT-VARIABLE
+         SLOOP::PARSE-LOOP-WHEN ANSI-LOOP::LOOP-DO-NAMED
+         ANSI-LOOP::LOOP-GET-FORM SYSTEM::GET-TEMP-DIR
+         SYSTEM::ILLEGAL-BOA SYSTEM::SET-UP-TOP-LEVEL
+         SYSTEM::SETUP-LINEINFO ANSI-LOOP::LOOP-CONTEXT
+         SYSTEM::TOP-LEVEL SYSTEM::DBL SLOOP::LOOP-UN-POP
+         SYSTEM::SET-CURRENT ANSI-LOOP::LOOP-GET-PROGN
+         ANSI-LOOP::LOOP-DO-REPEAT SYSTEM::INIT-BREAK-POINTS
+         SLOOP::PARSE-LOOP-FOR SLOOP::LOOP-POP
+         ANSI-LOOP::LOOP-POP-SOURCE ANSI-LOOP::LOOP-DO-WITH
+         ANSI-LOOP::LOOP-DO-DO COMMON-LISP::LISP-IMPLEMENTATION-VERSION
+         ANSI-LOOP::LOOP-DO-RETURN SLOOP::PARSE-LOOP-DO
+         SLOOP::LOOP-PEEK ANSI-LOOP::LOOP-BIND-BLOCK
+         SYSTEM::DEFAULT-SYSTEM-BANNER SLOOP::PARSE-LOOP1
+         SYSTEM::INSPECT-READ-LINE ANSI-LOOP::LOOP-DO-FINALLY
+         SYSTEM::TEST-ERROR COMMON-LISP::TYPE-ERROR
+         SYSTEM::DEFAULT-INFO-HOTLIST SYSTEM::SHOW-RESTARTS
+         SYSTEM::SET-ENV SLOOP::PARSE-LOOP-COLLECT
+         SYSTEM::ALL-TRACE-DECLARATIONS SYSTEM::GET-SIG-FN-NAME
+         SYSTEM::INSPECT-INDENT-1)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T)
-             COMMON-LISP::*)
-         SYSTEM::PUSH-OPTIONAL-BINDING)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
+             (COMMON-LISP::OR COMMON-LISP::NULL
+                 COMMON-LISP::HASH-TABLE))
+         SYSTEM::CONTEXT-HASH)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T)
-             COMMON-LISP::*)
-         SYSTEM::TRACE-CALL)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
+             COMMON-LISP::FIXNUM)
+         SYSTEM::LENEL SYSTEM::GET-NODE-INDEX SYSTEM::FASLINK
+         SYSTEM::THE-END ANSI-LOOP::DUPLICATABLE-CODE-P
+         SYSTEM::RELATIVE-LINE)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::*)
-             COMMON-LISP::*)
-         SYSTEM::MASET)) 
+             ((COMMON-LISP::INTEGER -9223372036854775808
+                  9223372036854775807))
+             COMMON-LISP::FIXNUM)
+         SYSTEM::DBL-WHAT-FRAME FPE::FE-ENABLE)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::*)
-             COMMON-LISP::*)
-         SYSTEM::EXPAND-WILD-DIRECTORY)) 
+         (COMMON-LISP::FUNCTION COMMON-LISP::NIL COMMON-LISP::*)
+         SYSTEM::GCL-TOP-LEVEL SYSTEM::BREAK-CURRENT
+         SYSTEM::BREAK-RESUME SYSTEM::BREAK-HELP SYSTEM::BREAK-MESSAGE
+         ANSI-LOOP::LOOP-DO-FOR SYSTEM::SIMPLE-BACKTRACE)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
-             COMMON-LISP::*)
-         SYSTEM::PARSE-DEFMACRO SYSTEM::PARSE-DEFMACRO-LAMBDA-LIST)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::*)
+             COMMON-LISP::T)
+         SYSTEM::PROCESS-SOME-ARGS COMMON-LISP::CONCATENATE
+         SYSTEM::TO-REGEXP COMMON-LISP::PATHNAME-DEVICE
+         SYSTEM::LIST-MATCHES ANSI-LOOP::LOOP-WARN
+         COMMON-LISP::REMOVE-DUPLICATES COMMON-LISP::PATHNAME-HOST
+         COMMON-LISP::BIT COMMON-LISP::SBIT
+         COMMON-LISP::ENOUGH-NAMESTRING SYSTEM::DIR-PARSE
+         SYSTEM::FILE-SEARCH SYSTEM::BREAK-LEVEL ANSI-LOOP::LOOP-ERROR
+         SYSTEM::MGLIST COMMON-LISP::PATHNAME-NAME
+         COMMON-LISP::MAKE-STRING-INPUT-STREAM SLOOP::ADD-FROM-DATA
+         COMMON-LISP::TRANSLATE-LOGICAL-PATHNAME COMMON-LISP::DIRECTORY
+         SYSTEM::FILE-TO-STRING COMMON-LISP::ARRAY-ROW-MAJOR-INDEX
+         SYSTEM::NTH-STACK-FRAME SLOOP::LOOP-ADD-TEMPS
+         COMMON-LISP::WARN
+         ANSI-LOOP::LOOP-COLLECT-PREPOSITIONAL-PHRASES
+         SYSTEM::LINK-EXPAND COMMON-LISP::PATHNAME-TYPE
+         COMMON-LISP::OPEN COMMON-LISP::BIT-NOT
+         COMMON-LISP::DELETE-DUPLICATES COMMON-LISP::ERROR
+         COMMON-LISP::FILE-POSITION COMMON-LISP::PATHNAME-VERSION
+         COMMON-LISP::ARRAY-IN-BOUNDS-P COMMON-LISP::REQUIRE
+         SYSTEM::MGSUB COMMON-LISP::MERGE-PATHNAMES COMMON-LISP::LOAD
+         COMMON-LISP::PATHNAME-DIRECTORY COMMON-LISP::SIGNAL
+         COMMON-LISP::WILD-PATHNAME-P COMMON-LISP::FIND-RESTART
+         SYSTEM::INFO-SEARCH SYSTEM::LOGICAL-PATHNAME-PARSE
+         SYSTEM::BAD-SEQ-LIMIT COMMON-LISP::READ-BYTE
+         COMMON-LISP::UPGRADED-ARRAY-ELEMENT-TYPE SYSTEM::NLOAD
+         COMMON-LISP::MAKE-ARRAY)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T)
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
              COMMON-LISP::*)
-         SYSTEM::MME3)) 
+         COMMON-LISP::RENAME-FILE ANSI-LOOP::ESTIMATE-CODE-SIZE-1
+         SYSTEM::FIND-DOC SYSTEM::SOURCE-PORTION SYSTEM::NEWLINE
+         SYSTEM::DO-REPL SYSTEM::RESTART-REPORT
+         ANSI-LOOP::ESTIMATE-CODE-SIZE SYSTEM::NEW-SEMI-COLON-READER)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              ((COMMON-LISP::INTEGER -9223372036854775808
-                  9223372036854775807)
-              COMMON-LISP::T)
+                  9223372036854775807))
              COMMON-LISP::T)
-         SYSTEM::SMALLNTHCDR)) 
+         SYSTEM::GET-CONTEXT SYSTEM::PUSH-CONTEXT)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION COMMON-LISP::NIL COMMON-LISP::*)
-         SYSTEM::GCL-TOP-LEVEL SYSTEM::BREAK-MESSAGE
-         SYSTEM::BREAK-RESUME SYSTEM::SIMPLE-BACKTRACE
-         SYSTEM::BREAK-HELP ANSI-LOOP::LOOP-DO-FOR
-         SYSTEM::BREAK-CURRENT)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::FIXNUM)
-         SYSTEM::S-DATA-LENGTH SYSTEM::THE-START SYSTEM::INSTREAM-LINE
-         SYSTEM::S-DATA-SIZE FPE::REG-LOOKUP)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
+             COMMON-LISP::T)
+         COMMON-LISP::PSETF COMMON-LISP::PROG* SYSTEM::BREAK-STEP-INTO
+         SLOOP::IN-PACKAGE-SLOOP-MAP SLOOP::SLOOP-FINISH
+         SYSTEM::CHECK-SEQ-START-END SLOOP::SLOOP
+         COMMON-LISP::MULTIPLE-VALUE-SETQ COMMON-LISP::ASSERT
+         SLOOP::MINIMIZE-SLOOP-COLLECT COMMON-LISP::ROTATEF
+         SYSTEM::LIST-TOGGLE-CASE SYSTEM::INCREMENT-CURSOR
+         ANSI-LOOP::LOOP-COLLECT-ANSWER COMMON-LISP::PROG2
+         SLOOP::SLOOP-SWAP COMMON-LISP::DEFTYPE
+         SYSTEM::SETF-LOGICAL-PATHNAME-TRANSLATIONS SYSTEM::?PUSH
+         COMMON-LISP::DO-EXTERNAL-SYMBOLS
+         ANSI-LOOP::LOOP-COLLECT-RPLACD COMMON-LISP::TRACE
+         ANSI-LOOP::LOOP-DO-IF ANSI-LOOP::MAKE-LOOP-MINIMAX
+         SYSTEM::SUBSTRINGP COMMON-LISP::LOGORC2
+         ANSI-LOOP::LOOP-DO-WHILE ANSI-LOOP::LOOP-LOOKUP-KEYWORD
+         SLOOP::DEF-LOOP-COLLECT SYSTEM::SETF-HELPER
+         COMMON-LISP::WITH-CONDITION-RESTARTS SYSTEM::INSPECT-PRINT
+         SLOOP::PARSE-LOOP-MAP SYSTEM::KEYWORD-SUPPLIED-P
+         COMMON-LISP::LOOP-FINISH ANSI-LOOP::LOOP-TASSOC
+         SYSTEM::GET-LINE-OF-FORM ANSI-LOOP::LOOP-STORE-TABLE-DATA
+         SLOOP::L-EQUAL COMMON-LISP::ETYPECASE
+         SLOOP::THEREIS-SLOOP-COLLECT COMMON-LISP::RETURN
+         SYSTEM::SUB-INTERVAL-P COMMON-LISP::ECASE
+         COMMON-LISP::WRITE-BYTE SYSTEM::LOOKUP-KEYWORD
+         COMMON-LISP::DEFSETF ANSI-LOOP::LOOP-DO-ALWAYS
+         SYSTEM::PARSE-SLOT-DESCRIPTION COMMON-LISP::VECTOR-PUSH
+         SYSTEM::GET-INFO-CHOICES SYSTEM::SETF-EXPAND
+         SYSTEM::LEFT-PARENTHESIS-READER SLOOP::DEF-LOOP-FOR
+         COMMON-LISP::PROG SYSTEM::OVERWRITE-SLOT-DESCRIPTIONS
+         SYSTEM::SUPER-GO COMMON-LISP::LDB SYSTEM::NODE
+         SYSTEM::COERCE-TO-PACKAGE COMMON-LISP::DO SYSTEM::TP-ERROR
+         SYSTEM::GET-NODES SLOOP::THE-TYPE ANSI-LOOP::LOOP-TMEMBER
+         ANSI-LOOP::LOOP-TEQUAL COMMON-LISP::DEFPARAMETER
+         COMMON-LISP::WITH-OPEN-STREAM SYSTEM::DEFINE-SETF-METHOD
+         SYSTEM::IF-ERROR ANSI-LOOP::HIDE-VARIABLE-REFERENCES
+         SLOOP::DESETQ1 COMMON-LISP::LOOP COMMON-LISP::CTYPECASE
+         COMMON-LISP::DEFSTRUCT COMMON-LISP::CASE SYSTEM::DOT-DIR-P
+         SYSTEM::INSPECT-RECURSIVELY COMMON-LISP::DOTIMES
+         SYSTEM::BREAK-STEP-NEXT SYSTEM::ALL-MATCHES
+         COMMON-LISP::LOCALLY SLOOP::IN-TABLE-SLOOP-MAP
+         SYSTEM::DISPLAY-ENV COMMON-LISP::MULTIPLE-VALUE-LIST
+         COMMON-LISP::LDB-TEST COMMON-LISP::DECLAIM
+         COMMON-LISP::WITH-STANDARD-IO-SYNTAX SYSTEM::SGEN
+         SLOOP::ALWAYS-SLOOP-COLLECT COMMON-LISP::PUSHNEW
+         COMMON-LISP::MULTIPLE-VALUE-BIND FPE::%-READER
+         COMMON-LISP::CCASE SLOOP::DEF-LOOP-MACRO
+         ANSI-LOOP::LOOP-REALLY-DESETQ SYSTEM::IN-INTERVAL-P
+         SYSTEM::DBL-UP SLOOP::DEF-LOOP-MAP ANSI-LOOP::LOOP-BODY
+         SYSTEM::SEQUENCE-CURSOR COMMON-LISP::COERCE
+         COMMON-LISP::PATHNAME-MATCH-P SYSTEM::OBJLT
+         COMMON-LISP::RESTART-CASE
+         COMMON-LISP::WITH-HASH-TABLE-ITERATOR COMMON-LISP::STEP
+         SYSTEM::QUOTATION-READER SYSTEM::PUT-AUX COMMON-LISP::TYPECASE
+         SYSTEM::*BREAK-POINTS* COMMON-LISP::LOGTEST
+         SYSTEM::CONDITION-PASS COMMON-LISP::DEFVAR
+         COMMON-LISP::WITH-OUTPUT-TO-STRING SYSTEM::SET-BACK
+         COMMON-LISP::NTHCDR COMMON-LISP::DO-ALL-SYMBOLS
+         SYSTEM::INFO-AUX COMMON-LISP::LOGANDC1 COMMON-LISP::PROG1
+         FPE::READ-OPERANDS SYSTEM::DISPLAY-COMPILED-ENV
+         COMMON-LISP::DEFCONSTANT SYSTEM::DM-V SLOOP::LOOP-RETURN
+         SYSTEM::ADD-FILE SYSTEM::WHILE SYSTEM::WITHOUT-INTERRUPTS
+         COMMON-LISP::NTH-VALUE COMMON-LISP::OR
+         ANSI-LOOP::LOOP-COPYLIST* SLOOP::IN-CAREFULLY-SLOOP-FOR
+         ANSI-LOOP::LOOP-DECLARE-VARIABLE SYSTEM::GET-MATCH
+         ANSI-LOOP::WITH-LOOP-LIST-COLLECTION-HEAD
+         ANSI-LOOP::LOOP-NOTE-MINIMAX-OPERATION SYSTEM::MV-SETQ
+         SLOOP::COLLATE-SLOOP-COLLECT COMMON-LISP::LOGORC1
+         SYSTEM::DM-NTH-CDR COMPILER::COMPILER-DEF-HOOK
+         SYSTEM::CHECK-TYPE-EVAL COMMON-LISP::DECF
+         COMMON-LISP::WITH-PACKAGE-ITERATOR SYSTEM::COERCE-TO-STRING
+         COMMON-LISP::DEFINE-MODIFY-MACRO FPE::0-READER
+         COMMON-LISP::WITH-COMPILATION-UNIT COMMON-LISP::LOGNAND
+         COMMON-LISP::CHECK-TYPE COMMON-LISP::INCF
+         SLOOP::MAXIMIZE-SLOOP-COLLECT SYSTEM::ITERATE-OVER-BKPTS
+         SLOOP::LOGXOR-SLOOP-COLLECT SLOOP::NEVER-SLOOP-COLLECT
+         SYSTEM::MV-VALUES SYSTEM::MSUB COMMON-LISP::DO*
+         SLOOP::=-SLOOP-FOR COMMON-LISP::UNLESS
+         SYSTEM::MATCH-DIMENSIONS COMMON-LISP::DOLIST
+         ANSI-LOOP::LOOP-MAYBE-BIND-FORM SLOOP::LOCAL-FINISH
+         COMMON-LISP::PSETQ COMMON-LISP::COND
+         COMMON-LISP::WITH-SIMPLE-RESTART COMMON-LISP::DO-SYMBOLS
+         COMMON-LISP::FILE-STRING-LENGTH COMMON-LISP::LAMBDA
+         ANSI-LOOP::LOOP-ACCUMULATE-MINIMAX-VALUE
+         SLOOP::IN-FRINGE-SLOOP-MAP SYSTEM::SET-DIR
+         COMMON-LISP::WITH-INPUT-FROM-STRING SYSTEM::LIST-DELQ
+         COMMON-LISP::BYTE COMMON-LISP::DOCUMENTATION SYSTEM::SAFE-EVAL
+         COMMON-LISP::DEFMACRO SLOOP::DESETQ COMMON-LISP::POP
+         SLOOP::COUNT-SLOOP-COLLECT SLOOP::LCASE
+         COMMON-LISP::DEFPACKAGE COMMON-LISP::DEFUN COMMON-LISP::TIME
+         COMMON-LISP::LOGNOR COMMON-LISP::RESTART-BIND
+         COMMON-LISP::PUSH COMMON-LISP::SHIFTF COMMON-LISP::AND
+         COMMON-LISP::WHEN SYSTEM::DM-NTH COMMON-LISP::WITH-OPEN-FILE
+         SLOOP::MAKE-VALUE COMMON-LISP::UNTRACE FPE::PAREN-READER
+         ANSI-LOOP::WITH-MINIMAX-VALUE COMMON-LISP::NTH
+         FPE::READ-INSTRUCTION SLOOP::SUM-SLOOP-COLLECT
+         COMMON-LISP::REMF COMMON-LISP::DESTRUCTURING-BIND
+         SYSTEM::SET-PATH-STREAM-NAME FPE::RF COMMON-LISP::LOGANDC2)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::FIXNUM) COMMON-LISP::T)
-         SYSTEM::MATCH-BEGINNING SYSTEM::MATCH-END)) 
\ No newline at end of file
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::*)
+             COMMON-LISP::*)
+         COMMON-LISP::FCEILING COMMON-LISP::APROPOS-LIST
+         COMMON-LISP::READ-FROM-STRING
+         COMMON-LISP::ENSURE-DIRECTORIES-EXIST SYSTEM::APROPOS-DOC
+         COMMON-LISP::FTRUNCATE SYSTEM::BREAK-FUNCTION
+         SYSTEM::GET-SETF-METHOD-MULTIPLE-VALUE SYSTEM::STEPPER
+         COMMON-LISP::DECODE-UNIVERSAL-TIME
+         ANSI-LOOP::LOOP-CONSTANT-FOLD-IF-POSSIBLE
+         COMMON-LISP::STORE-VALUE COMMON-LISP::GET-SETF-EXPANSION
+         SYSTEM::PRINT-DOC SYSTEM::INFO COMMON-LISP::APROPOS
+         COMMON-LISP::WRITE-TO-STRING COMMON-LISP::USE-VALUE
+         COMMON-LISP::FROUND COMMON-LISP::PARSE-NAMESTRING
+         COMMON-LISP::INVOKE-RESTART COMMON-LISP::FFLOOR
+         SYSTEM::SHOW-INFO)) 
\ No newline at end of file
--- gcl-2.6.12.orig/o/alloc.c
+++ gcl-2.6.12/o/alloc.c
@@ -182,61 +182,61 @@ void
 add_page_to_freelist(char *p, struct typemanager *tm) {
 
   short t,size;
-  long i=tm->tm_nppage,fw;
-  object x,f;
+  long fw;
+  object x,xe,f;
   struct pageinfo *pp;
 
- t=tm->tm_type;
+  t=tm->tm_type;
 
- size=tm->tm_size;
- f=tm->tm_free;
- pp=pageinfo(p);
- bzero(pp,sizeof(*pp));
- pp->type=t;
- pp->magic=PAGE_MAGIC;
-
- if (cell_list_head==NULL) 
-   cell_list_tail=cell_list_head=pp;
- else if (pp > cell_list_tail) {
-   cell_list_tail->next=pp;
-   cell_list_tail=pp;
- }
-
- x= (object)pagetochar(page(p));
- /* set_type_of(x,t); */
- make_free(x);
+  size=tm->tm_size;
+  pp=pageinfo(p);
+  bzero(pp,sizeof(*pp));
+  pp->type=t;
+  pp->magic=PAGE_MAGIC;
+
+  if (cell_list_head==NULL)
+    cell_list_tail=cell_list_head=pp;
+  else if (pp > cell_list_tail) {
+    cell_list_tail->next=pp;
+    cell_list_tail=pp;
+  }
+
+  x= (object)pagetochar(page(p));
+  /* set_type_of(x,t); */
+  make_free(x);
 
 #ifdef SGC
 
- if (sgc_enabled && tm->tm_sgc)
-   pp->sgc_flags=SGC_PAGE_FLAG;
+  if (sgc_enabled && tm->tm_sgc)
+    pp->sgc_flags=SGC_PAGE_FLAG;
 
 #ifndef SGC_WHOLE_PAGE
- if (TYPEWORD_TYPE_P(pp->type))
-   x->d.s=(sgc_enabled && tm->tm_sgc) ? SGC_RECENT : SGC_NORMAL;
+  if (TYPEWORD_TYPE_P(pp->type))
+    x->d.s=(sgc_enabled && tm->tm_sgc) ? SGC_RECENT : SGC_NORMAL;
 #endif
 
- /* array headers must be always writable, since a write to the
-    body does not touch the header.   It may be desirable if there
-    are many arrays in a system to make the headers not writable,
-    but just SGC_TOUCH the header each time you write to it.   this
-    is what is done with t_structure */
+  /* array headers must be always writable, since a write to the
+     body does not touch the header.   It may be desirable if there
+     are many arrays in a system to make the headers not writable,
+     but just SGC_TOUCH the header each time you write to it.   this
+     is what is done with t_structure */
   if (t==(tm_of(t_array)->tm_type))
     pp->sgc_flags|=SGC_PERM_WRITABLE;
-   
+
 #endif 
 
- fw= *(fixnum *)x;
- while (--i >= 0) {
-   *(fixnum *)x=fw;
-   SET_LINK(x,f);
-   f=x;
-   x= (object) ((char *)x + size);
- }
-
- tm->tm_free=f;
- tm->tm_nfree += tm->tm_nppage;
- tm->tm_npage++;
+  f=FREELIST_TAIL(tm);
+  fw=x->fw;
+  xe=(object)((void *)x+tm->tm_nppage*size);
+  for (;x<xe;f=x,x=(object)((void *)x+size)) {
+    x->fw=fw;
+    SET_LINK(f,x);
+  }
+
+  SET_LINK(f,OBJNULL);
+  tm->tm_tail=f;
+  tm->tm_nfree+=tm->tm_nppage;
+  tm->tm_npage++;
 
 }
 
@@ -1065,15 +1065,13 @@ make_cons(object a,object d) {
 
 }
 
-
-
-object on_stack_cons(object x, object y) {
+object
+on_stack_cons(object x, object y) {
   object p = (object) alloca_val;
   load_cons(p,x,y);
   return p;
 }
 
-
 DEFUNM_NEW("ALLOCATED",object,fSallocated,SI,1,1,NONE,OO,OO,OO,OO,(object typ),"")
 { struct typemanager *tm=(&tm_table[t_from_type(typ)]);
   tm = & tm_table[tm->tm_type];
--- gcl-2.6.12.orig/o/assignment.c
+++ gcl-2.6.12/o/assignment.c
@@ -388,14 +388,7 @@ EVAL:
 
 OTHERWISE:
 	vs_base = vs_top;
-	vs_push(sLsetf);
-	vs_push(place);
-	vs_push(form);
-	result=vs_top[-1];
-	vs_push(Cnil);
-	stack_cons();
-	stack_cons();
-	stack_cons();
+	vs_push(list(3,sLsetf,place,result=form));
 /***/
 #define VS_PUSH_ENV \
 	if(lex_env[1]){ \
@@ -428,9 +421,7 @@ FFN(Fpush)(object form)
 		return;
 	}
 	vs_base = vs_top;
-	vs_push(sLpush);
-	vs_push(form);
-	stack_cons();
+	vs_push(make_cons(sLpush,form));
 /***/
          VS_PUSH_ENV ;
 /***/
@@ -457,9 +448,7 @@ FFN(Fpop)(object form)
 		return;
 	}
 	vs_base = vs_top;
-	vs_push(sLpop);
-	vs_push(form);
-	stack_cons();
+	vs_push(make_cons(sLpop,form));
 /***/
 	VS_PUSH_ENV ;
 /***/
@@ -495,9 +484,7 @@ FFN(Fincf)(object form)
 		return;
 	}
 	vs_base = vs_top;
-	vs_push(sLincf);
-	vs_push(form);
-	stack_cons();
+	vs_push(make_cons(sLincf,form));
 /***/
 	VS_PUSH_ENV ;
 /***/
@@ -533,9 +520,7 @@ FFN(Fdecf)(object form)
 		return;
 	}
 	vs_base = vs_top;
-	vs_push(sLdecf);
-	vs_push(form);
-	stack_cons();
+	vs_push(make_cons(sLdecf,form));
 /***/
 	VS_PUSH_ENV ;
 /***/
--- gcl-2.6.12.orig/o/backq.c
+++ gcl-2.6.12/o/backq.c
@@ -22,7 +22,7 @@ Foundation, 675 Mass Ave, Cambridge, MA
 #include "include.h"
 
 #define	attach(x)	(vs_head = make_cons(x, vs_head))
-#define	make_list	(vs_push(Cnil), stack_cons(), stack_cons())
+#define	make_list	(vs_popp,vs_head=list(2,vs_head,*vs_top))
 
 
 #define	QUOTE	1
--- gcl-2.6.12.orig/o/bind.c
+++ gcl-2.6.12/o/bind.c
@@ -433,10 +433,11 @@ SEARCH_DECLARE:
 					 optional[i].opt_svar_spp);
 		}
 	if (rest_flag) {
-		vs_push(Cnil);
-		for (i = narg, j = nreq+nopt;  --i >= j;  )
-			vs_head = make_cons(base[i], vs_head);
-		bind_var(rest->rest_var, vs_head, rest->rest_spp);
+	  object *l=vs_top++;
+	  for (i=nreq+nopt;i<narg;i++)
+	    collect(l,make_cons(base[i],Cnil));
+	  *l=Cnil;
+	  bind_var(rest->rest_var, vs_head, rest->rest_spp);
 	}
 	if (key_flag) {
                 int allow_other_keys_found=0;
@@ -824,12 +825,11 @@ parse_key(object *base, bool rest, bool
 		}
 	}
 	if (rest) {
-		top = vs_top;
-		vs_push(Cnil);
-		base++;
-		while (base < vs_top)
-			stack_cons();
-		vs_top = top;
+	  object *a,*l;
+	  for (l=a=base;a<vs_top;a++)
+	    collect(l,make_cons(*a,Cnil));
+	  *l=Cnil;
+	  base++;
 	}
 	top = base + n;
 	va_start(ap,n);
--- gcl-2.6.12.orig/o/cfun.c
+++ gcl-2.6.12/o/cfun.c
@@ -217,20 +217,21 @@ DEFUN_NEW("MF",object,fSmf,SI
 static object
 MM(object sym, void (*self)(), char *start, int size, object data)
 {
-	object cf;
+	object sfn;
 
 	if (type_of(sym) != t_symbol)
 		not_a_symbol(sym);
 	if (sym->s.s_sfdef != NOT_SPECIAL && sym->s.s_mflag)
 		sym->s.s_sfdef = NOT_SPECIAL;
-	cf = alloc_object(t_cfun);
-	cf->cf.cf_self = self;
-	cf->cf.cf_name = sym;
-	cf->cf.cf_data = data;
+	sfn = alloc_object(t_sfun);
+	sfn->sfn.sfn_self = (void *)self;/*FIXME*/
+	sfn->sfn.sfn_name = sym;
+	sfn->sfn.sfn_data = data;
+	sfn->sfn.sfn_argd=2;
 	data->cfd.cfd_start=start; 
 	data->cfd.cfd_size=size;
-	sym = 	clear_compiler_properties(sym,cf);
-	sym->s.s_gfdef = cf;
+	sym = 	clear_compiler_properties(sym,sfn);
+	sym->s.s_gfdef = sfn;
 	sym->s.s_mflag = TRUE;
 	return sym;
 }
--- gcl-2.6.12.orig/o/eval.c
+++ gcl-2.6.12/o/eval.c
@@ -60,38 +60,41 @@ object sSAbreak_stepA;
 /* for t_sfun,t_gfun with args on vs stack */
 
 static void
-quick_call_sfun(object fun)
-{ DEBUG_AVMA
+quick_call_sfun(object fun) {
+
+  DEBUG_AVMA
   int i=fun->sfn.sfn_argd,n=SFUN_NARGS(i);
   enum ftype restype;
-  object *x,res,*base;
-  object *temp_ar=alloca(n*sizeof(object));
-/*   i=fun->sfn.sfn_argd; */
-/*   n=SFUN_NARGS(i); */
-  base = vs_base;
-  if (n != vs_top - base)
-    {check_arg_failed(n);}
+  object *x,*base;
+
+  if (n!=vs_top-vs_base)
+    check_arg_failed(n);
+
   restype = SFUN_RETURN_TYPE(i);
   SFUN_START_ARG_TYPES(i);
-  /* for moment just support object and int */
 #define COERCE_ARG(a,type)  (type==f_object ? a : (object)(fix(a)))
-  if (i==0)
-    x=vs_base;
-  else
-    {int j;
-     x=temp_ar;
-     for (j=0; j<n ; j++)
-       {enum ftype typ=SFUN_NEXT_TYPE(i);
-	x[j]=COERCE_ARG(vs_base[j],typ);}}
-  res=c_apply_n_fun(fun,n,x);
-  base[0]=
-    (restype==f_object ?  res :
-     restype==f_fixnum ? make_fixnum((long)res)
-     :(object) (FEerror("Bad result type",0),Cnil));
-  vs_base = base;
-  vs_top=base+1;
+
+  x=vs_base;
+  if (i) {
+    int j;
+    x=alloca(n*sizeof(object));
+    for (j=0;j<n;j++) {
+      enum ftype typ=SFUN_NEXT_TYPE(i);
+      x[j]=COERCE_ARG(vs_base[j],typ);
+    }
+  }
+
+  base=vs_base;
+  *base=c_apply_n_fun(fun,n,x);
+  if (restype==f_fixnum)
+    *base=make_fixnum((fixnum)*base);
+
+  vs_top=(vs_base=base)+1;
+
   CHECK_AVMA;
-  return;}
+  return;
+
+}
 
 /* only for sfun not gfun !!  Does not check number of args */
 static void
@@ -604,27 +607,33 @@ super_funcall(object fun)
 }
 
 void
-super_funcall_no_event(object fun)
-{
+super_funcall_no_event(object fun) {
+
 #ifdef DEBUGGING_AVMA
   funcall_no_event(fun); return;
 #endif 
-   if (type_of(fun)==t_cfun){(*fun->cf.cf_self)();return;}
-   if (type_of(fun)==t_sfun){call_sfun_no_check(fun); return;}
-   if (type_of(fun)==t_gfun)
-       {quick_call_sfun(fun); return;}
-   if (type_of(fun)==t_vfun)
-       {call_vfun(fun); return;}
-   if (type_of(fun) == t_symbol) {
-	  if (fun->s.s_sfdef != NOT_SPECIAL || fun->s.s_mflag)
-			FEinvalid_function(fun);
-		if (fun->s.s_gfdef == OBJNULL)
-			FEundefined_function(fun);
-		fun = fun->s.s_gfdef;
-		if (type_of(fun)==t_cfun){(*fun->cf.cf_self)();
-					  return;}
-	}
-	funcall_no_event(fun);
+
+  switch(type_of(fun)) {
+  case t_cfun:
+    (*fun->cf.cf_self)();
+    return;
+  case t_sfun:
+    call_sfun_no_check(fun); return;
+  case t_gfun:
+    quick_call_sfun(fun); return;
+  case t_vfun:
+    call_vfun(fun); return;
+  case t_symbol:
+    if (fun->s.s_sfdef != NOT_SPECIAL || fun->s.s_mflag)
+      FEinvalid_function(fun);
+    if (fun->s.s_gfdef == OBJNULL)
+      FEundefined_function(fun);
+    super_funcall_no_event(fun->s.s_gfdef);
+    return;
+  default:
+    funcall_no_event(fun);
+  }
+
 }
 
 #ifdef USE_BROKEN_IEVAL
@@ -814,13 +823,7 @@ EVAL:
 		bds_bind(siVevalhook, Cnil);
 		vs_base = vs_top;
 		vs_push(form);
-		vs_push(lex_env[0]);
-		vs_push(lex_env[1]);
-		vs_push(lex_env[2]);
-		vs_push(Cnil);
-		stack_cons();
-		stack_cons();
-		stack_cons();
+		vs_push(list(3,lex_env[0],lex_env[1],lex_env[2]));
 		super_funcall(hookfun);
 		bds_unwind(old_bds_top);
 		return;
@@ -970,22 +973,12 @@ static void
 call_applyhook(object fun)
 {
 	object ah;
-	object *v;
 
 	ah = symbol_value(siVapplyhook);
-	v = vs_base + 1;
-	vs_push(Cnil);
-	while (vs_top > v)
-		stack_cons();
+	Llist();
 	vs_push(vs_base[0]);
 	vs_base[0] = fun;
-	vs_push(lex_env[0]);
-	vs_push(lex_env[1]);
-	vs_push(lex_env[2]);
-	vs_push(Cnil);
-	stack_cons();
-	stack_cons();
-	stack_cons();
+	vs_push(list(3,lex_env[0],lex_env[1],lex_env[2]));
 	super_funcall(ah);
 }
 
--- gcl-2.6.12.orig/o/fasdump.c
+++ gcl-2.6.12/o/fasdump.c
@@ -1130,8 +1130,7 @@ read_fasd1(int i, object *loc)
 	*loc=Cnil;return;
       case DP(d_cons:)
 	read_fasd1(GET_OP(),&tem);
-	*loc=make_cons(tem,Cnil);
-	loc= &((*loc)->c.c_cdr);
+        collect(loc,make_cons(tem,Cnil));
 	i=GET_OP();
 	goto BEGIN;
       case DP(d_list1:) i=1;goto READ_LIST;
@@ -1162,8 +1161,7 @@ read_fasd1(int i, object *loc)
 		read_fasd1(j,&tem);
 		DPRINTF("{Item=",(debug >= 2 ? pp(tem) : 0));
 		DPRINTF("}",0);
-		*loc=make_cons(tem,Cnil);
-		loc= &((*loc)->c.c_cdr);}}
+		collect(loc,make_cons(tem,Cnil));}}
 
       case DP(d_delimiter:)
       case DP(d_dot:)
--- gcl-2.6.12.orig/o/file.d
+++ gcl-2.6.12/o/file.d
@@ -1429,52 +1429,54 @@ LFD(Lmake_synonym_stream)()
 	vs_base[0] = x;
 }
 
-LFD(Lmake_broadcast_stream)()
-{
-	object x;
-	int narg, i;
-
-	narg = vs_top - vs_base;
-	for (i = 0;  i < narg;  i++)
-		if (type_of(vs_base[i]) != t_stream ||
-		    !output_stream_p(vs_base[i]))
-			cannot_write(vs_base[i]);
-	vs_push(Cnil);
-	for (i = narg;  i > 0;  --i)
-		stack_cons();
-	x = alloc_object(t_stream);
-	x->sm.sm_mode = (short)smm_broadcast;
-	x->sm.sm_fp = NULL;
-	x->sm.sm_buffer = 0;
-	x->sm.sm_object0 = vs_base[0];
-	x->sm.sm_object1 = OBJNULL;
-	x->sm.sm_int = 0;
-	x->sm.sm_flags=0;
-	vs_base[0] = x;
+LFD(Lmake_broadcast_stream)() {
+
+  object x;
+  int narg, i;
+  
+  narg = vs_top - vs_base;
+  for (i = 0;  i < narg;  i++)
+    if (type_of(vs_base[i]) != t_stream ||
+	!output_stream_p(vs_base[i]))
+      cannot_write(vs_base[i]);
+
+  Llist();
+
+  x = alloc_object(t_stream);
+  x->sm.sm_mode = (short)smm_broadcast;
+  x->sm.sm_fp = NULL;
+  x->sm.sm_buffer = 0;
+  x->sm.sm_object0 = vs_base[0];
+  x->sm.sm_object1 = OBJNULL;
+  x->sm.sm_int = 0;
+  x->sm.sm_flags=0;
+  vs_base[0] = x;
+
 }
 
-LFD(Lmake_concatenated_stream)()
-{
-	object x;
-	int narg, i;
-
-	narg = vs_top - vs_base;
-	for (i = 0;  i < narg;  i++)
-		if (type_of(vs_base[i]) != t_stream ||
-		    !input_stream_p(vs_base[i]))
-			cannot_read(vs_base[i]);
-	vs_push(Cnil);
-	for (i = narg;  i > 0;  --i)
-		stack_cons();
-	x = alloc_object(t_stream);
-	x->sm.sm_mode = (short)smm_concatenated;
-	x->sm.sm_fp = NULL;
-	x->sm.sm_buffer = 0;
-	x->sm.sm_object0 = vs_base[0];
-	x->sm.sm_object1 = OBJNULL;
-	x->sm.sm_int = 0;
-	x->sm.sm_flags=0;
-	vs_base[0] = x;
+LFD(Lmake_concatenated_stream)() {
+
+  object x;
+  int narg, i;
+  
+  narg = vs_top - vs_base;
+  for (i = 0;  i < narg;  i++)
+    if (type_of(vs_base[i]) != t_stream ||
+	!input_stream_p(vs_base[i]))
+      cannot_read(vs_base[i]);
+
+  Llist();
+
+  x = alloc_object(t_stream);
+  x->sm.sm_mode = (short)smm_concatenated;
+  x->sm.sm_fp = NULL;
+  x->sm.sm_buffer = 0;
+  x->sm.sm_object0 = vs_base[0];
+  x->sm.sm_object1 = OBJNULL;
+  x->sm.sm_int = 0;
+  x->sm.sm_flags=0;
+  vs_base[0] = x;
+
 }
 
 LFD(Lmake_two_way_stream)()
--- gcl-2.6.12.orig/o/gbc.c
+++ gcl-2.6.12/o/gbc.c
@@ -543,7 +543,9 @@ mark_object1(object x) {
 	  mark_object_address(&x->ht.ht_self[i].hte_key,i);
 	  mark_object_address(&x->ht.ht_self[i].hte_value,i+1);
 	}
+    i=x->ht.ht_cache-x->ht.ht_self;
     MARK_LEAF_DATA(x,x->ht.ht_self,x->ht.ht_size*sizeof(*x->ht.ht_self));
+    if (x->ht.ht_cache) x->ht.ht_cache=x->ht.ht_self+i;
     break;
     
   case t_array:
@@ -662,6 +664,7 @@ mark_object1(object x) {
     break;
     
   case t_readtable:
+    mark_object(x->rt.rt_case);
     if (x->rt.rt_self) {
       for (i=0;i<RTABSIZE;i++)
 	mark_object_address(&x->rt.rt_self[i].rte_macro,i);
@@ -968,7 +971,7 @@ sweep_phase(void) {
     tm = tm_of((enum type)v->type);
     
     p = pagetochar(page(v));
-    f = tm->tm_free;
+    f = FREELIST_TAIL(tm);
     k = 0;
     for (j = tm->tm_nppage; j > 0; --j, p += tm->tm_size) {
       x = (object)p;
@@ -979,12 +982,13 @@ sweep_phase(void) {
 	continue;
       }
 
-      SET_LINK(x,f);
+      SET_LINK(f,x);
       make_free(x);
       f = x;
       k++;
     }
-    tm->tm_free = f;
+    SET_LINK(f,OBJNULL);
+    tm->tm_tail = f;
     tm->tm_nfree += k;
     pagetoinfo(page(v))->in_use-=k;
     
--- gcl-2.6.12.orig/o/hash.d
+++ gcl-2.6.12/o/hash.d
@@ -196,33 +196,28 @@ DEFUN_NEW("HASH-EQUAL",object,fShash_equ
 
 
 struct htent *
-gethash(object key, object hashtable) {
+gethash(object key, object ht) {
 
-  enum httest htest;
-  long hsize,j,s,q;
-  struct htent *e,*first_objnull=NULL;
-  object hkey;
+  long s,q;
+  struct htent *e,*ee,*first_open=NULL;
   static struct htent dummy={OBJNULL,OBJNULL};
   
-  if (!hashtable->ht.ht_size)
-    return &dummy;
-
-  htest = (enum httest)hashtable->ht.ht_test;
-  hsize = hashtable->ht.ht_size;
+  if (ht->ht.ht_cache && ht->ht.ht_cache->hte_key==key)
+    return ht->ht.ht_cache;
+  ht->ht.ht_cache=NULL;
 
 #define eq(x,y) x==y
 #define hash_loop(t_,i_)						\
-  for (s=i_%hsize,q=hsize,e=first_objnull;s>=0;q=s,s=s?0:-1)		\
-    for (j=s;j<q;j++) {							\
-      e = &hashtable->ht.ht_self[j];					\
-      hkey = e->hte_key;						\
+  for (q=ht->ht.ht_size,s=i_%q;s>=0;q=s,s=s?0:-1)			\
+    for (e=ht->ht.ht_self,ee=e+q,e+=s;e<ee;e++) {			\
+      object hkey=e->hte_key;						\
       if (hkey==OBJNULL) {						\
-	if (e->hte_value==OBJNULL) return first_objnull ? first_objnull : e; \
-	if (!first_objnull) first_objnull=e;				\
-      } else if (t_(key,hkey)) return e;				\
+	if (e->hte_value==OBJNULL) return first_open ? first_open : e;	\
+	if (!first_open) first_open=e;					\
+      } else if (t_(key,hkey)) return ht->ht.ht_cache=e;		\
     }
 
-  switch (htest) {
+  switch (ht->ht.ht_test) {
   case htt_eq:
     hash_loop(eq,hash_eq(key));
     break;
@@ -237,7 +232,7 @@ gethash(object key, object hashtable) {
     return &dummy;
   }
   
-  return first_objnull ? first_objnull : (FEerror("No free spot in hashtable ~S.", 1, hashtable),&dummy);
+  return first_open ? first_open : (FEerror("No free spot in hashtable ~S.", 1, ht),&dummy);
 
 }
 
@@ -290,7 +285,7 @@ object hashtable;
 	old = alloc_object(t_hashtable);
 	old->ht = hashtable->ht;
 	vs_push(old);
-	hashtable->ht.ht_self = NULL;
+	hashtable->ht.ht_cache=hashtable->ht.ht_self = NULL;
 	hashtable->ht.ht_size = new_size;
 	if (type_of(hashtable->ht.ht_rhthresh) == t_fixnum)
 		hashtable->ht.ht_rhthresh =
@@ -365,6 +360,7 @@ DEFVAR("*DEFAULT-HASH-TABLE-REHASH-THRES
 	h->ht.ht_size = fix(size);
 	h->ht.ht_rhsize = rehash_size;
 	h->ht.ht_rhthresh = rehash_threshold;
+	h->ht.ht_cache=NULL;
         h->ht.ht_nent = 0;
         h->ht.ht_static = static!=Cnil ? 1 : 0;
 	h->ht.ht_self = NULL;
--- gcl-2.6.12.orig/o/list.d
+++ gcl-2.6.12/o/list.d
@@ -277,93 +277,78 @@ object on_stack_list_vector_new(int n,ob
  return ans;
 }*/
 
-object list_vector_new(int n,object first,va_list ap)
-{object ans,*p;
+object
+list_vector_new(int n,object first,va_list ap) {
+
+  object ans,*p;
  
- if (n == 0) return Cnil;
- ans = make_cons(first==OBJNULL ? va_arg(ap,object) : first,Cnil);
- p = & (ans->c.c_cdr); 
- while (--n > 0)
-   { *p = make_cons(va_arg(ap,object),Cnil);
-     p = & ((*p)->c.c_cdr);
-   }
- return ans;}
+  for (p=&ans;n-->0;first=OBJNULL)
+    collect(p,make_cons(first==OBJNULL ? va_arg(ap,object) : first,Cnil));
+  *p=Cnil;
+ return ans;
 
+}
    
-/* clean this up */
-/* static object on_stack_list(int n, ...)
-{va_list ap;
- object res;
- va_start(ap,n);
- res=on_stack_list_vector(n,ap);
- va_end(ap);
- return res;
-}*/
 #ifdef WIDE_CONS
 #define maybe_set_type_of(a,b) set_type_of(a,b)
 #else
 #define maybe_set_type_of(a,b)
 #endif
 
+void
+free_check(void) {
 
+  int n=tm_table[t_cons].tm_nfree,m;
+  object f=tm_table[t_cons].tm_free;
+  for (m=0;f!=OBJNULL;m++,f=OBJ_LINK(f));
+  massert(n==m);
+}
+  
 #define multi_cons(n_,next_,last_)					\
-  ({static struct typemanager *_tm=tm_table+t_cons;			\
-    object _lis=OBJNULL;						\
-									\
-    if (n<=_tm->tm_nfree) {						\
-									\
-      object _tail=_tm->tm_free;					\
-									\
-      _lis=_tail;							\
-      									\
+  ({_tm->tm_nfree -= n_;						\
+    for(_x=_tm->tm_free,_p=&_x;n_-->0;_p=&(*_p)->c.c_cdr) {		\
+      object _z=*_p;							\
+      pageinfo(_z)->in_use++;						\
+      maybe_set_type_of(_z,t_cons);					\
+      _z->c.c_cdr=OBJ_LINK(_z);						\
+      _z->c.c_car=next_;						\
+    }									\
+    _tm->tm_free=*_p;							\
+    *_p=SAFE_CDR(last_);						\
+    _x;})
+
+#define n_cons(n_,next_,last_)						\
+  ({fixnum _n=n_;object _x=Cnil,*_p;					\
+    static struct typemanager *_tm=tm_table+t_cons;			\
+    if (_n>=0) {/*FIXME vs_top<vs_base*/				\
       BEGIN_NO_INTERRUPT;						\
-      									\
-      _tm->tm_nfree -= n_;						\
-      while (--n_) {							\
-	pageinfo(_tail)->in_use++;					\
-	maybe_set_type_of(_tail,t_cons);				\
-	_tail->c.c_cdr=OBJ_LINK(_tail);					\
-	_tail->c.c_car=next_;						\
-	_tail=_tail->c.c_cdr;						\
+      if (_n<=_tm->tm_nfree)						\
+	_x=multi_cons(_n,next_,last_);					\
+      else {								\
+	for (_p=&_x;_n--;)						\
+	  collect(_p,make_cons(next_,Cnil));				\
+	*_p=SAFE_CDR(last_);						\
       }									\
-      _tm->tm_free=OBJ_LINK(_tail);					\
-      pageinfo(_tail)->in_use++;					\
-      maybe_set_type_of(_tail,t_cons);					\
-      _tail->c.c_car=next_;						\
-      _tail->c.c_cdr=SAFE_CDR(last_);					\
-									\
       END_NO_INTERRUPT;							\
     }									\
-    _lis;})
-
-
-   
-object listqA(int a,int n,va_list ap) { 
-
-  object x,*p;
-
-  if (n<=0) return Cnil;
+    _x;})
+      
+object
+n_cons_from_x(fixnum n,object x) {
 
-  if ((x=multi_cons(n,va_arg(ap,object),a ? va_arg(ap,object) : Cnil))!=OBJNULL)
-    return x;
+  return n_cons(n,({object _z=x->c.c_car;x=x->c.c_cdr;_z;}),Cnil);
+  
+}
 
-  CHECK_INTERRUPT;
 
-  p = vs_top;
-  
-  vs_push(Cnil);
-  while(--n>=0) {
-    *p=make_cons(va_arg(ap,object),Cnil);
-    p= &((*p)->c.c_cdr);
-  }
-  if (a) 
-    *p=SAFE_CDR(va_arg(ap,object));
+object
+listqA(int a,int n,va_list ap) {
 
-  return(vs_pop);
+  return n_cons(n,va_arg(ap,object),a ? va_arg(ap,object) : Cnil);
 
 }
 
-object list(int n,...) { 
+object list(fixnum n,...) {
 
   va_list ap;
   object lis;
@@ -375,7 +360,7 @@ object list(int n,...) {
 
 }
 
-object listA(int n,...) { 
+object listA(fixnum n,...) {
 
   va_list ap;
   object lis;
@@ -417,163 +402,63 @@ BEGIN:
 object
 append(object x, object y) {
 
-  object z;
-  fixnum n;
-
-  if (endp(x))
-    return(y);
-
-  for (z=x,n=0;!endp(z);z=z->c.c_cdr,n++);
-  if ((z=multi_cons(n,({object _t=x->c.c_car;x=x->c.c_cdr;_t;}),y))!=OBJNULL)
-    return z;
+  return n_cons(length(x),({object _t=x->c.c_car;x=x->c.c_cdr;_t;}),y);
 
-  z = make_cons(Cnil, Cnil);
-  vs_push(z);
-  for (;;) {
-    z->c.c_car = x->c.c_car;
-    x = x->c.c_cdr;
-    if (endp(x))
-      break;
-    z->c.c_cdr = make_cons(Cnil, Cnil);
-    z = z->c.c_cdr;
-  }
-  z->c.c_cdr = SAFE_CDR(y);
-  return(vs_pop);
 }
 
-
-
-/* object */
-/* append(x, y) */
-/* object x, y; */
-/* { */
-/* 	object z; */
-
-/* 	if (endp(x)) */
-/* 		return(y); */
-/* 	z = make_cons(Cnil, Cnil); */
-/* 	vs_push(z); */
-/* 	for (;;) { */
-/* 		z->c.c_car = x->c.c_car; */
-/* 		x = x->c.c_cdr; */
-/* 		if (endp(x)) */
-/* 			break; */
-/* 		z->c.c_cdr = make_cons(Cnil, Cnil); */
-/* 		z = z->c.c_cdr; */
-/* 	} */
-/* 	z->c.c_cdr = SAFE_CDR(y); */
-/* 	return(vs_pop); */
-/* } */
-
 /*
 	Copy_list(x) copies list x.
 */
 object
-copy_list(x)
-object x;
-{
-	object y;
-
-	if (type_of(x) != t_cons)
-		return(x);
-	y = make_cons(x->c.c_car, Cnil);
-	vs_push(y);
-	for (x = x->c.c_cdr; type_of(x) == t_cons; x = x->c.c_cdr) {
-		y->c.c_cdr = make_cons(x->c.c_car, Cnil);
-		y = y->c.c_cdr;
-	}
-	y->c.c_cdr = SAFE_CDR(x);
-	return(vs_pop);
+copy_list(object x) {
+  object h,y;
+  
+  if (type_of(x) != t_cons)
+    return(x);
+  h=y=make_cons(x->c.c_car, Cnil);
+  for (x = x->c.c_cdr; type_of(x) == t_cons; x = x->c.c_cdr) {
+    y->c.c_cdr = make_cons(x->c.c_car, Cnil);
+    y=y->c.c_cdr;
+  }
+  y->c.c_cdr=SAFE_CDR(x);
+  return(h);
 }
 
 /*
 	Copy_alist(x) copies alist x.
 */
 static object
-copy_alist(x)
-object x;
-{
-	object y;
+copy_alist(object x) {
 
-	if (endp(x))
-		return(Cnil);
-	y = make_cons(Cnil, Cnil);
-	vs_push(y);
-	for (;;) {
-		y->c.c_car = make_cons(car(x->c.c_car), cdr(x->c.c_car));
-		x = x->c.c_cdr;
-		if (endp(x))
-			break;
-		y->c.c_cdr = make_cons(Cnil, Cnil);
-		y = y->c.c_cdr;
-	}
-	return(vs_pop);
+  object h,y;
+  
+  if (endp(x))
+    return(Cnil);
+  h=y=make_cons(Cnil, Cnil);
+  for (;;) {
+    y->c.c_car=make_cons(car(x->c.c_car), cdr(x->c.c_car));
+    x=x->c.c_cdr;
+    if (endp(x))
+      break;
+    y->c.c_cdr=make_cons(Cnil, Cnil);
+    y=y->c.c_cdr;
+  }
+  return(h);
 }
 
-/*
-	Copy_tree(x) copies tree x
-	and pushes the result onto vs.
-*/
-static void
-copy_tree(x)
-object x;
-{
-	cs_check(x);
-
-	if (type_of(x) == t_cons) {
-		copy_tree(x->c.c_car);
-		copy_tree(x->c.c_cdr);
-		stack_cons();
-	} else
-		vs_check_push(x);
-}
-
-/* /\* */
-/* 	Subst(new, tree) pushes */
-/* 	the result of substituting new in tree */
-/* 	onto vs. */
-/* *\/ */
-/* static void */
-/* subst(new, tree) */
-/* object new, tree; */
-/* { */
-/* 	cs_check(new); */
-
-/* 	if (TEST(tree)) */
-/* 		vs_check_push(new); */
-/* 	else if (type_of(tree) == t_cons) { */
-/* 		subst(new, tree->c.c_car); */
-/* 		subst(new, tree->c.c_cdr); */
-/* 		stack_cons(); */
-/* 	} else */
-/* 		vs_check_push(tree); */
-/* } */
-
-/* static object */
-/* subst1(object new, object tree) { */
-
-/*   if (TEST(tree)) */
-/*     return new; */
-/*   else if (type_of(tree) == t_cons) { */
-/*     object oa=tree->c.c_car,a=subst1(new,oa),od=tree->c.c_cdr,d=subst1(new,od); */
-/*     return a==oa && d==od ? tree : make_cons(a,d); */
-/*   } else */
-/*     return tree; */
-
-/* } */
-
-/* static object */
-/* subst1qi(object new, object tree) { */
-
-/*   if (item_compared == tree) */
-/*     return new; */
-/*   else if (type_of(tree) == t_cons) { */
-/*     object oa=tree->c.c_car,a=subst1qi(new,oa),od=tree->c.c_cdr,d=subst1qi(new,od); */
-/*     return a==oa && d==od ? tree : make_cons(a,d); */
-/*   } else */
-/*     return tree; */
+static object
+copy_tree(object x) {
 
-/* } */
+  object y;
+  
+  if (type_of(x) == t_cons) {
+    y=make_cons(Cnil,Cnil);
+    y->c.c_car=copy_tree(x->c.c_car);
+    y->c.c_cdr=copy_tree(x->c.c_cdr);
+    x=y;
+  }
+  return x;
+}
 
 /*
 	Nsubst(new, treep) stores
@@ -599,27 +484,22 @@ object new, *treep;
 	result of substituting tree by alist
 	onto vs.
 */
-static void
-sublis(alist, tree)
-object alist, tree;
-{
-	object x;
-	cs_check(alist);
-
+static object
+sublis(object alist, object tree) {
 
-	for (x = alist;  !endp(x);  x = x->c.c_cdr) {
-		item_compared = car(x->c.c_car);
-		if (TEST(tree)) {
-			vs_check_push(cdr(x->c.c_car));
-			return;
-		}
-	}
-	if (type_of(tree) == t_cons) {
-		sublis(alist, tree->c.c_car);
-		sublis(alist, tree->c.c_cdr);
-		stack_cons();
-	} else
-		vs_check_push(tree);
+  object x;
+  cs_check(alist);
+  
+  for (x=alist;!endp(x);x=x->c.c_cdr) {
+    item_compared=car(x->c.c_car);
+    if (TEST(tree))
+      return x->c.c_car->c.c_cdr;
+  }
+  if (type_of(tree) == t_cons) {
+    object a=sublis(alist,tree->c.c_car),d=sublis(alist,tree->c.c_cdr);
+    return (a==tree->c.c_car && d==tree->c.c_cdr) ? tree : make_cons(a,d);
+  } else
+    return tree;
 }
 
 /*
@@ -777,7 +657,7 @@ DEFUN_NEW("TENTH",object,fLtenth,LISP,1,
 LFD(Lcons)() {
   
   check_arg(2);
-  stack_cons();
+  vs_base[0]=make_cons(vs_base[0],vs_pop);
 
 }
 
@@ -907,36 +787,28 @@ LFD(Llast)() {
 
 }
 
-LFD(Llist)()
-{
-	vs_push(Cnil);
-	while (vs_top > vs_base + 1)
-		stack_cons();
-}
+LFD(Llist)() {
+
+  object *a;
+
+  a=vs_base;
+  vs_base[0]=n_cons(vs_top-vs_base,*a++,Cnil);
+  vs_top=vs_base+1;
 
-LFD(LlistA)()
-{
-	if (vs_top == vs_base)
-		too_few_arguments();
-	while (vs_top > vs_base + 1)
-		stack_cons();
 }
-/* static object copy_off_stack_tree(x) */
-/* object x; */
-/* {object *p; */
-/*  p = &x; */
-/*  TOP: */
-/*  if (type_of(*p) ==t_cons) */
-/*    { if(!inheap(*p)) */
-/*        *p=make_cons(copy_off_stack_tree((*p)->c.c_car),(*p)->c.c_cdr); */
-/*    else */
-/*      (*p)->c.c_car = copy_off_stack_tree((*p)->c.c_car); */
-/*      p = &((*p)->c.c_cdr); */
-/*      goto TOP;} */
-/*  return x; */
-/* } */
 
-        
+LFD(LlistA)() {
+
+  object *a;
+
+  if (vs_top == vs_base)
+    too_few_arguments();
+
+  a=vs_base;
+  vs_base[0]=n_cons(vs_top-vs_base-1,*a++,vs_head);
+  vs_top=vs_base+1;
+
+}
  
 object on_stack_make_list(n)
 int n;
@@ -957,23 +829,20 @@ int n;
  goto TOP;
 }
 
-object make_list(n)
-int n;
-{object x =Cnil ;
-  while (n-- > 0)
-    x = make_cons(Cnil, x);
- return x;}
+object
+make_list(int n) {
+
+  return n_cons(n,Cnil,Cnil);
+
+}
 
 @(defun make_list (size &key initial_element &aux x)
-	int i;
 @
-	check_type_non_negative_integer(&size);
-	if (type_of(size) != t_fixnum)
-		FEerror("Cannot make a list of the size ~D.", 1, size);
-	i = fix(size);
-	while (i-- > 0)
-		x = make_cons(initial_element, x);
-	@(return x)
+  check_type_non_negative_integer(&size);
+  if (type_of(size) != t_fixnum)
+    FEerror("Cannot make a list of the size ~D.", 1, size);
+  x=n_cons(fix(size),initial_element,Cnil);
+  @(return x)
 @)
 
 LFD(Lappend)()
@@ -1006,22 +875,19 @@ LFD(Lcopy_alist)()
 LFD(Lcopy_tree)()
 {
 	check_arg(1);
-	copy_tree(vs_base[0]);
-	vs_base[0] = vs_pop;
+	vs_base[0]=copy_tree(vs_base[0]);
 }
 
 LFD(Lrevappend)() {
-	object x, y;
 
-	check_arg(2);
-	y = vs_pop;
-	for (x = vs_base[0];  !endp(x);  x = x->c.c_cdr) {
-		vs_push(x->c.c_car);
-		vs_push(y);
-		stack_cons();
-		y = vs_pop;
-	}
-	vs_base[0] = y;
+  object x, y;
+
+  check_arg(2);
+  y=vs_pop;
+  for (x=vs_base[0];!endp(x);x=x->c.c_cdr)
+    y=make_cons(x->c.c_car,y);
+  vs_base[0] = y;
+
 }
 
 object
@@ -1078,26 +944,19 @@ LFD(Lreconc)() {
 }
 
 @(defun butlast (lis &optional (nn `make_fixnum(1)`))
-	int i;
+  int i;
+  object *p,x,y,z;
 @
-	check_type_non_negative_integer(&nn);
-	if (!listp(lis))/*FIXME checktype*/
-	  FEwrong_type_argument(sLlist, lis);
-	if (type_of(nn) != t_fixnum)
-		@(return Cnil)
-	for (i = 0;  consp(lis);  i++, lis = lis->c.c_cdr)
-		vs_check_push(lis->c.c_car);
-	if (i <= fix((nn))) {
-		vs_top -= i;
-		@(return Cnil)
-	}
-	vs_top -= fix((nn));
-	i -= fix((nn));
-	vs_push(Cnil);
-	while (i-- > 0)
-		stack_cons();
-	lis = vs_pop;
-	@(return lis)
+  check_type_non_negative_integer(&nn);
+  if (!listp(lis))/*FIXME checktype*/
+    FEwrong_type_argument(sLlist, lis);
+  if (type_of(nn) != t_fixnum)
+    @(return Cnil)
+      for (x=y=lis,i=0;i<fix(nn) && consp(y);i++,y=y->c.c_cdr);
+  for (p=&z;consp(y);x=x->c.c_cdr,y=y->c.c_cdr)
+    collect(p,make_cons(x->c.c_car,Cnil));
+  *p=i ? Cnil : x;
+  @(return `z`)
 @)
 
 @(defun nbutlast (lis &optional (nn `make_fixnum(1)`))
@@ -1119,21 +978,20 @@ LFD(Lreconc)() {
 @)
 
 LFD(Lldiff)() {
-	fixnum i;
-	object x;
 
-	check_arg(2);
-	x = vs_base[0];
-	if (!listp(x))/*FIXME checktype*/
-	  FEwrong_type_argument(sLlist, x);
-	for (i = 0; consp(x) && x!=vs_base[1] ;  i++, x = x->c.c_cdr)
-	  vs_check_push(x->c.c_car); /*FIXME but a segfault breaker at vs_limit*/
-	x=eql(x,vs_base[1]) ? Cnil : x;
-	vs_check_push(x);
-	while (i-- > 0)
-	  stack_cons();
-	vs_base[0] = vs_pop;
-	vs_popp;
+  fixnum i;
+  object x,y,*p,z;
+
+  check_arg(2);
+  x=vs_base[0];
+  z=vs_pop;
+  if (!listp(x))/*FIXME checktype*/
+    FEwrong_type_argument(sLlist, x);
+  for (p=&y,i=0;consp(x) && x!=z;i++,x=x->c.c_cdr)
+    collect(p,make_cons(x->c.c_car,Cnil));
+  *p=eql(x,z) ? Cnil : x;
+  vs_base[0]=y;
+
 }
 
 LFD(Lrplaca)()
@@ -1187,18 +1045,15 @@ LFD(Lrplacd)()
 PREDICATE(Lnsubst,Lnsubst_if,Lnsubst_if_not, 3)
 
 object
-sublis1(alist,tree,tst)
-     object alist,tree;
-     bool (*tst)();
-{object v;
- for (v=alist ; v!=Cnil; v=v->c.c_cdr)
-   { if ((*tst)(v->c.c_car->c.c_car ,tree))
-       return(v->c.c_car->c.c_cdr);}
- if (type_of(tree)==t_cons)
-   {object ntree=make_cons(sublis1(alist,tree->c.c_car,tst),
-			   tree->c.c_cdr);
-    ntree->c.c_cdr=sublis1(alist,ntree->c.c_cdr,tst);
-    return ntree;
+sublis1(object alist,object tree,bool (*tst)()) {
+
+  object v;
+  for (v=alist;v!=Cnil;v=v->c.c_cdr) {
+    if ((*tst)(v->c.c_car->c.c_car,tree))
+      return(v->c.c_car->c.c_cdr);}
+  if (type_of(tree)==t_cons){
+    object a=sublis1(alist,tree->c.c_car,tst),d=sublis1(alist,tree->c.c_cdr,tst);
+    return a==tree->c.c_car && d==tree->c.c_cdr ? tree : make_cons(a,d);
   }
   return tree;
 }
@@ -1226,8 +1081,7 @@ check_alist(alist)
 @  
 	protectTEST;
 	setupTEST(Cnil, test, test_not, key);
-	sublis(alist, tree);
-	tree = vs_pop;
+	tree=sublis(alist,tree);
 	restoreTEST;
 	@(return tree)
 @)
@@ -1321,27 +1175,25 @@ LFD(Lacons)()
 }
 
 @(defun pairlis (keys data &optional a_list)
-	object *vp, k, d;
+  object k,d,y,z,*p;
 @
-	vp = vs_top + 1;
-	k = keys;
-	d = data;
-	while (!endp(k)) {
-		if (endp(d))
-		 FEerror(
-		  "The keys ~S and the data ~S are not of the same length",
-		  2, keys, data);
-		vs_check_push(make_cons(k->c.c_car, d->c.c_car));
-		k = k->c.c_cdr;
-		d = d->c.c_cdr;
-	}
-	if (!endp(d))
-	    FEerror("The keys ~S and the data ~S are not of the same length",
-		    2, keys, data);
-	vs_push(a_list);
-	while (vs_top > vp)
-		stack_cons();
-	@(return `vp[-1]`)
+  k=keys;
+  d=data;
+  p=&y;
+  while (!endp(k)) {
+    if (endp(d))
+      FEerror("The keys ~S and the data ~S are not of the same length",2,keys,data);
+    z=make_cons(Cnil,Cnil);
+    z->c.c_car=make_cons(k->c.c_car,d->c.c_car);
+    collect(p,z);
+    k = k->c.c_cdr;
+    d = d->c.c_cdr;
+  }
+  if (!endp(d))
+    FEerror("The keys ~S and the data ~S are not of the same length",2,keys,data);
+  *p=a_list;
+  vs_top=vs_base+1;
+  @(return `y`)
 @)
 
 @(static defun assoc_or_rassoc (item a_list &key test test_not key)
--- gcl-2.6.12.orig/o/makefile
+++ gcl-2.6.12/o/makefile
@@ -91,8 +91,8 @@ $(DECL): $(HDIR)/make-decl.h $(INI_FILES
 grab_defs: grab_defs.c
 	${CC} $(OFLAGS) -o grab_defs  grab_defs.c
 
-wpool: wpool.c
-	$(CC) $(CFLAGS) $(DEFS) -o $@ $<
+wpool: wpool.o
+	$(CC) $(LDFLAGS) -o $@ $<
 
 $(GCLIB): ${ALIB} 
 	rm -f gcllib.a
--- gcl-2.6.12.orig/o/makefun.c
+++ gcl-2.6.12/o/makefun.c
@@ -6,12 +6,20 @@
 MakeAfun(addr,F_ARGD(min,max,flags,ARGTYPES(a,b,c,d)),0);
 MakeAfun(addr,F_ARGD(2,3,NONE,ARGTYPES(OO,OO,OO,OO)),0);
 */
+
+static int mv;
+
 object MakeAfun(object (*addr)(object,object), unsigned int argd, object data)
-{int type = (F_ARG_FLAGS_P(argd,F_requires_fun_passed) ? t_closure : t_afun);
+{
+  ufixnum at=F_TYPES(argd)>>F_TYPE_WIDTH;
+  ufixnum ma=F_MIN_ARGS(argd);
+  ufixnum xa=F_MAX_ARGS(argd);
+  ufixnum rt=F_RESULT_TYPE(argd);
+  int type = (F_ARG_FLAGS_P(argd,F_requires_fun_passed) ? t_closure : (!at&&!rt&&ma==xa&&!mv ? t_sfun : t_afun));
   object x = alloc_object(type);
   x->sfn.sfn_name = Cnil;
   x->sfn.sfn_self = addr;
-  x->sfn.sfn_argd = argd;
+  x->sfn.sfn_argd = type==t_sfun ? ma : argd;
   if (type == t_closure)
     { x->cl.cl_env = 0;
       x->cl.cl_envdim=0;}
@@ -107,7 +115,7 @@ DEFUN_NEW("SET-KEY-STRUCT",object,fSset_
 }
      
 
-#define collect(top_,next_,val_) ({object _x=MMcons(val_,Cnil);\
+#define mcollect(top_,next_,val_) ({object _x=MMcons(val_,Cnil);\
                                    if (top_==Cnil) top_=next_=_x; \
                                    else next_=next_->c.c_cdr=_x;})
 
@@ -125,23 +133,23 @@ put_fn_procls(object sym,fixnum argd,fix
   for (i=0;i<minargs;i++,atypes >>=F_TYPE_WIDTH) 
     switch(maxargs!=minargs ? F_object : atypes & MASK_RANGE(0,F_TYPE_WIDTH)) {
     case F_object:
-      collect(ta,na,def);
+      mcollect(ta,na,def);
       break;
     case F_int:
-      collect(ta,na,sLfixnum);
+      mcollect(ta,na,sLfixnum);
       break;
     case F_shortfloat:
-      collect(ta,na,sLshort_float);
+      mcollect(ta,na,sLshort_float);
       break;
     case F_double_ptr:
-      collect(ta,na,sLlong_float);
+      mcollect(ta,na,sLlong_float);
       break;
     default:
       FEerror("Bad sfn declaration",0);
       break;
     }
   if (maxargs!=minargs)
-    collect(ta,na,sLA);
+    mcollect(ta,na,sLA);
   putprop(sym,ta,sSproclaimed_arg_types);
   ta=na=Cnil;
   if (oneval) 
@@ -188,15 +196,19 @@ LISP_makefun(char *strg, void *fn, unsig
 void
 SI_makefunm(char *strg, void *fn, unsigned int argd)
 { object sym = make_si_ordinary(strg);
- fSfset(sym, fSmakefun(sym,fn,argd));
- put_fn_procls(sym,argd,0,Ct,Ct);
+  mv=1;
+  fSfset(sym, fSmakefun(sym,fn,argd));
+  mv=0;
+  put_fn_procls(sym,argd,0,Ct,Ct);
 }
 
 void
 LISP_makefunm(char *strg, void *fn, unsigned int argd)
 { object sym = make_ordinary(strg);
- fSfset(sym, fSmakefun(sym,fn,argd));
- put_fn_procls(sym,argd,0,Ct,Ct);
+  mv=1;
+  fSfset(sym, fSmakefun(sym,fn,argd));
+  mv=0;
+  put_fn_procls(sym,argd,0,Ct,Ct);
 }
 
 
--- gcl-2.6.12.orig/o/package.d
+++ gcl-2.6.12/o/package.d
@@ -849,17 +849,19 @@ FFN(Lpackage_shadowing_symbols)()
 	vs_base[0] = vs_base[0]->p.p_shadowings;
 }
 
-LFD(Llist_all_packages)()
-{
-	struct package *p;
-	int i;
+LFD(Llist_all_packages)() {
+
+  struct package *p;
+  object x,*l;
+  int i;
+  
+  check_arg(0);
+
+  for (l=&x,p=pack_pointer,i=0;p!=NULL;p=p->p_link,i++)
+    collect(l,make_cons((object)p,Cnil));
+  *l=Cnil;
+  vs_push(x);
 
-	check_arg(0);
-	for (p = pack_pointer, i = 0;  p != NULL;  p = p->p_link, i++)
-		vs_push((object)p);
-	vs_push(Cnil);
-	while (i-- > 0)
-		stack_cons();
 }
 
 @(defun intern (strng &optional (p `current_package()`) &aux sym)
--- gcl-2.6.12.orig/o/predicate.c
+++ gcl-2.6.12/o/predicate.c
@@ -425,7 +425,7 @@ eql1(register object x,register object y
 
   /*x and y are not == and not Cnil and not immfix*/
 
-  if (valid_cdr(x)||valid_cdr(y)||x->d.t!=y->d.t) return FALSE;
+  /* if (valid_cdr(x)||valid_cdr(y)||x->d.t!=y->d.t) return FALSE; */
   
   switch (x->d.t) {
 
--- gcl-2.6.12.orig/o/print.d
+++ gcl-2.6.12/o/print.d
@@ -41,6 +41,8 @@ int  line_length = 72;
 	 isLower((c)&0377) || (c) == ':')
 
 
+#define READ_TABLE_CASE (Vreadtable->s.s_dbind->rt.rt_case)
+
 #define	mod(x)		((x)%Q_SIZE)
 
 
@@ -619,13 +621,113 @@ object coerce_big_to_string(object,int);
 static bool
 potential_number_p(object,int);
 
+#define CASE_OF(x_) ({int _x=(x_);isUpper(_x) ? 1 : (isLower(_x) ? -1 : 0);})
+
+static int
+constant_case(object x) {
+
+  fixnum i,j,jj;
+
+  for (i=j=0;i<x->s.s_fillp;i++,j=j ? j : jj)
+    if (j*(jj=CASE_OF(x->s.s_self[i]))==-1)
+      return 0;
+
+  return j;
+
+}
+
+static int
+all_dots(object x) {
+
+  fixnum i;
+
+  for (i=0;i<x->s.s_fillp;i++)
+    if (x->s.s_self[i]!='.')
+      return 0;
+
+  return 1;
+
+}
+
+static int
+needs_escape (object x,int pp) {
+
+  fixnum i;
+  char ch;
+
+  if (!PRINTescape)
+    return 0;
+
+  for (i=0;i<x->s.s_fillp;i++)
+    switch((ch=x->s.s_self[i])) {
+    case '(':
+    case ')':
+    case ':':
+    case '`':
+    case '\'':
+    case '"':
+    case ';':
+    case ',':
+    case '\n':
+      return 1;
+    case ' ':
+      if (!i) return 1;
+    default:
+      if ((READ_TABLE_CASE==sKupcase   && isLower(ch)) ||
+	  (READ_TABLE_CASE==sKdowncase && isUpper(ch)))
+	return 1;
+    }
+
+  if (pp)
+    if (potential_number_p(x, PRINTbase) || all_dots(x))
+      return 1;
+
+  return !x->s.s_fillp;
+
+}
+
+#define convertible_upper(c) ((READ_TABLE_CASE==sKupcase  ||READ_TABLE_CASE==sKinvert)&& isUpper(c))
+#define convertible_lower(c) ((READ_TABLE_CASE==sKdowncase||READ_TABLE_CASE==sKinvert)&& isLower(c))
+
+static void
+print_symbol_name_body(object x,int pp) {
+
+  int i,j,fc,tc,lw,k,cc;
+
+  cc=constant_case(x);
+  k=needs_escape(x,pp);
+
+  if (k)
+    write_ch('|');
+
+  for (lw=i=0;i<x->s.s_fillp;i++) {
+    j = x->s.s_self[i];
+    if (PRINTescape && (j == '|' || j == '\\'))
+      write_ch('\\');
+    fc=convertible_upper(j) ? 1 :
+        (convertible_lower(j) ? -1 : 0);
+    tc=(READ_TABLE_CASE==sKinvert ? -cc :
+	 (PRINTcase == sKupcase ? 1 :
+	  (PRINTcase == sKdowncase ? -1 :
+	   (PRINTcase == sKcapitalize ? (i==lw ? 1 : -1) : 0))));
+    if (ispunct(j)||isspace(j)) lw=i+1;
+    j+=(tc*fc && !k ? (tc-fc)>>1 : 0)*('A'-'a');
+    write_ch(j);
+
+  }
+
+  if (k)
+    write_ch('|');
+
+}
+
 void
 write_object(x, level)
 object x;
 int level;
 {
 	object r, y;
-	int i, j, k,lw;
+	int i, j, k;
 	object *vp;
 
 	cs_check(x);
@@ -797,117 +899,49 @@ int level;
 		break;
 
 	case t_symbol:
-		if (!PRINTescape) {
-			for (lw = 0,i = 0;  i < x->s.s_fillp;  i++) {
-				j = x->s.s_self[i];
-				if (isUpper(j)) {
-                                    if (PRINTcase == sKdowncase ||
-                                        (PRINTcase == sKcapitalize && i!=lw))
-                                          j += 'a' - 'A';
-                                 } else if (!isLower(j))
-                                         lw = i + 1;
-                                  write_ch(j);
+	  {
 
-			}
-			break;
-		}
-		if (x->s.s_hpack == Cnil) {
-		    if (PRINTcircle) {
-			for (vp = PRINTvs_top;  vp < PRINTvs_limit;  vp += 2)
-			    if (x == *vp) {
-				if (vp[1] != Cnil) {
-				    write_ch('#');
-				    write_decimal((vp-PRINTvs_top)/2);
-				    write_ch('#');
-				    return;
-				} else {
-				    write_ch('#');
-				    write_decimal((vp-PRINTvs_top)/2);
-				    write_ch('=');
-				    vp[1] = Ct;
-				}
-			    }
+	    if (PRINTescape) {
+	      if (x->s.s_hpack == Cnil) {
+		if (PRINTcircle) {
+		  for (vp = PRINTvs_top;  vp < PRINTvs_limit;  vp += 2)
+		    if (x == *vp) {
+		      if (vp[1] != Cnil) {
+			write_ch('#');
+			write_decimal((vp-PRINTvs_top)/2+1);
+			write_ch('#');
+			return;
+		      } else {
+			write_ch('#');
+			write_decimal((vp-PRINTvs_top)/2+1);
+			write_ch('=');
+			vp[1] = Ct;
+		      }
 		    }
-		    if (PRINTgensym)
-			write_str("#:");
-		} else if (x->s.s_hpack == keyword_package)
-			write_ch(':');
-		else if (PRINTpackage||find_symbol(x,current_package())!=x
-			 || intern_flag == 0)
-		  {
-			k = 0;
-			for (i = 0;
-			     i < x->s.s_hpack->p.p_name->st.st_fillp;
-			     i++) {
-				j = x->s.s_hpack->p.p_name
-				    ->st.st_self[i];
-				if (to_be_escaped(j))
-					k++;
-			}
-			if (k > 0)
-				write_ch('|');
-		     for (lw = 0, i = 0;	
-			     i < x->s.s_hpack->p.p_name->st.st_fillp;
-			     i++) {
-				j = x->s.s_hpack->p.p_name
-				    ->st.st_self[i];
- 				if (j == '|' || j == '\\')
-					write_ch('\\');
-                                 if (k == 0) {
-                                         if (isUpper(j)) {
-                                                 if (PRINTcase == sKdowncase ||
-                                                     (PRINTcase == sKcapitalize && i!=lw))
-                                                 j += 'a' - 'A';
-                                         } else if (!isLower(j))
-                                                 lw = i + 1;
-                                 }
-				write_ch(j);
-			}
-			if (k > 0)
-				write_ch('|');
-			if (find_symbol(x, x->s.s_hpack) != x)
-				error("can't print symbol");
-			if (PRINTpackage || intern_flag == INTERNAL)
-				write_str("::");
-			else if (intern_flag == EXTERNAL)
-				write_ch(':');
-			else
-			FEerror("Pathological symbol --- cannot print.", 0);
 		}
-		k = 0;
-		if (potential_number_p(x, PRINTbase))
-			k++;
-		for (i = 0;  i < x->s.s_fillp;  i++) {
-			j = x->s.s_self[i];
-			if (to_be_escaped(j))
-				k++;
-		}
-		for (i = 0;  i < x->s.s_fillp;  i++)
-			if (x->s.s_self[i] != '.')
-				goto NOT_DOT;
-		k++;
-
-	NOT_DOT:			
-		if (k > 0)
-			write_ch('|');
-                 for (lw = 0, i = 0;  i < x->s.s_fillp;  i++) {
-			j = x->s.s_self[i];
- 			if (j == '|' || j == '\\')
-				write_ch('\\');
-                         if (k == 0) {
-                                 if (isUpper(j)) {
-                                         if (PRINTcase == sKdowncase ||
-                                             (PRINTcase == sKcapitalize && i != lw))
-                                             j += 'a' - 'A';
-                                 } else if (!isLower(j))
-                                         lw = i + 1;
-                         }
-			write_ch(j);
-		}
-		if (k > 0)
-			write_ch('|');
-		break;
+		if (PRINTgensym)
+		  write_str("#:");
+	      } else if (x->s.s_hpack == keyword_package) {
+		write_ch(':');
+	      } else if (PRINTpackage||find_symbol(x,current_package())!=x || !intern_flag) {
+
+		print_symbol_name_body(x->s.s_hpack->p.p_name,0);
+
+		if (find_symbol(x, x->s.s_hpack) != x)
+		  error("can't print symbol");
+		if (PRINTpackage || intern_flag == INTERNAL)
+		  write_str("::");
+		else if (intern_flag == EXTERNAL)
+		  write_ch(':');
+		else
+		  FEerror("Pathological symbol --- cannot print.", 0);
+
+	      }
 
+	    }
+	    print_symbol_name_body(x,1);
+	    break;
+	  }
 	case t_array:
 	{
 		int subscripts[ARANKLIM];
--- gcl-2.6.12.orig/o/read.d
+++ gcl-2.6.12/o/read.d
@@ -695,10 +695,29 @@ BEGIN:
 		    goto K;
 		  else
 		    break;
-		}
-		else if ('a' <= char_code(c) && char_code(c) <= 'z')
-			c = code_char(char_code(c) - ('a' - 'A'));
-		else if (char_code(c) == ':') {
+		} else {
+
+		  switch(char_code(c)) {
+		  case '\b':
+		  case '\t':
+		  case '\n':
+		  case '\r':
+		  case '\f':
+		  case ' ':
+		  case '\177':
+		    READER_ERROR(in,"Cannot read character");
+		  default:
+		    break;
+		  }
+
+		  if ('a' <= char_code(c) && char_code(c) <= 'z') {
+		    if ('a' <= char_code(c) && char_code(c) <= 'z' &&
+			(READtable->rt.rt_case==sKupcase || READtable->rt.rt_case==sKinvert))
+		      c = code_char(char_code(c) - ('a' - 'A'));
+		    else if ('A' <= char_code(c) && char_code(c) <= 'Z' &&
+			     (READtable->rt.rt_case==sKdowncase || READtable->rt.rt_case==sKinvert))
+		      c = code_char(char_code(c) + ('a' - 'A'));
+		  } else if (char_code(c) == ':') {
 			if (colon_type == 0) {
 				colon_type = 1;
 				colon = length;
@@ -707,6 +726,7 @@ BEGIN:
 			else
 				colon_type = -1;
 				/*  Colon has appeared twice.  */
+		  }
 		}
         }
 	if (preserving_whitespace_flag || cat(c) != cat_whitespace)
@@ -807,46 +827,49 @@ SYMBOL:
 }
 
 static void
-Lleft_parenthesis_reader()
-{
-	object in, x;
-	object *p;
+Lleft_parenthesis_reader() {
 
-	check_arg(2);
-	in = vs_base[0];
-	vs_head = Cnil;
-	p = &vs_head;
-	for (;;) {
-		delimiting_char = code_char(')');
-		in_list_flag = TRUE;
-		x = read_object(in);
-		if (x == OBJNULL)
-			goto ENDUP;
-		if (dot_flag) {
-			if (p == &vs_head)
-	FEerror("A dot appeared after a left parenthesis.", 0);
-			delimiting_char = code_char(')');
-			in_list_flag = TRUE;
-			*p = SAFE_CDR(read_object(in));
-			if (dot_flag)
-	FEerror("Two dots appeared consecutively.", 0);
-			if (*p==OBJNULL)
-	FEerror("Object missing after dot.", 0);
-			delimiting_char = code_char(')');
-			in_list_flag = TRUE;
-			if (read_object(in)!=OBJNULL)
-        FEerror("Two objects after dot.",0);
-			goto ENDUP;
-		}
-		vs_push(x);
-		*p = make_cons(x, Cnil);
-		vs_popp;
-		p = &((*p)->c.c_cdr);
-	}
+  object in, x;
+  object *p;
+  
+  check_arg(2);
+  in = vs_base[0];
+  vs_top=vs_base+1;
+  p = &vs_head;
+
+  for (;;) {
+
+    delimiting_char = code_char(')');
+    in_list_flag = TRUE;
+
+    if ((x=read_object(in))==OBJNULL) {
+      *p=Cnil;
+      break;
+    }
+
+    if (dot_flag) {
+
+      if (p==&vs_head) READER_ERROR(in,"A dot appeared after a left parenthesis.");
+
+      delimiting_char = code_char(')');
+      in_list_flag = TRUE;
+      *p=SAFE_CDR(read_object(in));
+
+      if (dot_flag) READER_ERROR(in,"Two dots appeared consecutively.");
+      if (*p==OBJNULL) READER_ERROR(in,"Object missing after dot.");
+
+      delimiting_char = code_char(')');
+      in_list_flag = TRUE;
+      if (read_object(in)!=OBJNULL) READER_ERROR(in,"Two objects after dot.");
+
+      break;
+
+    }
+
+    collect(p,make_cons(x,Cnil));
+
+  }
 
-ENDUP:
-	vs_base[0] = vs_pop;
-	return;
 }
 
 
@@ -959,13 +982,8 @@ static void
 Lsingle_quote_reader()
 {
 	check_arg(2);
-	vs_popp;
-	vs_push(sLquote);
-	vs_push(read_object(vs_base[0]));
-	vs_push(Cnil);
-	stack_cons();
-	stack_cons();
-	vs_base[0] = vs_pop;
+	vs_base[0] = list(2,sLquote,read_object(vs_base[0]));
+	vs_top=vs_base+1;
 }
 
 static void
@@ -1111,14 +1129,8 @@ Lsharp_single_quote_reader()
 	check_arg(3);
 	if(vs_base[2] != Cnil && !READsuppress)
 		extra_argument('#');
-	vs_popp;
-	vs_popp;
-	vs_push(sLfunction);
-	vs_push(read_object(vs_base[0]));
-	vs_push(Cnil);
-	stack_cons();
-	stack_cons();
-	vs_base[0] = vs_pop;
+	vs_base[0] = list(2,sLfunction,read_object(vs_base[0]));
+	vs_top=vs_base+1;
 }
 
 #define	QUOTE	1
@@ -1163,20 +1175,7 @@ Lsharp_left_parenthesis_reader()
 			}	
 			goto L;
 		}
-		vs_push(siScomma);
-		vs_push(sLapply);
-		vs_push(sLquote);
-		vs_push(sLvector);
-		vs_push(Cnil);
-		stack_cons();
-		stack_cons();
-		vs_push(vs_base[2]);
-		vs_push(Cnil);
-		stack_cons();
-		stack_cons();
-		stack_cons();
-		stack_cons();
-		vs_base = vs_top - 1;
+		vs_base[0]=list(4,siScomma,sLapply,list(2,sLquote,sLvector),vs_base[2]);
 		return;
 	}
 	vsp = vs_top;
@@ -1633,6 +1632,7 @@ object from, to;
 				rtab[i].rte_dtab[j]
 				= from->rt.rt_self[i].rte_dtab[j];
 		}
+	to->rt.rt_case=from->rt.rt_case;
 	vs_reset;
 	END_NO_INTERRUPT;}
 	return(to);
@@ -1758,8 +1758,7 @@ READ:
 		x = read_object_recursive(strm);
 		if (x == OBJNULL)
 			break;
-		*p = make_cons(x, Cnil);
-		p = &((*p)->c.c_cdr);
+		collect(p,make_cons(x,Cnil));
 	}
 	if (recursivep == Cnil) {
 	  if (sSAsharp_eq_contextA->s.s_dbind!=Cnil)
@@ -2181,6 +2180,18 @@ LFD(Lreadtablep)()
 	@(return Ct)
 @)
 
+DEFUN_NEW("READTABLE-CASE",object,fLreadtable_case,LISP,1,1,NONE,OO,OO,OO,OO,(object rt),"") {
+  check_type_readtable_no_default(&rt);
+  RETURN1(rt->rt.rt_case);
+}
+
+DEFUN_NEW("SET-READTABLE-CASE",object,fSset_readtable_case,SI,2,2,NONE,OO,OO,OO,OO,(object rt,object cas),"") {
+  check_type_readtable_no_default(&rt);
+  if (cas!=sKupcase && cas!=sKdowncase && cas!=sKpreserve && cas!=sKinvert)
+    TYPE_ERROR(cas,list(5,sLmember,sKupcase,sKdowncase,sKpreserve,sKinvert));
+  RETURN1(rt->rt.rt_case=cas);
+}
+
 @(static defun get_dispatch_macro_character (dspchr subchr
 	&optional (rdtbl `current_readtable()`))
 @
@@ -2348,6 +2359,13 @@ gcl_init_read()
 
 	gcl_init_backq();
 
+	sKupcase = make_keyword("UPCASE");
+	sKdowncase = make_keyword("DOWNCASE");
+	sKpreserve = make_keyword("PRESERVE");
+	sKinvert = make_keyword("INVERT");
+
+	standard_readtable->rt.rt_case=sKupcase;
+
 	Vreadtable
  	= make_special("*READTABLE*",
 		       copy_readtable(standard_readtable, Cnil));
--- gcl-2.6.12.orig/o/reference.c
+++ gcl-2.6.12/o/reference.c
@@ -73,18 +73,14 @@ LFD(Lsymbol_function)(void)
 	if (type_of(sym) != t_symbol)
 		not_a_symbol(sym);
 	if (sym->s.s_sfdef != NOT_SPECIAL) {
-		vs_push(make_fixnum((long)(sym->s.s_sfdef)));
-		vs_base[0] = sLspecial;
-		stack_cons();
-		return;
+	  vs_base[0]=make_cons(sLspecial,make_fixnum((long)(sym->s.s_sfdef)));
+	  return;
 	}
 	if (sym->s.s_gfdef==OBJNULL)
 		FEundefined_function(sym);
 	if (sym->s.s_mflag) {
-		vs_push(sym->s.s_gfdef);
-		vs_base[0] = sSmacro;
-		stack_cons();
-		return;
+	  vs_base[0]=make_cons(sSmacro,sym->s.s_gfdef);
+	  return;
 	}
 	vs_base[0] = sym->s.s_gfdef;
 }
--- gcl-2.6.12.orig/o/sequence.d
+++ gcl-2.6.12/o/sequence.d
@@ -205,16 +205,7 @@ E:
 		}
 		if (e < 0)
 			@(return `copy_list(sequence)`)
-		for (i = 0;  i < e;  i++) {
-			if (type_of(sequence) != t_cons)
-				goto ILLEGAL_START_END;
-			vs_check_push(sequence->c.c_car);
-			sequence = sequence->c.c_cdr;
-		}
-		vs_push(Cnil);
-		while (e-- > 0)
-			stack_cons();
-		x = vs_pop;
+		x=n_cons_from_x(e,sequence);
 		@(return x)
 
 	case t_vector:
--- gcl-2.6.12.orig/o/sgbc.c
+++ gcl-2.6.12/o/sgbc.c
@@ -165,7 +165,7 @@ sgc_sweep_phase(void) {
     tm = tm_of((enum type)v->type);
     
     p = pagetochar(page(v));
-    f = tm->tm_free;
+    f = FREELIST_TAIL(tm);
     k = 0;
     size=tm->tm_size;
 
@@ -189,7 +189,7 @@ sgc_sweep_phase(void) {
 	
 	/* it is ok to free x */
 	
-	SET_LINK(x,f);
+	SET_LINK(f,x);
 	make_free(x);
 #ifndef SGC_WHOLE_PAGE
 	if (TYPEWORD_TYPE_P(v->type)) x->d.s = SGC_RECENT;
@@ -198,7 +198,8 @@ sgc_sweep_phase(void) {
 	k++;
 
       }
-      tm->tm_free = f;
+      SET_LINK(f,OBJNULL);
+      tm->tm_tail = f;
       tm->tm_nfree += k;
       v->in_use-=k;
 
@@ -674,34 +675,38 @@ sgc_start(void) {
      contain the others */
   for (i= t_start; i < t_contiguous ; i++)
     if (TM_BASE_TYPE_P(i) && (np=(tm=tm_of(i))->tm_sgc)) {
-      object f=tm->tm_free ,x,y,next;
+      object f=tm->tm_free,xf,yf;
+      struct freelist x,y;/*the f_link heads have to be separated on the stack*/
       fixnum count=0;
-      x=y=OBJNULL;
       
+      xf=PHANTOM_FREELIST(x.f_link);
+      yf=PHANTOM_FREELIST(y.f_link);
       while (f!=OBJNULL) {
-	next=OBJ_LINK(f);
 #ifdef SDEBUG	     
 	if (!is_free(f))
 	  printf("Not FREE in freelist f=%d",f);
 #endif
 	if (pageinfo(f)->sgc_flags&SGC_PAGE_FLAG) {
-	  SET_LINK(f,x);
+	  SET_LINK(xf,f);
 #ifndef SGC_WHOLE_PAGE
 	  if (TYPEWORD_TYPE_P(pageinfo(f)->type)) f->d.s = SGC_RECENT;
 #endif
-	  x=f;
+	  xf=f;
 	  count++;
 	} else {
-	  SET_LINK(f,y);
+	  SET_LINK(yf,f);
 #ifndef SGC_WHOLE_PAGE
  	  if (TYPEWORD_TYPE_P(pageinfo(f)->type)) f->d.s = SGC_NORMAL;
 #endif
-	  y=f;
+	  yf=f;
 	}
-	f=next;
+	f=OBJ_LINK(f);
       }
-      tm->tm_free = x;
-      tm->tm_alt_free = y;
+      SET_LINK(xf,OBJNULL);
+      tm->tm_free = OBJ_LINK(&x);
+      tm->tm_tail = xf;
+      SET_LINK(yf,OBJNULL);
+      tm->tm_alt_free = OBJ_LINK(&y);
       tm->tm_alt_nfree = tm->tm_nfree - count;
       tm->tm_nfree=count;
     }
@@ -853,38 +858,21 @@ sgc_quit(void) {
   for (i= t_start; i < t_contiguous ; i++)
     
     if (TM_BASE_TYPE_P(i) && (np=(tm=tm_of(i))->tm_sgc)) {
-      
-      object f,y;
-      
-      f=tm->tm_free;
-      if (f==OBJNULL) 
-	tm->tm_free=tm->tm_alt_free;
-      else {
-	/* tack the alt_free onto the end of free */
-#ifdef SDEBUG
-	fixnum count=0;
-	f=tm->tm_free;
-	while(y= (object) F_LINK(f)) {
-	  if(y->d.s != SGC_RECENT)
-	    printf("[bad %d]",y);
-	  count++; f=y;
+
+      object n=tm->tm_free,o=tm->tm_alt_free,f=PHANTOM_FREELIST(tm->tm_free);
+
+      for (;n!=OBJNULL && o!=OBJNULL;)
+	if (o!=OBJNULL && (n==OBJNULL || o<n)) {
+	  SET_LINK(f,o);
+	  f=o;
+	  o=OBJ_LINK(o);
+	} else {
+	  SET_LINK(f,n);
+	  f=n;
+	  n=OBJ_LINK(n);
 	}
-	
-	count=0;
-	if (f==tm->tm_alt_free)
-	  while(y= F_LINK(f)) {
-	    if(y->d.s != SGC_NORMAL)
-	      printf("[alt_bad %d]",y);
-	    count++; f=y;
-	  }
-	
-#endif
-	f=tm->tm_free;
-	while((y= (object) F_LINK(f))!=OBJNULL)
-	  f=y;
-	F_LINK(f)= (long)(tm->tm_alt_free);
-      }
-      /* tm->tm_free has all of the free objects */
+      SET_LINK(f,OBJNULL);
+      tm->tm_tail=f;
       tm->tm_nfree += tm->tm_alt_nfree;
       tm->tm_alt_nfree = 0;
       tm->tm_alt_free = OBJNULL;
--- gcl-2.6.12.orig/o/structure.c
+++ gcl-2.6.12/o/structure.c
@@ -182,22 +182,19 @@ object
 structure_to_list(object x)
 {
 
-	object *p, s;
-	struct s_data *def=S_DATA(x->str.str_def);
-	int i, n;
-	
-	s = def->slot_descriptions;
-	vs_push(def->name);
-	vs_push(Cnil);
-	p = &vs_head;
-	for (i=0, n=def->length;  !endp(s)&&i<n;  s=s->c.c_cdr, i++) {
-		*p = make_cons(car(s->c.c_car), Cnil);
-		p = &((*p)->c.c_cdr);
-		*p = make_cons(structure_ref(x,x->str.str_def,i), Cnil);
-		p = &((*p)->c.c_cdr);
-	}
-	stack_cons();
-	return(vs_pop);
+  object *p,s,v;
+  struct s_data *def=S_DATA(x->str.str_def);
+  int i,n;
+
+  s=def->slot_descriptions;
+  for (p=&v,i=0,n=def->length;!endp(s)&&i<n;s=s->c.c_cdr,i++) {
+    collect(p,make_cons(car(s->c.c_car),Cnil));
+    collect(p,make_cons(structure_ref(x,x->str.str_def,i),Cnil));
+  }
+  *p=Cnil;
+
+  return make_cons(def->name,v);
+
 }
 
 LFD(siLmake_structure)(void)
--- gcl-2.6.12.orig/o/unixfsys.c
+++ gcl-2.6.12/o/unixfsys.c
@@ -169,9 +169,8 @@ DEF_ORDINARY("DIRECTORY",sKdirectory,KEY
 DEF_ORDINARY("LINK",sKlink,KEYWORD,"");
 DEF_ORDINARY("FILE",sKfile,KEYWORD,"");
 
-DEFUNM_NEW("STAT",object,fSstat,SI,1,1,NONE,OO,OO,OO,OO,(object x),"") {
-
-  struct stat ss;
+static int
+stat_internal(object x,struct stat *ssp) {
 
   if (type_of(x)==t_string) {
 
@@ -180,19 +179,43 @@ DEFUNM_NEW("STAT",object,fSstat,SI,1,1,N
 #ifdef __MINGW32__
     {char *p=FN1+strlen(FN1)-1;for (;p>FN1 && *p=='/';p--) *p=0;}
 #endif
-    if (lstat(FN1,&ss))
-      RETURN1(Cnil);
+    if (lstat(FN1,ssp))
+      return 0;
   } else if ((x=file_stream(x))!=Cnil&&x->sm.sm_fp) {
-    if (fstat(fileno(x->sm.sm_fp),&ss))
-      RETURN1(Cnil);
+    if (fstat(fileno(x->sm.sm_fp),ssp))
+      return 0;
   } else
-    RETURN1(Cnil);
+    return 0;
+  return 1;
+}
+
+static object
+stat_mode_key(struct stat *ssp) {
 
-  RETURN4(S_ISDIR(ss.st_mode) ? sKdirectory :
-	  (S_ISLNK(ss.st_mode) ? sKlink : sKfile),
-	  make_fixnum(ss.st_size),
-	  make_fixnum(ss.st_mtime),
-	  make_fixnum(ss.st_uid));
+  return S_ISDIR(ssp->st_mode) ? sKdirectory : (S_ISLNK(ssp->st_mode) ? sKlink : sKfile);
+
+}
+
+DEFUN_NEW("STAT1",object,fSstat1,SI,1,1,NONE,OO,OO,OO,OO,(object x),"") {
+
+  struct stat ss;
+
+  RETURN1(stat_internal(x,&ss) ? stat_mode_key(&ss) : Cnil);
+
+}
+
+
+DEFUNM_NEW("STAT",object,fSstat,SI,1,1,NONE,OO,OO,OO,OO,(object x),"") {
+
+  struct stat ss;
+
+  if (stat_internal(x,&ss))
+    RETURN4(stat_mode_key(&ss),
+	    make_fixnum(ss.st_size),
+	    make_fixnum(ss.st_mtime),
+	    make_fixnum(ss.st_uid));
+  else
+    RETURN1(Cnil);
 
 }
 
--- gcl-2.6.12.orig/o/wpool.c
+++ gcl-2.6.12/o/wpool.c
@@ -3,7 +3,7 @@
 #define NO_PRELINK_UNEXEC_DIVERSION
 char *rb_end=NULL,*rb_start=NULL,*heap_end=NULL;
 void *data_start=NULL;
-int use_pool=1;
+int multiprocess_memory_pool=1;
 
 #include "include.h"
 #include "page.h"
@@ -20,9 +20,9 @@ assert_error(const char *a,unsigned l,co
 int
 main(int argc,char * argv[],char * envp[]) {
 
-  int s;
+  int s=3;
 
-  sscanf(argv[1],"%d",&s);
+  if (argc>1) sscanf(argv[1],"%d",&s);
   open_pool();
   for (;;) {
     lock_pool();
--- gcl-2.6.12.orig/pcl/sys-proclaim.lisp
+++ gcl-2.6.12/pcl/sys-proclaim.lisp
@@ -2,402 +2,1009 @@
 (COMMON-LISP::IN-PACKAGE "PCL") 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::FIXNUM COMMON-LISP::T)
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
+             PCL::NON-NEGATIVE-FIXNUM)
+         PCL::CACHE-SIZE PCL::CACHE-MASK PCL::CACHE-NLINES
+         PCL::CACHE-MAX-LOCATION)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::T)
+         PCL::COMPILE-LAMBDA-DEFERRED
+         PCL::EARLY-SLOT-DEFINITION-LOCATION PCL::FGEN-SYSTEM
+         PCL::EARLY-CLASS-PRECEDENCE-LIST PCL::MAKE-CLASS-EQ-PREDICATE
+         PCL::BOOTSTRAP-ACCESSOR-DEFINITIONS PCL::USE-CACHING-DFUN-P
+         WALKER::GET-IMPLEMENTATION-DEPENDENT-WALKER-TEMPLATE
+         PCL::SFUN-P PCL::INTERN-EQL-SPECIALIZER
+         PCL::ACCESSOR-DFUN-INFO-P WALKER::ENV-WALK-FORM
+         PCL::ARG-INFO-NUMBER-OPTIONAL PCL::TWO-CLASS-ACCESSOR-TYPE
+         PCL::FREE-CACHE PCL::SHOW-DFUN-COSTS PCL::CHECKING-CACHE
+         PCL::EARLY-GF-P PCL::EARLY-COLLECT-CPL PCL::NO-METHODS-CACHE
+         PCL::EXTRACT-PARAMETERS PCL::DEFAULT-CONSTANTP
+         PCL::PARSE-SPECIALIZERS
+         PCL::MAKE-OPTIMIZED-STRUCTURE-SETF-SLOT-VALUE-USING-CLASS-METHOD-FUNCTION
+         PCL::INITIALIZE-INFO-CACHED-SHARED-INITIALIZE-NIL-FUNCTION
+         PCL::DFUN-INFO-P PCL::CLASS-PRECEDENCE-DESCRIPTION-P
+         PCL::%FBOUNDP PCL::ONE-INDEX-DFUN-INFO-INDEX
+         PCL::ONE-CLASS-CACHE PCL::DEFAULT-STRUCTURE-INSTANCE-P
+         PCL::CONSTANT-VALUE-CACHE PCL::STRUCTURE-SVUC-METHOD
+         PCL::CLASS-HAS-A-FORWARD-REFERENCED-SUPERCLASS-P
+         PCL::METHODS-CONTAIN-EQL-SPECIALIZER-P
+         PCL::STRUCTURE-SLOTD-WRITER-FUNCTION PCL::CCLOSUREP
+         PCL::COUNT-DFUN PCL::COMPUTE-STD-CPL-PHASE-2
+         PCL::EARLY-METHOD-STANDARD-ACCESSOR-SLOT-NAME
+         PCL::EARLY-SLOT-DEFINITION-NAME PCL::MAP-SPECIALIZERS
+         PCL::MAKE-CONSTANT-FUNCTION PCL::GF-PRECOMPUTE-DFUN-AND-EMF-P
+         PCL::DEFAULT-TEST-CONVERTER
+         PCL::PROCLAIM-INCOMPATIBLE-SUPERCLASSES PCL::TWO-CLASS-INDEX
+         PCL::CACHE-P PCL::ARG-INFO-PRECEDENCE
+         PCL::STRUCTURE-SLOTD-INIT-FORM PCL::INITIAL-P
+         PCL::EXTRACT-REQUIRED-PARAMETERS PCL::%STD-INSTANCE-WRAPPER
+         PCL::FUNCTION-PRETTY-ARGLIST PCL::INTERN-FUNCTION-NAME
+         PCL::INITIALIZE-INFO-CACHED-COMBINED-INITARGS-FORM-LIST
+         PCL::FLUSH-CACHE-VECTOR-INTERNAL PCL::TWO-CLASS-P
+         PCL::CHECK-CACHE PCL::RESET-INITIALIZE-INFO
+         PCL::ONE-INDEX-DFUN-INFO-P PCL::LEGAL-CLASS-NAME-P
+         PCL::UPDATE-PV-TABLE-CACHE-INFO
+         PCL::RESET-CLASS-INITIALIZE-INFO PCL::DISPATCH-P
+         PCL::%STD-INSTANCE-SLOTS PCL::SETFBOUNDP PCL::LOOKUP-FGEN
+         PCL::MAKE-INITFUNCTION PCL::FORCE-CACHE-FLUSHES
+         PCL::COMPLICATED-INSTANCE-CREATION-METHOD
+         PCL::NET-TEST-CONVERTER WALKER::ENV-DECLARATIONS
+         SYSTEM::%STRUCTURE-NAME PCL::GMAKUNBOUND PCL::TWO-CLASS-CACHE
+         PCL::STRUCTURE-TYPE PCL::CPD-CLASS PCL::CPD-AFTER
+         PCL::FAST-METHOD-CALL-P PCL::FGEN-GENERATOR-LAMBDA
+         PCL::CHECKING-FUNCTION PCL::DEFAULT-CONSTANT-CONVERTER
+         PCL::BUILT-IN-OR-STRUCTURE-WRAPPER1
+         PCL::GET-MAKE-INSTANCE-FUNCTION-SYMBOL PCL::EARLY-METHOD-CLASS
+         PCL::BUILT-IN-WRAPPER-OF PCL::EXPAND-SHORT-DEFCOMBIN
+         PCL::WRAPPER-OF
+         PCL::MAKE-OPTIMIZED-STRUCTURE-SLOT-BOUNDP-USING-CLASS-METHOD-FUNCTION
+         PCL::INITIALIZE-INFO-CACHED-SHARED-INITIALIZE-T-FUNCTION
+         PCL::PV-TABLEP PCL::EARLY-CLASS-NAME-OF
+         PCL::GET-MAKE-INSTANCE-FUNCTION PCL::ARG-INFO-KEY/REST-P
+         PCL::MAKE-EQL-PREDICATE PCL::STRUCTURE-SLOTD-READER-FUNCTION
+         PCL::CACHING-DFUN-INFO PCL::GF-INFO-SIMPLE-ACCESSOR-TYPE
+         PCL::N-N-ACCESSOR-TYPE PCL::FAST-METHOD-CALL-PV-CELL
+         PCL::MAKE-STRUCTURE-SLOT-BOUNDP-FUNCTION
+         PCL::EXTRACT-SPECIALIZER-NAMES PCL::MAKE-TYPE-PREDICATE
+         PCL::GET-CACHE-VECTOR PCL::SORT-SLOTS
+         PCL::DEFAULT-STRUCTURE-TYPE SYSTEM::%COMPILED-FUNCTION-NAME
+         PCL::DO-STANDARD-DEFSETFS-FOR-DEFCLASS WALKER::ENV-LOCK
+         PCL::ONE-INDEX-DFUN-INFO-CACHE PCL::ONE-INDEX-P
+         PCL::METHOD-FUNCTION-FROM-FAST-FUNCTION
+         PCL::STANDARD-SVUC-METHOD PCL::MAKE-FUNCTION-INLINE
+         PCL::ALLOCATE-CACHE-VECTOR PCL::SLOT-BOUNDP-SYMBOL
+         PCL::METHOD-CALL-P PCL::STD-INSTANCE-P
+         PCL::GET-BUILT-IN-WRAPPER-SYMBOL PCL::FUNCALLABLE-INSTANCE-P
+         PCL::ECD-CANONICAL-SLOTS PCL::GET-BUILT-IN-CLASS-SYMBOL
+         PCL::FREE-CACHE-VECTOR PCL::GF-INFO-STATIC-C-A-M-EMF
+         PCL::EARLY-GF-NAME PCL::UPDATE-CLASS-CAN-PRECEDE-P
+         PCL::USE-DEFAULT-METHOD-ONLY-DFUN-P
+         PCL::ACCESSOR-DFUN-INFO-CACHE PCL::ARG-INFO-VALID-P
+         PCL::ONE-CLASS-INDEX WALKER::GET-WALKER-TEMPLATE
+         PCL::GFS-OF-TYPE PCL::N-N-P PCL::METHOD-CALL-CALL-METHOD-ARGS
+         PCL::BOOTSTRAP-CLASS-PREDICATES PCL::MAKE-INITIAL-DFUN
+         PCL::ONE-CLASS-WRAPPER0 PCL::ECD-OTHER-INITARGS
+         PCL::TWO-CLASS-WRAPPER1 PCL::MAKE-INSTANCE-FUNCTION-SYMBOL
+         PCL::FUNCTION-RETURNING-T PCL::STRUCTURE-SLOTD-TYPE
+         PCL::ARG-INFO-APPLYP PCL::ECD-SUPERCLASS-NAMES
+         PCL::EARLY-ACCESSOR-METHOD-SLOT-NAME
+         PCL::INITIALIZE-INFO-CACHED-MAKE-INSTANCE-FUNCTION
+         PCL::FGEN-GENSYMS PCL::EARLY-METHOD-STANDARD-ACCESSOR-P
+         PCL::DEFAULT-METHOD-ONLY-CACHE WALKER::ENV-LEXICAL-VARIABLES
+         PCL::ECD-CLASS-NAME PCL::GET-MAKE-INSTANCE-FUNCTIONS
+         PCL::EARLY-CLASS-DEFINITION PCL::ECD-METACLASS
+         PCL::UNDEFMETHOD-1 PCL::MAKE-CALL-METHODS
+         PCL::METHOD-LL->GENERIC-FUNCTION-LL PCL::SORT-CALLS
+         ITERATE::VARIABLES-FROM-LET PCL::GF-LAMBDA-LIST
+         PCL::INITIALIZE-INFO-KEY PCL::EARLY-CLASS-DIRECT-SUBCLASSES
+         PCL::ACCESSOR-DFUN-INFO-ACCESSOR-TYPE
+         PCL::MAKE-PERMUTATION-VECTOR PCL::EXTRACT-LAMBDA-LIST
+         PCL::CONSTANT-VALUE-DFUN-INFO PCL::DNET-METHODS-P
+         PCL::STRUCTURE-TYPE-INCLUDED-TYPE-NAME
+         PCL::UPDATE-GFS-OF-CLASS PCL::SLOT-VECTOR-SYMBOL
+         PCL::COMPUTE-MCASE-PARAMETERS PCL::GBOUNDP
+         PCL::SLOT-INITARGS-FROM-STRUCTURE-SLOTD PCL::CONSTANT-SYMBOL-P
+         PCL::CPD-SUPERS PCL::DEFAULT-METHOD-ONLY-P
+         PCL::MAKE-OPTIMIZED-STRUCTURE-SLOT-VALUE-USING-CLASS-METHOD-FUNCTION
+         PCL::CACHE-OWNER PCL::FAST-INSTANCE-BOUNDP-P
+         PCL::INITIALIZE-INFO-WRAPPER
+         PCL::INITIALIZE-INFO-CACHED-VALID-P PCL::EVAL-FORM
+         PCL::DEFAULT-STRUCTUREP PCL::FUNCTION-RETURNING-NIL
+         PCL::ONE-CLASS-P PCL::ARG-INFO-KEYWORDS
+         PCL::EARLY-CLASS-SLOTDS PCL::GET-PV-CELL-FOR-CLASS
+         PCL::ONE-CLASS-ACCESSOR-TYPE PCL::GENERIC-CLOBBERS-FUNCTION
+         PCL::DFUN-INFO-CACHE PCL::MAKE-PV-TABLE-TYPE-DECLARATION
+         PCL::RESET-CLASS-INITIALIZE-INFO-1 PCL::CLASS-FROM-TYPE
+         PCL::FTYPE-DECLARATION-FROM-LAMBDA-LIST
+         PCL::EARLY-METHOD-LAMBDA-LIST
+         PCL::EARLY-COLLECT-DEFAULT-INITARGS
+         PCL::COMPILE-LAMBDA-UNCOMPILED
+         PCL::INITIALIZE-INFO-CACHED-RI-VALID-P PCL::STRUCTURE-TYPE-P
+         PCL::%SYMBOL-FUNCTION PCL::MAKE-CALLS-TYPE-DECLARATION
+         PCL::SLOT-READER-SYMBOL PCL::KEYWORD-SPEC-NAME
+         PCL::FIND-CYCLE-REASONS PCL::UPDATE-ALL-C-A-M-GF-INFO
+         PCL::INITIALIZE-INFO-P
+         PCL::METHOD-FUNCTION-NEEDS-NEXT-METHODS-P
+         PCL::INITIAL-DISPATCH-CACHE PCL::CACHING-CACHE
+         PCL::INFORM-TYPE-SYSTEM-ABOUT-STD-CLASS
+         PCL::INITIALIZE-INFO-CACHED-INITARGS-FORM-LIST
+         PCL::STRUCTURE-TYPE-INTERNAL-SLOTDS PCL::CONSTANT-VALUE-P
+         PCL::FAST-METHOD-CALL-NEXT-METHOD-CALL PCL::EARLY-CLASS-SLOTS
+         PCL::UPDATE-C-A-M-GF-INFO PCL::GDEFINITION
+         PCL::ARG-INFO-LAMBDA-LIST PCL::STRUCTURE-SLOTD-ACCESSOR-SYMBOL
+         PCL::DEFAULT-SECONDARY-DISPATCH-FUNCTION
+         PCL::MAKE-PV-TYPE-DECLARATION
+         PCL::COMPUTE-APPLICABLE-METHODS-EMF-STD-P PCL::DISPATCH-CACHE
+         PCL::ONE-INDEX-ACCESSOR-TYPE
+         PCL::INITIALIZE-INFO-CACHED-CONSTANTS PCL::NO-METHODS-P
+         PCL::INITIALIZE-INFO-CACHED-COMBINED-INITIALIZE-FUNCTION
+         PCL::CACHING-DFUN-COST PCL::ONE-INDEX-DFUN-INFO-ACCESSOR-TYPE
+         PCL::COMPUTE-CLASS-SLOTS PCL::UPDATE-GF-SIMPLE-ACCESSOR-TYPE
+         PCL::GF-INFO-FAST-MF-P PCL::GF-INFO-C-A-M-EMF-STD-P
+         PCL::FGEN-TEST PCL::STRUCTURE-SLOTD-NAME PCL::CLASS-PREDICATE
+         PCL::STRUCTURE-SLOT-BOUNDP PCL::EARLY-CLASS-NAME
+         PCL::LIST-LARGE-CACHE PCL::ONE-INDEX-CACHE
+         PCL::SYMBOL-PKG-NAME PCL::INITIAL-CACHE
+         PCL::UNENCAPSULATED-FDEFINITION PCL::STORE-FGEN
+         PCL::FINAL-ACCESSOR-DFUN-TYPE
+         PCL::INITIALIZE-INFO-CACHED-NEW-KEYS PCL::TYPE-CLASS
+         PCL::%CCLOSURE-ENV PCL::INITIALIZE-INFO-BOUND-SLOTS
+         PCL::GF-DFUN-CACHE PCL::EXPAND-LONG-DEFCOMBIN
+         PCL::FGEN-GENERATOR PCL::DFUN-ARG-SYMBOL
+         PCL::STRUCTURE-TYPE-SLOT-DESCRIPTION-LIST
+         PCL::EARLY-METHOD-QUALIFIERS
+         WALKER::VARIABLE-GLOBALLY-SPECIAL-P COMMON-LISP::CLASS-OF
+         PCL::INITIALIZE-INFO-CACHED-DEFAULT-INITARGS-FUNCTION
+         PCL::GET-SETF-FUNCTION-NAME PCL::ARG-INFO-P
+         WALKER::ENV-WALK-FUNCTION PCL::LIST-DFUN
+         PCL::CHECK-WRAPPER-VALIDITY PCL::ARG-INFO-METATYPES
+         PCL::EXPAND-MAKE-INSTANCE-FORM PCL::STRUCTURE-OBJECT-P
+         PCL::COMPUTE-LINE-SIZE PCL::CANONICAL-SLOT-NAME
+         PCL::INITIAL-DISPATCH-P PCL::NEXT-WRAPPER-FIELD
+         PCL::WRAPPER-FIELD PCL::WRAPPER-FOR-STRUCTURE
+         PCL::METHOD-FUNCTION-PV-TABLE PCL::COPY-CACHE PCL::ECD-SOURCE
+         PCL::INITIALIZE-INFO-CACHED-MAKE-INSTANCE-FUNCTION-SYMBOL
+         PCL::UNPARSE-SPECIALIZERS PCL::CHECKING-P
+         PCL::FORMAT-CYCLE-REASONS PCL::N-N-CACHE
+         PCL::MAKE-DEFAULT-METHOD-GROUP-DESCRIPTION
+         PCL::MAP-ALL-GENERIC-FUNCTIONS PCL::METHOD-FUNCTION-METHOD
+         PCL::UPDATE-GF-INFO PCL::ARG-INFO-NKEYS
+         PCL::TWO-CLASS-WRAPPER0 PCL::GF-DFUN-INFO PCL::ONE-INDEX-INDEX
+         PCL::EARLY-COLLECT-SLOTS PCL::CACHING-P
+         PCL::METHOD-FUNCTION-PLIST PCL::SLOT-WRITER-SYMBOL
+         PCL::FAST-METHOD-CALL-ARG-INFO PCL::INTERNED-SYMBOL-P
+         ITERATE::SEQUENCE-ACCESSOR)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::*) COMMON-LISP::*)
+         PCL::LIST-LARGE-CACHES
+         PCL::UPDATE-MAKE-INSTANCE-FUNCTION-TABLE PCL::UNTRACE-METHOD
+         COMMON-LISP::INVALID-METHOD-ERROR
+         COMMON-LISP::METHOD-COMBINATION-ERROR)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::*) COMMON-LISP::T)
+         PCL::|__si::MAKE-CLASS-PRECEDENCE-DESCRIPTION|
+         PCL::|__si::MAKE-TWO-CLASS| PCL::FALSE PCL::MAKE-PV-TABLE
+         PCL::|__si::MAKE-DISPATCH| PCL::MAKE-INITIALIZE-INFO
+         PCL::|__si::MAKE-PV-TABLE| PCL::MAKE-FAST-INSTANCE-BOUNDP
+         PCL::|__si::MAKE-DEFAULT-METHOD-ONLY|
+         WALKER::UNBOUND-LEXICAL-FUNCTION
+         PCL::|__si::MAKE-ACCESSOR-DFUN-INFO| PCL::|__si::MAKE-N-N|
+         PCL::USE-PACKAGE-PCL PCL::|__si::MAKE-CHECKING|
+         PCL::|STRUCTURE-OBJECT class constructor|
+         PCL::|__si::MAKE-CONSTANT-VALUE|
+         PCL::CALLED-FIN-WITHOUT-FUNCTION PCL::|__si::MAKE-INITIAL|
+         PCL::|__si::MAKE-CACHE| PCL::|__si::MAKE-ONE-INDEX|
+         PCL::MAKE-PROGN PCL::TRUE PCL::MAKE-FAST-METHOD-CALL
+         PCL::|__si::MAKE-ARG-INFO| PCL::INTERN-PV-TABLE
+         PCL::|__si::MAKE-DFUN-INFO| PCL::|__si::MAKE-STD-INSTANCE|
+         PCL::|__si::MAKE-CACHING| PCL::|__si::MAKE-ONE-CLASS|
+         PCL::PV-WRAPPERS-FROM-PV-ARGS PCL::ZERO
+         PCL::|__si::MAKE-INITIAL-DISPATCH|
+         PCL::|__si::MAKE-NO-METHODS| PCL::STRING-APPEND
+         PCL::|__si::MAKE-ONE-INDEX-DFUN-INFO| PCL::MAKE-METHOD-CALL
+         PCL::FIX-EARLY-GENERIC-FUNCTIONS)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::*)
+         PCL::METHOD-PROTOTYPE-FOR-GF PCL::SPECIALIZER-FROM-TYPE
+         PCL::EMIT-ONE-INDEX-WRITERS PCL::*NORMALIZE-TYPE
+         PCL::COMPUTE-APPLICABLE-METHODS-EMF PCL::ANALYZE-LAMBDA-LIST
+         PCL::PARSE-DEFMETHOD PCL::GET-DISPATCH-FUNCTION
+         PCL::PROTOTYPES-FOR-MAKE-METHOD-LAMBDA
+         PCL::EMIT-CONSTANT-VALUE PCL::FIND-WRAPPER
+         PCL::MAKE-FINAL-DISPATCH-DFUN PCL::EARLY-COLLECT-INHERITANCE
+         PCL::GENERIC-FUNCTION-NAME-P PCL::EMIT-TWO-CLASS-READER
+         PCL::PARSE-METHOD-GROUP-SPECIFIER PCL::EMIT-ONE-CLASS-READER
+         PCL::FIND-STRUCTURE-CLASS PCL::EMIT-TWO-CLASS-WRITER
+         PCL::CONVERT-TO-SYSTEM-TYPE PCL::TYPE-FROM-SPECIALIZER
+         PCL::EMIT-ONE-CLASS-WRITER PCL::EARLY-METHOD-FUNCTION
+         PCL::MAKE-DISPATCH-DFUN PCL::NET-CODE-CONVERTER
+         PCL::GET-GENERIC-FUNCTION-INFO PCL::DEFAULT-CODE-CONVERTER
+         PCL::COMPILE-IIS-FUNCTIONS PCL::EMIT-ONE-INDEX-READERS
+         PCL::STRUCTURE-WRAPPER PCL::CLASS-EQ-TYPE
+         PCL::EMIT-IN-CHECKING-CACHE-P PCL::PCL-DESCRIBE)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
              COMMON-LISP::T)
-         PCL::%CCLOSURE-ENV-NTHCDR)) 
+         ITERATE::RENAME-AND-CAPTURE-VARIABLES
+         PCL::|(FAST-METHOD WRAPPER-FETCHER (STANDARD-CLASS))|
+         WALKER::WALK-PROG PCL::INVALIDATE-WRAPPER
+         PCL::COMPUTE-PRECEDENCE
+         PCL::|(FAST-METHOD SPECIALIZER-DIRECT-METHODS (CLASS))|
+         WALKER::WALK-LAMBDA PCL::STANDARD-COMPUTE-EFFECTIVE-METHOD
+         PCL::|(FAST-METHOD FINALIZE-INHERITANCE (STD-CLASS))|
+         WALKER::WALK-MULTIPLE-VALUE-BIND
+         PCL::|(FAST-METHOD SPECIALIZER-CLASS (CLASS))|
+         PCL::|(FAST-METHOD SLOTS-FETCHER (FUNCALLABLE-STANDARD-CLASS))|
+         PCL::|(FAST-METHOD SPECIALIZER-DIRECT-METHODS (SPECIALIZER-WITH-OBJECT))|
+         PCL::NOTE-PV-TABLE-REFERENCE
+         PCL::|(FAST-METHOD CLASS-PREDICATE-NAME (T))|
+         PCL::|(FAST-METHOD ACCESSOR-METHOD-CLASS (STANDARD-WRITER-METHOD))|
+         WALKER::WALK-MULTIPLE-VALUE-SETQ PCL::CONVERT-TABLE
+         WALKER::WALK-LET
+         PCL::|(FAST-METHOD FINALIZE-INHERITANCE (STRUCTURE-CLASS))|
+         PCL::|(FAST-METHOD INITIALIZE-INTERNAL-SLOT-FUNCTIONS (EFFECTIVE-SLOT-DEFINITION))|
+         PCL::|(FAST-METHOD MAKE-INSTANCES-OBSOLETE (STD-CLASS))|
+         PCL::|(FAST-METHOD SPECIALIZER-METHOD-TABLE (EQL-SPECIALIZER))|
+         PCL::SKIP-FAST-SLOT-ACCESS-P
+         PCL::|(FAST-METHOD SLOT-DEFINITION-ALLOCATION (STRUCTURE-SLOT-DEFINITION))|
+         PCL::|(FAST-METHOD RAW-INSTANCE-ALLOCATOR (FUNCALLABLE-STANDARD-CLASS))|
+         PCL::OPTIMIZE-SLOT-BOUNDP PCL::TRACE-EMF-CALL-INTERNAL
+         ITERATE::SIMPLE-EXPAND-GATHERING-FORM
+         PCL::MAKE-OPTIMIZED-STD-SETF-SLOT-VALUE-USING-CLASS-METHOD-FUNCTION
+         WALKER::WALK-FLET PCL::ONE-CLASS-DFUN-INFO
+         WALKER::WALK-COMPILER-LET
+         PCL::|(FAST-METHOD RAW-INSTANCE-ALLOCATOR (STANDARD-CLASS))|
+         PCL::FIRST-FORM-TO-LISP WALKER::WALK-DO*
+         PCL::|(FAST-METHOD SPECIALIZER-CLASS (EQL-SPECIALIZER))|
+         PCL::|(FAST-METHOD ACCESSOR-METHOD-CLASS (STANDARD-ACCESSOR-METHOD))|
+         PCL::|(FAST-METHOD COMPUTE-DEFAULT-INITARGS (SLOT-CLASS))|
+         PCL::|(FAST-METHOD COMPUTE-CLASS-PRECEDENCE-LIST (SLOT-CLASS))|
+         PCL::PRINT-STD-INSTANCE
+         PCL::|(FAST-METHOD CLASS-DIRECT-DEFAULT-INITARGS (BUILT-IN-CLASS))|
+         WALKER::WALK-MACROLET PCL::GET-FUNCTION-GENERATOR
+         PCL::INITIALIZE-INTERNAL-SLOT-GFS*
+         PCL::|(FAST-METHOD CLASS-DEFAULT-INITARGS (SLOT-CLASS))|
+         PCL::COMPUTE-EFFECTIVE-METHOD PCL::EXPAND-DEFGENERIC
+         PCL::OBSOLETE-INSTANCE-TRAP WALKER::WALK-TAGBODY-1
+         PCL::MAKE-METHOD-INITARGS-FORM-INTERNAL
+         PCL::GET-NEW-FUNCTION-GENERATOR PCL::SORT-METHODS
+          WALKER::WALK-DO PCL::MAKE-DFUN-CALL
+         PCL::OPTIMIZE-GF-CALL-INTERNAL
+         PCL::|(FAST-METHOD GENERIC-FUNCTION-PRETTY-ARGLIST (STANDARD-GENERIC-FUNCTION))|
+         PCL::OPTIMIZE-SET-SLOT-VALUE
+         PCL::|(FAST-METHOD COMPUTE-SLOTS (STD-CLASS))|
+         PCL::ENTRY-IN-CACHE-P
+         PCL::|(FAST-METHOD METHOD-QUALIFIERS (STANDARD-METHOD))|
+         WALKER::WALK-IF PCL::MAKE-METHOD-SPEC PCL::SET-FUNCTION-NAME-1
+         WALKER::WALK-SETQ
+         PCL::|(FAST-METHOD CLASS-SLOT-CELLS (STD-CLASS))|
+         PCL::|(FAST-METHOD GENERIC-FUNCTION-LAMBDA-LIST (GENERIC-FUNCTION))|
+         PCL::DECLARE-STRUCTURE PCL::EMIT-BOUNDP-CHECK
+         WALKER::WALK-LOCALLY
+         PCL::MAKE-OPTIMIZED-STD-SLOT-BOUNDP-USING-CLASS-METHOD-FUNCTION
+         PCL::CAN-OPTIMIZE-ACCESS PCL::|SETF PCL PLIST-VALUE|
+         WALKER::WALK-LABELS PCL::EMIT-1-T-DLAP
+         PCL::|(FAST-METHOD CLASS-DIRECT-SLOTS (BUILT-IN-CLASS))|
+         PCL::|(FAST-METHOD SPECIALIZER-DIRECT-GENERIC-FUNCTIONS (CLASS))|
+         PCL::|(FAST-METHOD COMPUTE-SLOTS (STRUCTURE-CLASS))|
+         PCL::SORT-APPLICABLE-METHODS
+         PCL::|(FAST-METHOD WRAPPER-FETCHER (FUNCALLABLE-STANDARD-CLASS))|
+         WALKER::WALK-NAMED-LAMBDA ITERATE::OPTIMIZE-ITERATE-FORM
+         PCL::MAP-ALL-ORDERS
+         PCL::|(FAST-METHOD CLASS-SLOTS (BUILT-IN-CLASS))|
+         ITERATE::OPTIMIZE-GATHERING-FORM
+         PCL::|(FAST-METHOD CLASS-CONSTRUCTORS (SLOT-CLASS))|
+         PCL::ONE-INDEX-DFUN-INFO
+         PCL::|(FAST-METHOD CLASS-DEFAULT-INITARGS (BUILT-IN-CLASS))|
+         PCL::|(FAST-METHOD COMPUTE-SLOTS :AROUND (STRUCTURE-CLASS))|
+         PCL::FLUSH-CACHE-TRAP WALKER::WALK-PROG*
+         ITERATE::VARIABLE-SAME-P PCL::EMIT-SLOT-READ-FORM
+         PCL::|(FAST-METHOD COMPUTE-SLOTS :AROUND (STD-CLASS))|
+         PCL::EMIT-GREATER-THAN-1-DLAP
+         PCL::|(FAST-METHOD GF-FAST-METHOD-FUNCTION-P (STANDARD-GENERIC-FUNCTION))|
+         PCL::WRAP-METHOD-GROUP-SPECIFIER-BINDINGS WALKER::WALK-LET*
+         WALKER::WALK-SYMBOL-MACROLET WALKER::VARIABLE-DECLARATION
+         PCL::|(FAST-METHOD CLASS-FINALIZED-P (PCL-CLASS))|
+         WALKER::RECONS
+         PCL::|(FAST-METHOD SPECIALIZER-DIRECT-GENERIC-FUNCTIONS (SPECIALIZER-WITH-OBJECT))|
+         PCL::OPTIMIZE-SLOT-VALUE WALKER::RELIST-INTERNAL
+         PCL::MAKE-OPTIMIZED-STD-SLOT-VALUE-USING-CLASS-METHOD-FUNCTION
+         PCL::|(FAST-METHOD SPECIALIZER-METHOD-TABLE (CLASS-EQ-SPECIALIZER))|
+         PCL::|SETF PCL METHOD-FUNCTION-GET| WALKER::WALK-TAGBODY
+         WALKER::WITH-AUGMENTED-ENVIRONMENT-INTERNAL
+         PCL::|(FAST-METHOD SLOTS-FETCHER (STANDARD-CLASS))|
+         PCL::PRINT-CACHE PCL::MAKE-TOP-LEVEL-FORM
+         PCL::FIX-SLOT-ACCESSORS WALKER::WALK-UNEXPECTED-DECLARE
+         PCL::SKIP-OPTIMIZE-SLOT-VALUE-BY-CLASS-P
+         PCL::|(FAST-METHOD CLASS-DIRECT-DEFAULT-INITARGS (SLOT-CLASS))|)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION COMMON-LISP::NIL COMMON-LISP::FIXNUM)
-         PCL::GET-WRAPPER-CACHE-NUMBER)) 
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
+             COMMON-LISP::T)
+         PCL::GET-DECLARATION
+         PCL::MAKE-EFFECTIVE-METHOD-FUNCTION-SIMPLE
+         PCL::EXPAND-EFFECTIVE-METHOD-FUNCTION
+         PCL::GET-METHOD-FUNCTION-PV-CELL
+         PCL::NAMED-OBJECT-PRINT-FUNCTION
+         PCL::FIND-CLASS-PREDICATE-FROM-CELL
+         PCL::GET-EFFECTIVE-METHOD-FUNCTION1 PCL::RECORD-DEFINITION
+         PCL::PROBE-CACHE PCL::INITIALIZE-INFO PCL::EMIT-MISS
+         PCL::REAL-ENSURE-GF-USING-CLASS--GENERIC-FUNCTION
+         PCL::FIND-CLASS-FROM-CELL PCL::PRECOMPUTE-EFFECTIVE-METHODS
+         PCL::COMPUTE-SECONDARY-DISPATCH-FUNCTION1
+         PCL::METHOD-FUNCTION-GET PCL::MAP-CACHE
+         WALKER::CONVERT-MACRO-TO-LAMBDA PCL::MAKE-EMF-FROM-METHOD
+         PCL::ENSURE-GENERIC-FUNCTION-USING-CLASS
+         PCL::REAL-ENSURE-GF-USING-CLASS--NULL)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
-             PCL::NON-NEGATIVE-FIXNUM)
-         PCL::CACHE-NLINES PCL::CACHE-MASK PCL::CACHE-SIZE
-         PCL::CACHE-MAX-LOCATION)) 
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T)
+             COMMON-LISP::T)
+         PCL::MAKE-EFFECTIVE-METHOD-FUNCTION-INTERNAL
+         PCL::BOOTSTRAP-SET-SLOT
+         PCL::|(FAST-METHOD REMOVE-DIRECT-METHOD (CLASS METHOD))|
+         PCL::|(FAST-METHOD REMOVE-DIRECT-METHOD (SPECIALIZER-WITH-OBJECT METHOD))|
+         PCL::|(FAST-METHOD PRINT-OBJECT (T T))|
+         PCL::|(FAST-METHOD MAKE-READER-METHOD-FUNCTION (FUNCALLABLE-STANDARD-CLASS T))|
+         WALKER::WALK-TEMPLATE
+         PCL::|(FAST-METHOD ALLOCATE-INSTANCE (STANDARD-CLASS))|
+         PCL::|(FAST-METHOD MAKE-WRITER-METHOD-FUNCTION (FUNCALLABLE-STANDARD-CLASS T))|
+         PCL::|(FAST-METHOD VALIDATE-SUPERCLASS (CLASS BUILT-IN-CLASS))|
+         PCL::|(FAST-METHOD SAME-SPECIALIZER-P (CLASS CLASS))|
+         PCL::|(FAST-METHOD INFORM-TYPE-SYSTEM-ABOUT-CLASS (STRUCTURE-CLASS T))|
+         PCL::|(FAST-METHOD LEGAL-SLOT-NAME-P (STANDARD-METHOD T))|
+         PCL::|(FAST-METHOD PRINT-OBJECT (GENERIC-FUNCTION T))|
+         PCL::|(FAST-METHOD PRINT-OBJECT (STANDARD-METHOD T))|
+         PCL::OPTIMIZE-WRITER
+         PCL::|(FAST-METHOD ADD-DIRECT-METHOD (SPECIALIZER-WITH-OBJECT METHOD))|
+         PCL::|(FAST-METHOD COMPUTE-EFFECTIVE-SLOT-DEFINITION-INITARGS :AROUND (STRUCTURE-CLASS T))|
+         PCL::|(FAST-METHOD VALIDATE-SUPERCLASS (FUNCALLABLE-STANDARD-CLASS STANDARD-CLASS))|
+         PCL::|(FAST-METHOD DOCUMENTATION (T))|
+         PCL::|(FAST-METHOD LEGAL-LAMBDA-LIST-P (STANDARD-METHOD T))|
+         PCL::|(FAST-METHOD PRINT-OBJECT (SLOT-DEFINITION T))|
+         PCL::|(FAST-METHOD REINITIALIZE-INSTANCE (STANDARD-METHOD))|
+         PCL::|(FAST-METHOD COMPUTE-APPLICABLE-METHODS (GENERIC-FUNCTION T))|
+         PCL::MAKE-EFFECTIVE-METHOD-FUNCTION1
+         PCL::|(FAST-METHOD MAKE-BOUNDP-METHOD-FUNCTION (SLOT-CLASS T))|
+         PCL::|(FAST-METHOD VALIDATE-SUPERCLASS (CLASS CLASS))|
+         PCL::LOAD-PRECOMPILED-IIS-ENTRY PCL::ADJUST-CACHE
+         WALKER::WALK-PROG/PROG*
+         PCL::|(FAST-METHOD PRINT-OBJECT (STANDARD-METHOD-COMBINATION T))|
+         PCL::|(FAST-METHOD REMOVE-READER-METHOD (SLOT-CLASS T))|
+         PCL::OPTIMIZE-READER
+         PCL::|(FAST-METHOD DIRECT-SLOT-DEFINITION-CLASS (STD-CLASS T))|
+         PCL::|(FAST-METHOD REMOVE-DIRECT-SUBCLASS (CLASS CLASS))|
+         WALKER::WALK-BINDINGS-2 PCL::MEMF-TEST-CONVERTER
+         PCL::|(FAST-METHOD SAME-SPECIALIZER-P (CLASS-EQ-SPECIALIZER CLASS-EQ-SPECIALIZER))|
+         PCL::|(FAST-METHOD LEGAL-QUALIFIER-P (STANDARD-METHOD T))|
+         PCL::|(FAST-METHOD INITIALIZE-INSTANCE :AFTER (STANDARD-GENERIC-FUNCTION))|
+         PCL::LOAD-PRECOMPILED-DFUN-CONSTRUCTOR
+         PCL::|(FAST-METHOD UPDATE-GF-DFUN (STD-CLASS T))|
+         PCL::|(FAST-METHOD SAME-SPECIALIZER-P (EQL-SPECIALIZER EQL-SPECIALIZER))|
+         PCL::|(FAST-METHOD LEGAL-METHOD-FUNCTION-P (STANDARD-METHOD T))|
+         PCL::MAKE-DISPATCH-LAMBDA
+         PCL::|(FAST-METHOD ADD-DIRECT-SUBCLASS (CLASS CLASS))|
+         PCL::|(FAST-METHOD EFFECTIVE-SLOT-DEFINITION-CLASS (STD-CLASS T))|
+         PCL::|(FAST-METHOD EFFECTIVE-SLOT-DEFINITION-CLASS (STRUCTURE-CLASS T))|
+         PCL::|(FAST-METHOD REMOVE-DEPENDENT (DEPENDENT-UPDATE-MIXIN T))|
+         PCL::|(FAST-METHOD ADD-DEPENDENT (DEPENDENT-UPDATE-MIXIN T))|
+         WALKER::WALK-DO/DO* PCL::MAKE-EFFECTIVE-METHOD-FUNCTION-TYPE
+         PCL::|(FAST-METHOD REMOVE-WRITER-METHOD (SLOT-CLASS T))|
+         PCL::|(FAST-METHOD COMPUTE-EFFECTIVE-SLOT-DEFINITION-INITARGS (SLOT-CLASS T))|
+         PCL::GET-WRAPPERS-FROM-CLASSES
+         PCL::|(FAST-METHOD MAKE-READER-METHOD-FUNCTION (SLOT-CLASS T))|
+         PCL::EXPAND-CACHE
+         PCL::|(FAST-METHOD SAME-SPECIALIZER-P (SPECIALIZER SPECIALIZER))|
+         PCL::|(FAST-METHOD CHANGE-CLASS (STANDARD-OBJECT STANDARD-CLASS))|
+         PCL::|(FAST-METHOD LEGAL-DOCUMENTATION-P (STANDARD-METHOD T))|
+         PCL::|(FAST-METHOD SLOT-ACCESSOR-STD-P (EFFECTIVE-SLOT-DEFINITION T))|
+         PCL::|(FAST-METHOD REINITIALIZE-INSTANCE :BEFORE (SLOT-CLASS))|
+         PCL::EXPAND-SYMBOL-MACROLET-INTERNAL
+         PCL::|(FAST-METHOD REINITIALIZE-INSTANCE :AFTER (STANDARD-GENERIC-FUNCTION))|
+         PCL::|(FAST-METHOD PRINT-OBJECT (STANDARD-ACCESSOR-METHOD T))|
+         PCL::|(FAST-METHOD MAKE-INSTANCE (CLASS))|
+         WALKER::WALK-LET/LET*
+         PCL::|(FAST-METHOD LEGAL-SPECIALIZER-P (STANDARD-METHOD T))|
+         PCL::|(FAST-METHOD MAKE-WRITER-METHOD-FUNCTION (SLOT-CLASS T))|
+         PCL::|(FAST-METHOD COMPATIBLE-META-CLASS-CHANGE-P (T T))|
+         PCL::|(FAST-METHOD DIRECT-SLOT-DEFINITION-CLASS (STRUCTURE-CLASS T))|
+         PCL::|(FAST-METHOD MAP-DEPENDENTS (DEPENDENT-UPDATE-MIXIN T))|
+         PCL::|(FAST-METHOD PRINT-OBJECT (CLASS T))|
+         PCL::|(FAST-METHOD REMOVE-BOUNDP-METHOD (SLOT-CLASS T))|
+         PCL::EXPAND-DEFCLASS PCL::INITIALIZE-INSTANCE-SIMPLE
+         PCL::|(FAST-METHOD REINITIALIZE-INSTANCE (SLOT-OBJECT))|
+         PCL::|(FAST-METHOD DOCUMENTATION (DOCUMENTATION-MIXIN))|
+         PCL::MAYBE-EXPAND-ACCESSOR-FORM
+         PCL::|(FAST-METHOD INFORM-TYPE-SYSTEM-ABOUT-CLASS (STD-CLASS T))|
+         PCL::FILL-CACHE-P
+         PCL::|(FAST-METHOD ALLOCATE-INSTANCE (FUNCALLABLE-STANDARD-CLASS))|
+         PCL::|(FAST-METHOD ADD-DIRECT-METHOD (CLASS METHOD))|
+         PCL::|(FAST-METHOD CHANGE-CLASS (STANDARD-OBJECT FUNCALLABLE-STANDARD-CLASS))|
+         PCL::|(FAST-METHOD VALIDATE-SUPERCLASS (SLOT-CLASS FORWARD-REFERENCED-CLASS))|
+         PCL::EMIT-CHECKING-OR-CACHING-FUNCTION-PRELIMINARY
+         PCL::TWO-CLASS-DFUN-INFO)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
-             COMMON-LISP::SIMPLE-VECTOR)
-         PCL::CACHE-VECTOR)) 
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::T)
+             COMMON-LISP::T)
+         PCL::EXPAND-EMF-CALL-METHOD
+         PCL::|(FAST-METHOD ENSURE-CLASS-USING-CLASS (T PCL-CLASS))|
+         PCL::BOOTSTRAP-MAKE-SLOT-DEFINITIONS
+         PCL::|(FAST-METHOD FIND-METHOD-COMBINATION (GENERIC-FUNCTION (EQL STANDARD) T))|
+         PCL::MAKE-INSTANCE-FUNCTION-COMPLEX
+         PCL::|(FAST-METHOD ENSURE-CLASS-USING-CLASS (T NULL))|
+         PCL::|(FAST-METHOD SHARED-INITIALIZE :BEFORE (STANDARD-ACCESSOR-METHOD T))|
+         PCL::UPDATE-SLOTS-IN-PV
+         PCL::|(FAST-METHOD SLOT-BOUNDP-USING-CLASS (STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
+         PCL::|(FAST-METHOD SLOT-UNBOUND (T T T))|
+         PCL::MAKE-PARAMETER-REFERENCES
+         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (DOCUMENTATION-MIXIN T))|
+         PCL::BOOTSTRAP-ACCESSOR-DEFINITIONS1
+         PCL::OPTIMIZE-INSTANCE-ACCESS PCL::OPTIMIZE-ACCESSOR-CALL
+         PCL::OPTIMIZE-GENERIC-FUNCTION-CALL
+         PCL::REAL-MAKE-METHOD-INITARGS-FORM
+         PCL::|(FAST-METHOD REMOVE-NAMED-METHOD (T T))|
+         PCL::|(FAST-METHOD WRITER-METHOD-CLASS (SLOT-CLASS T))|
+         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (STRUCTURE-CLASS T))|
+         PCL::|(FAST-METHOD SLOT-BOUNDP-USING-CLASS (STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
+         PCL::|(FAST-METHOD (SETF DOCUMENTATION) (T DOCUMENTATION-MIXIN))|
+         PCL::COMPUTE-PV-SLOT PCL::MAKE-METHOD-INITARGS-FORM-INTERNAL1
+         PCL::LOAD-FUNCTION-GENERATOR
+         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (STRUCTURE-SLOT-DEFINITION T))|
+         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (STANDARD-METHOD T))|
+         PCL::|(FAST-METHOD COMPUTE-SLOT-ACCESSOR-INFO (EFFECTIVE-SLOT-DEFINITION T T))|
+         PCL::|(FAST-METHOD COMPUTE-EFFECTIVE-METHOD (GENERIC-FUNCTION SHORT-METHOD-COMBINATION T))|
+         PCL::|(FAST-METHOD SLOT-MAKUNBOUND-USING-CLASS (STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
+         PCL::GET-MAKE-INSTANCE-FUNCTION-INTERNAL
+         PCL::|(FAST-METHOD READER-METHOD-CLASS (SLOT-CLASS T))|
+         PCL::|(FAST-METHOD (SETF DOCUMENTATION) (T T))|
+         PCL::MAKE-FINAL-ORDINARY-DFUN-INTERNAL
+         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (STD-CLASS T))|
+         WALKER::WALK-BINDINGS-1 PCL::MAKE-INSTANCE-FUNCTION-SIMPLE
+         PCL::MAKE-FGEN WALKER::WALK-TEMPLATE-HANDLE-REPEAT
+         PCL::|(FAST-METHOD SLOT-MAKUNBOUND-USING-CLASS (STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
+         PCL::|(FAST-METHOD SHARED-INITIALIZE :BEFORE (BUILT-IN-CLASS T))|
+         PCL::|(FAST-METHOD (SETF SLOT-ACCESSOR-STD-P) (T EFFECTIVE-SLOT-DEFINITION T))|
+         PCL::MAKE-EMF-CACHE)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::*)
+             COMMON-LISP::T)
+         PCL::BOOTSTRAP-INITIALIZE-CLASS)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
+             COMMON-LISP::T)
+         PCL::REAL-LOAD-DEFCLASS PCL::LOAD-DEFCLASS
+         PCL::OPTIMIZE-GF-CALL PCL::MAKE-EARLY-CLASS-DEFINITION
+         WALKER::WALK-TEMPLATE-HANDLE-REPEAT-1 PCL::EMIT-SLOT-ACCESS
+         PCL::BOOTSTRAP-MAKE-SLOT-DEFINITION
+         PCL::|(FAST-METHOD (SETF SLOT-VALUE-USING-CLASS) (T STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
+         PCL::SET-ARG-INFO1)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::*)
+             COMMON-LISP::T)
+         PCL::FILL-CACHE PCL::REAL-GET-METHOD PCL::MAKE-EMF-CALL
+         PCL::EMIT-FETCH-WRAPPER PCL::CHECK-INITARGS-1
+         PCL::CAN-OPTIMIZE-ACCESS1 PCL::CHECK-INITARGS-2-PLIST
+         PCL::CHECK-INITARGS-2-LIST WALKER::WALK-ARGLIST
+         PCL::GET-METHOD)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
+             COMMON-LISP::T)
+         PCL::GET-SECONDARY-DISPATCH-FUNCTION1 PCL::EMIT-DLAP)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::*)
+             COMMON-LISP::T)
+         PCL::FILL-DFUN-CACHE PCL::EARLY-ADD-NAMED-METHOD
+         PCL::REAL-ADD-NAMED-METHOD)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
              COMMON-LISP::*)
-         PCL::ACCESSOR-VALUES-INTERNAL
+         PCL::ACCESSOR-VALUES1 PCL::CHECK-METHOD-ARG-INFO
+         PCL::EMIT-READER/WRITER PCL::OPTIMIZE-SLOT-VALUE-BY-CLASS-P
+         PCL::|(FAST-METHOD FUNCTION-KEYWORDS (STANDARD-METHOD))|
+         PCL::EMIT-ONE-OR-N-INDEX-READER/WRITER-FUNCTION
+         PCL::CACHE-MISS-VALUES
+         PCL::GET-OPTIMIZED-STD-SLOT-VALUE-USING-CLASS-METHOD-FUNCTION
+         PCL::MAKE-FINAL-CACHING-DFUN
          PCL::MAKE-OPTIMIZED-STD-READER-METHOD-FUNCTION
+         PCL::|(FAST-METHOD COMPUTE-DISCRIMINATING-FUNCTION (STANDARD-GENERIC-FUNCTION))|
+         PCL::MAKE-FINAL-CONSTANT-VALUE-DFUN
+         PCL::|(FAST-METHOD METHOD-FUNCTION (STANDARD-METHOD))|
          PCL::|(FAST-METHOD METHOD-SPECIALIZERS (TRACED-METHOD))|
-         PCL::MAKE-FINAL-N-N-ACCESSOR-DFUN
-         PCL::|(FAST-METHOD ACCESSOR-METHOD-SLOT-NAME (TRACED-METHOD))|
-         PCL::CHECK-METHOD-ARG-INFO
-         PCL::|(FAST-METHOD COMPUTE-DISCRIMINATING-FUNCTION-ARGLIST-INFO (STANDARD-GENERIC-FUNCTION))|
-         PCL::GET-OPTIMIZED-STD-ACCESSOR-METHOD-FUNCTION
-         PCL::GET-OPTIMIZED-STD-SLOT-VALUE-USING-CLASS-METHOD-FUNCTION
-         PCL::|(FAST-METHOD CLASS-PROTOTYPE (STD-CLASS))|
+         PCL::ACCESSOR-VALUES-INTERNAL ITERATE::EXPAND-INTO-LET
          PCL::MAKE-OPTIMIZED-STD-BOUNDP-METHOD-FUNCTION
-         PCL::OPTIMIZE-SLOT-VALUE-BY-CLASS-P
-         ITERATE::WALK-GATHERING-BODY
+         PCL::CONSTANT-VALUE-MISS
+         PCL::GET-OPTIMIZED-STD-ACCESSOR-METHOD-FUNCTION
+         WALKER::WALK-LET-IF ITERATE::WALK-GATHERING-BODY
          PCL::EMIT-ONE-OR-N-INDEX-READER/WRITER
-         PCL::|(FAST-METHOD METHOD-FUNCTION (STANDARD-METHOD))|
-         PCL::SLOT-BOUNDP-USING-CLASS-DFUN WALKER::WALK-FORM-INTERNAL
-         PCL::LOAD-LONG-DEFCOMBIN PCL::MAKE-FINAL-CACHING-DFUN
-         PCL::EMIT-READER/WRITER
-         PCL::EMIT-ONE-OR-N-INDEX-READER/WRITER-FUNCTION
-         PCL::SLOT-VALUE-USING-CLASS-DFUN PCL::CACHING-MISS
-         PCL::|(FAST-METHOD METHOD-LAMBDA-LIST (TRACED-METHOD))|
-         PCL::EMIT-READER/WRITER-FUNCTION PCL::ACCESSOR-VALUES1
-         PCL::GENERATING-LISP PCL::GET-CLASS-SLOT-VALUE-1
-         PCL::MAKE-FINAL-CONSTANT-VALUE-DFUN PCL::CACHE-MISS-VALUES
-         WALKER::WALK-LET-IF
          PCL::|(FAST-METHOD CLASS-PROTOTYPE (STRUCTURE-CLASS))|
-         PCL::|(FAST-METHOD METHOD-QUALIFIERS (TRACED-METHOD))|
-         PCL::CHECKING-MISS ITERATE::EXPAND-INTO-LET
+         PCL::CHECKING-MISS PCL::MAKE-FINAL-N-N-ACCESSOR-DFUN
+         PCL::GENERATING-LISP ITERATE::RENAME-VARIABLES
+         PCL::|(FAST-METHOD METHOD-LAMBDA-LIST (TRACED-METHOD))|
+         PCL::CONVERT-METHODS PCL::SLOT-VALUE-USING-CLASS-DFUN
+         PCL::EMIT-READER/WRITER-FUNCTION
+         PCL::|(FAST-METHOD MAKE-INSTANCES-OBSOLETE (SYMBOL))|
+         PCL::|(FAST-METHOD COMPUTE-DISCRIMINATING-FUNCTION-ARGLIST-INFO (STANDARD-GENERIC-FUNCTION))|
+         PCL::CACHING-MISS
          PCL::MAKE-OPTIMIZED-STD-WRITER-METHOD-FUNCTION
-         PCL::CONSTANT-VALUE-MISS ITERATE::RENAME-VARIABLES
-         PCL::|(FAST-METHOD FUNCTION-KEYWORDS (STANDARD-METHOD))|
+         PCL::GET-CLASS-SLOT-VALUE-1 WALKER::WALK-FORM-INTERNAL
+         PCL::SLOT-BOUNDP-USING-CLASS-DFUN PCL::LOAD-LONG-DEFCOMBIN
+         PCL::|(FAST-METHOD CLASS-PROTOTYPE (STD-CLASS))|
+         PCL::|(FAST-METHOD METHOD-QUALIFIERS (TRACED-METHOD))|
          PCL::SET-SLOT-VALUE
-         PCL::|(FAST-METHOD COMPUTE-DISCRIMINATING-FUNCTION (STANDARD-GENERIC-FUNCTION))|
-         PCL::|(FAST-METHOD MAKE-INSTANCES-OBSOLETE (SYMBOL))|
          PCL::|(FAST-METHOD METHOD-PRETTY-ARGLIST (STANDARD-METHOD))|
-         PCL::CONVERT-METHODS)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T)
-             COMMON-LISP::*)
-         PCL::|(FAST-METHOD ADD-READER-METHOD (SLOT-CLASS T T))|
-         PCL::|(FAST-METHOD UPDATE-INSTANCE-FOR-DIFFERENT-CLASS (STANDARD-OBJECT STANDARD-OBJECT))|
-         PCL::|(FAST-METHOD COMPUTE-EFFECTIVE-METHOD (GENERIC-FUNCTION LONG-METHOD-COMBINATION T))|
-         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (CLASS-EQ-SPECIALIZER T))|
-         PCL::|(FAST-METHOD SLOT-VALUE-USING-CLASS (STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
-         PCL::|(FAST-METHOD ADD-WRITER-METHOD (SLOT-CLASS T T))|
-         PCL::|(FAST-METHOD ADD-BOUNDP-METHOD (SLOT-CLASS T T))|
-         PCL::MAKE-TWO-CLASS-ACCESSOR-DFUN
-         PCL::|(FAST-METHOD (SETF DOCUMENTATION) (T STANDARD-SLOT-DEFINITION))|
-         PCL::|(FAST-METHOD SHARED-INITIALIZE (SLOT-OBJECT T))|
-         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (EQL-SPECIALIZER T))|
-         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (STANDARD-ACCESSOR-METHOD T))|
-         PCL::|(FAST-METHOD (SETF SLOT-ACCESSOR-FUNCTION) (T EFFECTIVE-SLOT-DEFINITION T))|
-         PCL::ADD-METHOD-DECLARATIONS
-         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (STANDARD-SLOT-DEFINITION T))|
-         PCL::|(FAST-METHOD (SETF CLASS-SLOT-VALUE) (T STD-CLASS T))|
-         PCL::WALK-METHOD-LAMBDA
-         PCL::|(FAST-METHOD SLOT-VALUE-USING-CLASS (STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
-         PCL::COMPUTE-DISCRIMINATING-FUNCTION-ARGLIST-INFO-INTERNAL
-         PCL::|(FAST-METHOD SHARED-INITIALIZE :BEFORE (CLASS T))|
-         PCL::|(FAST-METHOD SHARED-INITIALIZE :BEFORE (STANDARD-METHOD T))|
-         PCL::|(FAST-METHOD SHARED-INITIALIZE :BEFORE (STANDARD-GENERIC-FUNCTION T))|)) 
+         PCL::|(FAST-METHOD ACCESSOR-METHOD-SLOT-NAME (TRACED-METHOD))|)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
                  COMMON-LISP::T)
              COMMON-LISP::*)
-         PCL::GET-ACCESSOR-METHOD-FUNCTION
-         PCL::|(FAST-METHOD LEGAL-SPECIALIZERS-P (STANDARD-METHOD T))|
+         PCL::SETF-SLOT-VALUE-USING-CLASS-DFUN
+         PCL::|(FAST-METHOD DESCRIBE-OBJECT (SLOT-OBJECT T))|
+         PCL::ORDER-SPECIALIZERS
+         PCL::|(FAST-METHOD DESCRIBE-OBJECT (STANDARD-GENERIC-FUNCTION T))|
+         PCL::EMIT-CHECKING-OR-CACHING
+         PCL::|(FAST-METHOD REINITIALIZE-INSTANCE :AFTER (SLOT-CLASS))|
+         PCL::|(FAST-METHOD MAKE-INSTANCE (SYMBOL))|
          PCL::|(FAST-METHOD LEGAL-QUALIFIERS-P (STANDARD-METHOD T))|
+         PCL::GENERATE-DISCRIMINATION-NET
+         PCL::|(FAST-METHOD CHANGE-CLASS (T SYMBOL))|
          PCL::|(FAST-METHOD ALLOCATE-INSTANCE (STRUCTURE-CLASS))|
-         PCL::MAKE-ONE-CLASS-ACCESSOR-DFUN
+         PCL::|(FAST-METHOD SLOT-ACCESSOR-FUNCTION (EFFECTIVE-SLOT-DEFINITION T))|
+         PCL::GET-ACCESSOR-METHOD-FUNCTION
          PCL::|(FAST-METHOD CLASS-SLOT-VALUE (STD-CLASS T))|
-         PCL::GENERATE-DISCRIMINATION-NET
          PCL::|(FAST-METHOD DESCRIBE-OBJECT (CLASS T))|
-         PCL::LOAD-SHORT-DEFCOMBIN
-         PCL::|(FAST-METHOD REINITIALIZE-INSTANCE :AFTER (SLOT-CLASS))|
-         PCL::|(FAST-METHOD SLOT-ACCESSOR-FUNCTION (EFFECTIVE-SLOT-DEFINITION T))|
-         PCL::REAL-MAKE-METHOD-LAMBDA PCL::SET-CLASS-SLOT-VALUE-1
-         PCL::BOOTSTRAP-ACCESSOR-DEFINITION
          PCL::MAKE-FINAL-ONE-INDEX-ACCESSOR-DFUN
-         PCL::|(FAST-METHOD COMPUTE-EFFECTIVE-SLOT-DEFINITION (SLOT-CLASS T))|
-         PCL::ACCESSOR-MISS PCL::|(FAST-METHOD MAKE-INSTANCE (SYMBOL))|
-         PCL::ACCESSOR-VALUES
+         PCL::EMIT-CHECKING-OR-CACHING-FUNCTION PCL::ACCESSOR-MISS
+         PCL::|(FAST-METHOD LEGAL-SPECIALIZERS-P (STANDARD-METHOD T))|
+         PCL::LOAD-SHORT-DEFCOMBIN PCL::MAKE-FINAL-CHECKING-DFUN
+         PCL::|(FAST-METHOD DEFAULT-INITARGS (SLOT-CLASS T))|
+         PCL::MAKE-SHARED-INITIALIZE-FORM-LIST
          PCL::|(FAST-METHOD DESCRIBE-OBJECT (T T))|
-         PCL::|(FAST-METHOD DOCUMENTATION (STANDARD-SLOT-DEFINITION))|
-         PCL::EMIT-CHECKING-OR-CACHING-FUNCTION
          PCL::INITIALIZE-INSTANCE-SIMPLE-FUNCTION
-         PCL::MAKE-FINAL-CHECKING-DFUN
-         PCL::MAKE-SHARED-INITIALIZE-FORM-LIST
-         PCL::|(FAST-METHOD DEFAULT-INITARGS (SLOT-CLASS T))|
-         PCL::EMIT-CHECKING-OR-CACHING
-         PCL::|(FAST-METHOD CHANGE-CLASS (T SYMBOL))|
-         PCL::|(FAST-METHOD DESCRIBE-OBJECT (STANDARD-GENERIC-FUNCTION T))|
-         PCL::|(FAST-METHOD DESCRIBE-OBJECT (SLOT-OBJECT T))|
          PCL::|(FAST-METHOD SLOTS-TO-INSPECT (SLOT-CLASS SLOT-OBJECT))|
-         PCL::SETF-SLOT-VALUE-USING-CLASS-DFUN
+         PCL::ACCESSOR-VALUES PCL::REAL-MAKE-METHOD-LAMBDA
+         PCL::|(FAST-METHOD COMPUTE-APPLICABLE-METHODS-USING-CLASSES (GENERIC-FUNCTION T))|
+         PCL::|(FAST-METHOD COMPUTE-EFFECTIVE-SLOT-DEFINITION (SLOT-CLASS T))|
+         PCL::|(FAST-METHOD INITIALIZE-INSTANCE (SLOT-OBJECT))|
+         PCL::BOOTSTRAP-ACCESSOR-DEFINITION
+         PCL::|(FAST-METHOD DOCUMENTATION (STANDARD-SLOT-DEFINITION))|
+         PCL::MAKE-ONE-CLASS-ACCESSOR-DFUN
          PCL::GET-ACCESSOR-FROM-SVUC-METHOD-FUNCTION
          PCL::|(FAST-METHOD NO-APPLICABLE-METHOD (T))|
-         PCL::ORDER-SPECIALIZERS
-         PCL::|(FAST-METHOD COMPUTE-APPLICABLE-METHODS-USING-CLASSES (GENERIC-FUNCTION T))|
-         PCL::|(FAST-METHOD INITIALIZE-INSTANCE (SLOT-OBJECT))|)) 
+         PCL::SET-CLASS-SLOT-VALUE-1)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::T)
              COMMON-LISP::*)
-         PCL::MAKE-N-N-ACCESSOR-DFUN
-         PCL::GET-SIMPLE-INITIALIZATION-FUNCTION
-         PCL::MAKE-FINAL-ACCESSOR-DFUN
-         PCL::GET-EFFECTIVE-METHOD-FUNCTION PCL::MAKE-ACCESSOR-TABLE
-         PCL::MAKE-EFFECTIVE-METHOD-FUNCTION PCL::MAKE-CHECKING-DFUN
-         PCL::GET-COMPLEX-INITIALIZATION-FUNCTIONS
-         PCL::MAKE-DEFAULT-INITARGS-FORM-LIST PCL::REAL-ADD-METHOD
-         PCL::SLOT-VALUE-OR-DEFAULT PCL::LOAD-DEFGENERIC PCL::CPL-ERROR
-         WALKER::NESTED-WALK-FORM PCL::TYPES-FROM-ARGUMENTS
-         PCL::COMPUTE-SECONDARY-DISPATCH-FUNCTION)) 
+         PCL::|(FAST-METHOD SLOT-VALUE-USING-CLASS (STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
+         PCL::|(FAST-METHOD SHARED-INITIALIZE :BEFORE (STANDARD-GENERIC-FUNCTION T))|
+         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (EQL-SPECIALIZER T))|
+         PCL::|(FAST-METHOD ADD-WRITER-METHOD (SLOT-CLASS T T))|
+         PCL::|(FAST-METHOD (SETF DOCUMENTATION) (T STANDARD-SLOT-DEFINITION))|
+         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (CLASS-EQ-SPECIALIZER T))|
+         PCL::|(FAST-METHOD SLOT-VALUE-USING-CLASS (STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
+         PCL::WALK-METHOD-LAMBDA
+         PCL::|(FAST-METHOD COMPUTE-EFFECTIVE-METHOD (GENERIC-FUNCTION LONG-METHOD-COMBINATION T))|
+         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (STANDARD-SLOT-DEFINITION T))|
+         PCL::COMPUTE-DISCRIMINATING-FUNCTION-ARGLIST-INFO-INTERNAL
+         PCL::|(FAST-METHOD UPDATE-INSTANCE-FOR-DIFFERENT-CLASS (STANDARD-OBJECT STANDARD-OBJECT))|
+         PCL::|(FAST-METHOD (SETF CLASS-SLOT-VALUE) (T STD-CLASS T))|
+         PCL::|(FAST-METHOD SHARED-INITIALIZE (SLOT-OBJECT T))|
+         PCL::MAKE-TWO-CLASS-ACCESSOR-DFUN
+         PCL::|(FAST-METHOD ADD-BOUNDP-METHOD (SLOT-CLASS T T))|
+         PCL::|(FAST-METHOD SHARED-INITIALIZE :BEFORE (STANDARD-METHOD T))|
+         PCL::|(FAST-METHOD (SETF SLOT-ACCESSOR-FUNCTION) (T EFFECTIVE-SLOT-DEFINITION T))|
+         PCL::|(FAST-METHOD ADD-READER-METHOD (SLOT-CLASS T T))|
+         PCL::|(FAST-METHOD SHARED-INITIALIZE :BEFORE (CLASS T))|
+         PCL::ADD-METHOD-DECLARATIONS
+         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (STANDARD-ACCESSOR-METHOD T))|)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::LIST)
+         PCL::PV-TABLE-CALL-LIST PCL::CACHE-OVERFLOW
+         PCL::PV-TABLE-SLOT-NAME-LISTS)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
              COMMON-LISP::*)
-         PCL::MAKE-LONG-METHOD-COMBINATION-FUNCTION
-         PCL::GENERATE-DISCRIMINATION-NET-INTERNAL
-         PCL::CACHE-MISS-VALUES-INTERNAL
-         PCL::|(FAST-METHOD (SETF SLOT-VALUE-USING-CLASS) (T STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
-         PCL::DO-SHORT-METHOD-COMBINATION PCL::MEMF-CODE-CONVERTER)) 
+         PCL::MAKE-DEFAULT-INITARGS-FORM-LIST
+         PCL::GET-EFFECTIVE-METHOD-FUNCTION PCL::LOAD-DEFGENERIC
+         PCL::GET-COMPLEX-INITIALIZATION-FUNCTIONS
+         PCL::COMPUTE-SECONDARY-DISPATCH-FUNCTION
+         PCL::SLOT-VALUE-OR-DEFAULT PCL::MAKE-CHECKING-DFUN
+         PCL::MAKE-FINAL-ACCESSOR-DFUN WALKER::NESTED-WALK-FORM
+         PCL::MAKE-ACCESSOR-TABLE PCL::REAL-ADD-METHOD
+         PCL::TYPES-FROM-ARGUMENTS
+         PCL::GET-SIMPLE-INITIALIZATION-FUNCTION PCL::CPL-ERROR
+         PCL::MAKE-EFFECTIVE-METHOD-FUNCTION
+         PCL::MAKE-N-N-ACCESSOR-DFUN)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
                  COMMON-LISP::*)
              COMMON-LISP::*)
-         PCL::MAKE-ONE-INDEX-ACCESSOR-DFUN WALKER::WALK-DECLARATIONS
-         PCL::GET-SECONDARY-DISPATCH-FUNCTION)) 
+         PCL::REAL-MAKE-A-METHOD)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
                  COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
                  COMMON-LISP::T)
-             COMMON-LISP::*)
-         PCL::|(FAST-METHOD SLOT-MISSING (T T T T))|
-         PCL::|(FAST-METHOD UPDATE-INSTANCE-FOR-REDEFINED-CLASS (STANDARD-OBJECT T T T))|
-         ITERATE::ITERATE-TRANSFORM-BODY)) 
+             COMMON-LISP::T)
+         PCL::LOAD-DEFMETHOD-INTERNAL PCL::EXPAND-DEFMETHOD)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::*)
-             COMMON-LISP::*)
-         ITERATE::RENAME-LET-BINDINGS
-         PCL::MAKE-EFFECTIVE-METHOD-FUNCTION-SIMPLE1)) 
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::*)
+             COMMON-LISP::T)
+         PCL::EARLY-MAKE-A-METHOD PCL::LOAD-DEFMETHOD
+         PCL::MAKE-DEFMETHOD-FORM PCL::MAKE-DEFMETHOD-FORM-INTERNAL)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::*)
+                 COMMON-LISP::T COMMON-LISP::*)
              COMMON-LISP::*)
-         PCL::REAL-MAKE-A-METHOD)) 
-(COMMON-LISP::MAPC
-    (COMMON-LISP::LAMBDA (COMPILER::X)
-      (COMMON-LISP::SETF
-          (COMMON-LISP::GET COMPILER::X 'COMPILER::PROCLAIMED-CLOSURE)
-          COMMON-LISP::T))
-    '(PCL::REDEFINE-FUNCTION PCL::DO-STANDARD-DEFSETF-1
-         PCL::TRACE-METHOD-INTERNAL PCL::FDEFINE-CAREFULLY)) 
+         PCL::MAKE-EFFECTIVE-METHOD-FUNCTION-SIMPLE1
+         ITERATE::RENAME-LET-BINDINGS)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::*)
-         PCL::ANALYZE-LAMBDA-LIST PCL::GET-DISPATCH-FUNCTION
-         PCL::PARSE-DEFMETHOD PCL::MAKE-DISPATCH-DFUN
-         PCL::EMIT-IN-CHECKING-CACHE-P PCL::EMIT-ONE-INDEX-READERS
-         PCL::METHOD-PROTOTYPE-FOR-GF PCL::EMIT-ONE-CLASS-READER
-         PCL::GENERIC-FUNCTION-NAME-P PCL::DEFAULT-CODE-CONVERTER
-         PCL::CLASS-EQ-TYPE PCL::CONVERT-TO-SYSTEM-TYPE
-         PCL::COMPILE-IIS-FUNCTIONS PCL::EMIT-CONSTANT-VALUE
-         PCL::GET-GENERIC-FUNCTION-INFO PCL::EARLY-METHOD-FUNCTION
-         PCL::FIND-STRUCTURE-CLASS PCL::PCL-DESCRIBE
-         PCL::NET-CODE-CONVERTER PCL::PARSE-METHOD-GROUP-SPECIFIER
-         PCL::TYPE-FROM-SPECIALIZER PCL::EMIT-TWO-CLASS-WRITER
-         PCL::COMPUTE-APPLICABLE-METHODS-EMF PCL::EMIT-ONE-CLASS-WRITER
-         PCL::PROTOTYPES-FOR-MAKE-METHOD-LAMBDA
-         PCL::SPECIALIZER-FROM-TYPE PCL::EARLY-COLLECT-INHERITANCE
-         PCL::EMIT-TWO-CLASS-READER PCL::FIND-WRAPPER
-         PCL::*NORMALIZE-TYPE PCL::EMIT-ONE-INDEX-WRITERS
-         PCL::STRUCTURE-WRAPPER PCL::MAKE-FINAL-DISPATCH-DFUN)) 
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
+             COMMON-LISP::*)
+         PCL::DO-SHORT-METHOD-COMBINATION
+         PCL::GENERATE-DISCRIMINATION-NET-INTERNAL
+         PCL::CACHE-MISS-VALUES-INTERNAL
+         PCL::|(FAST-METHOD (SETF SLOT-VALUE-USING-CLASS) (T STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
+         PCL::MEMF-CODE-CONVERTER
+         PCL::MAKE-LONG-METHOD-COMBINATION-FUNCTION)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::*) COMMON-LISP::T)
-         PCL::|__si::MAKE-INITIAL| PCL::|__si::MAKE-ARG-INFO|
-         PCL::STRING-APPEND PCL::|__si::MAKE-ONE-INDEX|
-         PCL::MAKE-INITIALIZE-INFO PCL::MAKE-FAST-METHOD-CALL
-         PCL::|__si::MAKE-STD-INSTANCE|
-         PCL::|__si::MAKE-ONE-INDEX-DFUN-INFO|
-         PCL::|__si::MAKE-CONSTANT-VALUE| PCL::|__si::MAKE-N-N|
-         PCL::FIX-EARLY-GENERIC-FUNCTIONS PCL::INTERN-PV-TABLE
-         PCL::FALSE PCL::|__si::MAKE-DFUN-INFO|
-         PCL::|__si::MAKE-CACHING| PCL::MAKE-PV-TABLE
-         PCL::MAKE-METHOD-CALL PCL::TRUE PCL::MAKE-PROGN
-         PCL::|__si::MAKE-CACHE|
-         PCL::|STRUCTURE-OBJECT class constructor|
-         PCL::|__si::MAKE-CLASS-PRECEDENCE-DESCRIPTION|
-         PCL::|__si::MAKE-NO-METHODS| PCL::|__si::MAKE-ONE-CLASS|
-         PCL::|__si::MAKE-PV-TABLE| PCL::PV-WRAPPERS-FROM-PV-ARGS
-         WALKER::UNBOUND-LEXICAL-FUNCTION PCL::|__si::MAKE-TWO-CLASS|
-         PCL::|__si::MAKE-ACCESSOR-DFUN-INFO|
-         PCL::|__si::MAKE-DEFAULT-METHOD-ONLY|
-         PCL::MAKE-FAST-INSTANCE-BOUNDP
-         PCL::CALLED-FIN-WITHOUT-FUNCTION PCL::USE-PACKAGE-PCL
-         PCL::|__si::MAKE-CHECKING| PCL::|__si::MAKE-INITIAL-DISPATCH|
-         PCL::|__si::MAKE-DISPATCH|)) 
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::*)
+             COMMON-LISP::*)
+         WALKER::WALK-DECLARATIONS PCL::GET-SECONDARY-DISPATCH-FUNCTION
+         PCL::MAKE-ONE-INDEX-ACCESSOR-DFUN)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::FUNCTION)
-         PCL::METHOD-CALL-FUNCTION PCL::FAST-METHOD-CALL-FUNCTION
-         PCL::CACHE-LIMIT-FN)) 
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::T)
+             COMMON-LISP::T)
+         PCL::GET-SECONDARY-DISPATCH-FUNCTION2)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::BOOLEAN)
-         PCL::CACHE-VALUEP)) 
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::T)
+             COMMON-LISP::*)
+         ITERATE::ITERATE-TRANSFORM-BODY
+         PCL::|(FAST-METHOD SLOT-MISSING (T T T T))|
+         PCL::|(FAST-METHOD UPDATE-INSTANCE-FOR-REDEFINED-CLASS (STANDARD-OBJECT T T T))|)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
-             (COMMON-LISP::INTEGER 1 255))
-         PCL::CACHE-NKEYS)) 
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T
+                 (COMMON-LISP::INTEGER -9223372036854775808
+                     9223372036854775807))
+             COMMON-LISP::T)
+         PCL::COMPUTE-STD-CPL-PHASE-3)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
-             (COMMON-LISP::INTEGER 1 256))
-         PCL::CACHE-LINE-SIZE)) 
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
+                 COMMON-LISP::FIXNUM)
+             COMMON-LISP::T)
+         PCL::FILL-CACHE-FROM-CACHE-P PCL::GET-CACHE)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
-             (COMMON-LISP::VALUES COMMON-LISP::T COMMON-LISP::T))
-         PCL::SYMBOL-APPEND)) 
+         (COMMON-LISP::FUNCTION COMMON-LISP::NIL COMMON-LISP::FIXNUM)
+         PCL::GET-WRAPPER-CACHE-NUMBER)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
-             (COMMON-LISP::*))
-         PCL::SORT-APPLICABLE-METHODS PCL::SORT-METHODS)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::FUNCTION)
+         PCL::METHOD-CALL-FUNCTION PCL::FAST-METHOD-CALL-FUNCTION
+         PCL::CACHE-LIMIT-FN)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
              COMMON-LISP::T)
-         PCL::COMPUTE-CALLS PCL::SET-STRUCTURE-SVUC-METHOD
-         PCL::UPDATE-STD-OR-STR-METHODS PCL::SET-METHODS
-         WALKER::NOTE-LEXICAL-BINDING
+         PCL::MEC-ALL-CLASS-LISTS PCL::REMOVE-SLOT-ACCESSORS
+         PCL::PARSE-GSPEC PCL::STANDARD-INSTANCE-ACCESS
+         PCL::DOCTOR-DFUN-FOR-THE-DEBUGGER
+         PCL::UPDATE-STD-OR-STR-METHODS PCL::CLASS-MIGHT-PRECEDE-P
+         PCL::ACCESSOR-SET-SLOT-VALUE PCL::DOPLIST
+         PCL::ADD-SLOT-ACCESSORS PCL::DFUN-MISS
+         PCL::FSC-INSTANCE-WRAPPER PCL::CLASS-EQ-TEST
+         PCL::MAKE-INTERNAL-READER-METHOD-FUNCTION
+         PCL::MAKE-EARLY-ACCESSOR WALKER::ENVIRONMENT-MACRO
+         PCL::WITH-DFUN-WRAPPERS PCL::WRAPPER-STATE
+         PCL::DFUN-INFO-WRAPPER0
+         WALKER::WITH-NEW-DEFINITION-IN-ENVIRONMENT PCL::IF*
+         PCL::CHECK-WRAPPER-VALIDITY1
+         PCL::INITIALIZE-INFO-MAKE-INSTANCE-FUNCTION-SYMBOL
+         PCL::BUILT-IN-OR-STRUCTURE-WRAPPER
+         PCL::FIND-CLASS-CELL-PREDICATE PCL::CLASS-CAN-PRECEDE-P
+         COMMON-LISP::CALL-METHOD PCL::NET-CONSTANT-CONVERTER
+         PCL::UPDATE-INITIALIZE-INFO-INTERNAL
+         PCL::GET-CACHE-VECTOR-LOCK-COUNT PCL::UNDEFMETHOD
+         PCL::%SET-SVREF PCL::PV-WRAPPERS-FROM-ALL-WRAPPERS
+         PCL::WRAPPER-NO-OF-INSTANCE-SLOTS PCL::CACHE-VECTOR-LOCK-COUNT
+         WALKER::VARIABLE-LEXICAL-P PCL::FIN-LAMBDA-FN
+         PCL::INITIAL-CLASSES-AND-WRAPPERS PCL::MLOOKUP
+         PCL::RAISE-METATYPE ITERATE::WHILE PCL::EARLY-GF-ARG-INFO
+         PCL::INVALID-WRAPPER-P WALKER::VARIABLE-SPECIAL-P
+         PCL::EMIT-N-WRAPPER-COMPUTE-PRIMARY-CACHE-LOCATION
+         PCL::EMIT-CHECKING-OR-CACHING-FUNCTION-PRECOMPILED
+         PCL::INSTANCE-WRITE-INTERNAL WALKER::WALK-REPEAT-EVAL
+         WALKER::GET-WALKER-TEMPLATE-INTERNAL ITERATE::PLIST-ELEMENTS
+         PCL::MAKE-FIND-CLASS-CELL COMMON-LISP::WITH-ACCESSORS
+         PCL::MAKE-METHOD-FUNCTION PCL::SIMPLE-LEXICAL-METHOD-FUNCTIONS
+         PCL::CANONICALIZE-DEFCLASS-OPTION PCL::UPDATE-INITS PCL::SCASE
+         PCL::INSTANCE-BOUNDP-INTERNAL PCL::FMC-FUNCALL
+         PCL::SET-METHODS PCL::CACHE-LOCK-COUNT PCL::GET-WRAPPER
+         PCL::INVOKE-METHOD-CALL1 PCL::MAKE-CLASS-PREDICATE
+         PCL::PRINTING-RANDOM-THING PCL::UPDATE-SLOTS
+         PCL::FUNCTION-APPLY PCL::AUGMENT-TYPE ITERATE::WITH-GATHERING
+         PCL::CHECKING-DFUN-INFO PCL::LIST-EQ PCL::CACHE-VECTOR-SIZE
+         PCL::DESCRIBE-PACKAGE PCL::WRAPPER-REF PCL::PLIST-VALUE
+         PCL::%INSTANCE-REF WALKER::NOTE-DECLARATION
+         PCL::MAKE-STD-READER-METHOD-FUNCTION
+         PCL::EMIT-READER/WRITER-MACRO WALKER::ENVIRONMENT-FUNCTION
+         PCL::N-N-DFUN-INFO
+         PCL::FIND-CLASS-CELL-MAKE-INSTANCE-FUNCTION-KEYS
+         PCL::DEFCONSTRUCTOR PCL::INSTANCE-SLOT-INDEX
+         PCL::CLASS-NO-OF-INSTANCE-SLOTS ITERATE::ELEMENTS
+         PCL::NEXT-WRAPPER-CACHE-NUMBER-INDEX
+         PCL::INITIALIZE-INFO-COMBINED-INITARGS-FORM-LIST
+         COMMON-LISP::DEFINE-METHOD-COMBINATION PCL::MDOTIMES
+         PCL::REMOVE-DIRECT-SUBCLASSES PCL::MAKE-WRAPPER-INTERNAL
+         ITERATE::MAXIMIZING PCL::PV-OFFSET
+         PCL::DEAL-WITH-ARGUMENTS-OPTION PCL::INSTANCE-READER
+         PCL::ALLOCATE-STANDARD-INSTANCE--MACRO PCL::DEFINE-INLINES
+         PCL::WRAPPER-CACHE-NUMBER-VECTOR PCL::GATHERING1
+         PCL::FIND-CLASS-CELL-CLASS PCL::SWAP-WRAPPERS-AND-SLOTS
+         PCL::COMPUTE-APPLICABLE-METHODS-FUNCTION PCL::PV-TABLE-LOOKUP
+         PCL::WRAPPER-INSTANCE-SLOTS-LAYOUT
+         WALKER::WALKER-ENVIRONMENT-BIND PCL::COPY-SLOTS PCL::MCASE
+         PCL::ADD-TO-CVECTOR PCL::ADD-DIRECT-SUBCLASSES
+         PCL::%SET-CCLOSURE-ENV PCL::PRECOMPILE-RANDOM-CODE-SEGMENTS
+         PCL::UPDATE-CLASS PCL::SLOT-SYMBOL PCL::VALUE-FOR-CACHING
+         PCL::EXPANDING-MAKE-INSTANCE-TOP-LEVEL PCL::REMTAIL
+         PCL::MAKE-DISCRIMINATING-FUNCTION-ARGLIST
+         PCL::CLASSES-HAVE-COMMON-SUBCLASS-P
+         PCL::FIRST-WRAPPER-CACHE-NUMBER-INDEX
+         PCL::INITIALIZE-INFO-INITARGS-FORM-LIST
+         PCL::WITH-MAKE-INSTANCE-FUNCTION-VALID-P-CHECK
+         PCL::FUNCALLABLE-INSTANCE-DATA-1 PCL::SAUT-NOT-EQL
+         PCL::EARLY-GF-METHODS ITERATE::EXTRACT-SPECIAL-BINDINGS
+         PCL::MEMQ PCL::DFUN-UPDATE
+         PCL::MAKE-CHECKING-OR-CACHING-FUNCTION-LIST PCL::ONCE-ONLY
+         PCL::GET-INSTANCE-WRAPPER-OR-NIL PCL::SYMBOL-LESSP
+         PCL::|SETF PCL FIND-CLASS| PCL::PARSE-QUALIFIER-PATTERN
          ITERATE::SIMPLE-EXPAND-ITERATE-FORM
-         PCL::|SETF PCL METHOD-FUNCTION-PLIST| PCL::SAUT-NOT-PROTOTYPE
-         PCL::VALUE-FOR-CACHING PCL::PROCLAIM-DEFMETHOD
-         PCL::MAKE-FAST-METHOD-CALL-LAMBDA-LIST
-         PCL::MAKE-STD-BOUNDP-METHOD-FUNCTION PCL::METHODS-CONVERTER
-         PCL::DEAL-WITH-ARGUMENTS-OPTION
-         PCL::UPDATE-ALL-PV-TABLE-CACHES
-         PCL::MAP-PV-TABLE-REFERENCES-OF PCL::UPDATE-CLASS
-         PCL::FIND-STANDARD-II-METHOD
-         PCL::METHOD-FUNCTION-RETURNING-NIL
-         PCL::REDIRECT-EARLY-FUNCTION-INTERNAL PCL::UPDATE-CPL
-         PCL::QUALIFIER-CHECK-RUNTIME PCL::COMPUTE-STD-CPL
-         PCL::COMPUTE-CONSTANTS PCL::ADD-FORMS PCL::AUGMENT-TYPE
-         PCL::MEMF-CONSTANT-CONVERTER PCL::SWAP-WRAPPERS-AND-SLOTS
-         PCL::SET-WRAPPER PCL::GET-KEY-ARG PCL::MAKE-PLIST
-         PCL::MAKE-PV-TABLE-INTERNAL ITERATE::EXTRACT-SPECIAL-BINDINGS
-         PCL::SAUT-NOT-EQL WALKER::VARIABLE-SYMBOL-MACRO-P
-         PCL::EMIT-1-WRAPPER-COMPUTE-PRIMARY-CACHE-LOCATION
-         PCL::SET-FUNCTION-PRETTY-ARGLIST
-         PCL::GF-MAKE-FUNCTION-FROM-EMF PCL::FIND-SLOT-DEFINITION
-         PCL::SET-STANDARD-SVUC-METHOD PCL::ADD-TO-CVECTOR
-         PCL::PV-WRAPPERS-FROM-ALL-WRAPPERS COMMON-LISP::REMOVE-METHOD
-         PCL::CHECKING-DFUN-INFO PCL::PARSE-QUALIFIER-PATTERN
-         PCL::%SET-CCLOSURE-ENV PCL::MAKE-CDXR
-         PCL::FUNCALLABLE-STANDARD-INSTANCE-ACCESS
-         PCL::NET-CONSTANT-CONVERTER PCL::|SETF PCL FIND-CLASS|
+         PCL::INITIALIZE-INFO-SHARED-INITIALIZE-T-FUNCTION
+         PCL::RESET-INITIALIZE-INFO-INTERNAL
+         PCL::INITIALIZE-INFO-DEFAULT-INITARGS-FUNCTION
+         PCL::DESTRUCTURE-INTERNAL PCL::DFUN-INFO-INDEX
+         PCL::PRECOMPILE-IIS-FUNCTIONS PCL::INSTANCE-WRITE
+         COMMON-LISP::DEFCLASS PCL::UPDATE-ALL-PV-TABLE-CACHES
+         PCL::WRAPPER-CACHE-NUMBER-VECTOR-REF
+         PCL::INITIALIZE-INFO-COMBINED-INITIALIZE-FUNCTION
+         PCL::MODIFY-CACHE PCL::BOOTSTRAP-SLOT-INDEX
+         PCL::SET-FUNCTION-PRETTY-ARGLIST PCL::COMPUTE-LAYOUT
+         PCL::CALL-METHOD-LIST PCL::GET-KEY-ARG ITERATE::LIST-TAILS
+         PCL::INITIALIZE-INFO-MAKE-INSTANCE-FUNCTION ITERATE::EACHTIME
+         PCL::INSTANCE-REF PCL::WITH-EQ-HASH-TABLE
+         PCL::QUALIFIER-CHECK-RUNTIME PCL::CALLSREF ITERATE::MV-SETQ
+         PCL::PRINTING-RANDOM-THING-INTERNAL PCL::CHECK-MEMBER
+         PCL::INSTANCE-WRITER PCL::CANONICALIZE-SLOT-SPECIFICATION
+         PCL::BIND-LEXICAL-METHOD-FUNCTIONS ITERATE::LIST-ELEMENTS
+         PCL::INVOKE-EFFECTIVE-METHOD-FUNCTION-FAST
+         PCL::INVOKE-METHOD-CALL PCL::INITIALIZE-INFO-RI-VALID-P
+         PCL::SET-WRAPPER PCL::STD-INSTANCE-CLASS
+         PCL::EXPANDING-MAKE-INSTANCE PCL::BIND-ARGS
+         PCL::INITIALIZE-INFO-VALID-P PCL::STD-INSTANCE-WRAPPER
+         PCL::FSC-INSTANCE-SLOTS PCL::REAL-ENSURE-GF-INTERNAL PCL::NEQ
+         PCL::PRECOMPILE-DFUN-CONSTRUCTORS PCL::MAKE-DLAP-LAMBDA-LIST
+         PCL::FIND-SLOT-DEFINITION
+         PCL::BIND-SIMPLE-LEXICAL-METHOD-MACROS
+         PCL::ACCESSOR-SLOT-VALUE PCL::METHOD-FUNCTION-RETURNING-NIL
+         PCL::MAKE-DFUN-LAMBDA-LIST WALKER::VARIABLE-SYMBOL-MACRO-P
+         PCL::DFUN-INFO-FUNCTION COMMON-LISP::WITH-SLOTS
+         PCL::FUNCTION-FUNCALL PCL::EQL-TEST
+         PCL::INITIALIZE-INFO-CONSTANTS PCL::POSQ PCL::DOLIST-CAREFULLY
+         PCL::EMIT-ONE-OR-N-INDEX-READER/WRITER-MACRO PCL::MAKE-CAXR
+         ITERATE::ITERATE PCL::DEFINE-INITIALIZE-INFO PCL::ALIST-ENTRY
+         PCL::WITH-LOCAL-CACHE-FUNCTIONS PCL::WRAPPER-OF-MACRO
+         PCL::RASSQ PCL::SUPERCLASSES-COMPATIBLE-P
          PCL::METHOD-FUNCTION-RETURNING-T PCL::CHANGE-CLASS-INTERNAL
-         PCL::MAKE-DFUN-ARG-LIST PCL::DOCTOR-DFUN-FOR-THE-DEBUGGER
-         PCL::MAKE-STD-WRITER-METHOD-FUNCTION ITERATE::MV-SETQ
-         PCL::MAKE-EARLY-ACCESSOR PCL::GET-KEY-ARG1
-         PCL::ADD-DIRECT-SUBCLASSES PCL::DO-SATISFIES-DEFTYPE
-         PCL::N-N-DFUN-INFO PCL::CLASSES-HAVE-COMMON-SUBCLASS-P
-         PCL::SAUT-NOT-CLASS PCL::CANONICALIZE-DEFCLASS-OPTION
-         PCL::MAKE-DISCRIMINATING-FUNCTION-ARGLIST
-         WALKER::VARIABLE-LEXICAL-P WALKER::ENVIRONMENT-FUNCTION
-         PCL::PV-TABLE-LOOKUP PCL::DESTRUCTURE-INTERNAL
-         PCL::MAKE-INTERNAL-READER-METHOD-FUNCTION
-         PCL::REMOVE-SLOT-ACCESSORS
+         PCL::PRECOMPILE-FUNCTION-GENERATORS
+         WALKER::DEFINE-WALKER-TEMPLATE PCL::CACHE-VECTOR-REF
+         PCL::GET-SLOTS PCL::MEC-ALL-CLASSES-INTERNAL
+         COMMON-LISP::SLOT-EXISTS-P PCL::WITHOUT-INTERRUPTS
+         PCL::MAKE-UNORDERED-METHODS-EMF PCL::GET-KEY-ARG1
+         PCL::MAKE-STD-WRITER-METHOD-FUNCTION PCL::COMPUTE-CONSTANTS
+         PCL::BOOTSTRAP-GET-SLOT PCL::DEFINE-GF-PREDICATE
+         PCL::REDIRECT-EARLY-FUNCTION-INTERNAL
+         PCL::SET-STRUCTURE-SVUC-METHOD PCL::WRAPPER-CLASS
+         ITERATE::UNTIL PCL::PV-BINDING1 PCL::UPDATE-CPL PCL::PV-ENV
+         PCL::PV-BINDING PCL::INSTANCE-READ-INTERNAL
+         COMMON-LISP::DEFGENERIC ITERATE::COLLECTING
+         WALKER::NOTE-LEXICAL-BINDING PCL::ORIGINAL-DEFINITION
+         PCL::COLLECTING-ONCE PCL::GET-SLOTS-OR-NIL PCL::TRACE-EMF-CALL
+         PCL::WITH-HASH-TABLE PCL::FUNCALLABLE-INSTANCE-MARKER
+         PCL::INITIALIZE-INFO-NEW-KEYS PCL::STD-INSTANCE-SLOTS
+         PCL::ACCESSOR-SLOT-BOUNDP PCL::SAUT-NOT-PROTOTYPE
+         PCL::MAP-PV-TABLE-REFERENCES-OF COMMON-LISP::ADD-METHOD
+         PCL::MAKE-CDXR PCL::CALL-INITIALIZE-FUNCTION PCL::ASV-FUNCALL
+         PCL::MAKE-STD-BOUNDP-METHOD-FUNCTION PCL::IIS-BODY
+         COMMON-LISP::DEFMETHOD PCL::SYMBOL-OR-CONS-LESSP
+         PCL::SAUT-NOT-CLASS-EQ PCL::METHODS-CONVERTER PCL::PVREF
+         PCL::EMIT-1-WRAPPER-COMPUTE-PRIMARY-CACHE-LOCATION
+         PCL::EMIT-CHECKING-OR-CACHING-MACRO ITERATE::SUMMING
+         PCL::|SETF PCL GDEFINITION| PCL::ESETF PCL::COPY-PV
+         PCL::WRAPPER-CLASS* COMMON-LISP::REMOVE-METHOD
          PCL::|SETF PCL FIND-CLASS-PREDICATE|
-         PCL::|SETF PCL GDEFINITION| PCL::MAKE-DFUN-LAMBDA-LIST
-         PCL::CANONICALIZE-SLOT-SPECIFICATION WALKER::WALK-REPEAT-EVAL
-         PCL::STANDARD-INSTANCE-ACCESS
-         PCL::PRINTING-RANDOM-THING-INTERNAL PCL::REMTAIL
-         PCL::ACCESSOR-MISS-FUNCTION PCL::COMPUTE-LAYOUT
-         PCL::CLASS-MIGHT-PRECEDE-P
-         PCL::EMIT-N-WRAPPER-COMPUTE-PRIMARY-CACHE-LOCATION
-         SYSTEM::%SET-COMPILED-FUNCTION-NAME PCL::PLIST-VALUE
-         PCL::MAKE-CAXR PCL::MAKE-DLAP-LAMBDA-LIST
-         PCL::MAKE-STD-READER-METHOD-FUNCTION WALKER::ENVIRONMENT-MACRO
-         PCL::UPDATE-SLOTS PCL::VARIABLE-CLASS
-         PCL::SET-FUNCALLABLE-INSTANCE-FUNCTION PCL::LIST-EQ
-         PCL::ADD-SLOT-ACCESSORS PCL::SAUT-NOT-CLASS-EQ PCL::COMPUTE-PV
-         PCL::PV-WRAPPERS-FROM-ALL-ARGS PCL::UPDATE-INITS
-         PCL::MEC-ALL-CLASS-LISTS PCL::RAISE-METATYPE
-         WALKER::NOTE-DECLARATION PCL::EMIT-1-NIL-DLAP
-         PCL::BOOTSTRAP-SLOT-INDEX PCL::SUPERCLASSES-COMPATIBLE-P
-         PCL::MEC-ALL-CLASSES-INTERNAL COMMON-LISP::SLOT-EXISTS-P
-         PCL::DESCRIBE-PACKAGE PCL::NO-SLOT PCL::PROCLAIM-DEFGENERIC
-         COMMON-LISP::ADD-METHOD PCL::MAKE-UNORDERED-METHODS-EMF
-         PCL::MEC-ALL-CLASSES PCL::SYMBOL-OR-CONS-LESSP
-         PCL::UPDATE-INITIALIZE-INFO-INTERNAL PCL::CLASS-CAN-PRECEDE-P
-         PCL::SYMBOL-LESSP PCL::COMPUTE-APPLICABLE-METHODS-FUNCTION
-         PCL::MAKE-CLASS-PREDICATE WALKER::VARIABLE-SPECIAL-P
-         PCL::REMOVE-DIRECT-SUBCLASSES)) 
+         PCL::ACCESSOR-MISS-FUNCTION PCL::MEMF-CONSTANT-CONVERTER
+         PCL::DELQ PCL::VECTORIZING PCL::MAKE-DFUN-ARG-LIST
+         PCL::VARIABLE-CLASS PCL::INSTANCE-ACCESSOR-PARAMETER
+         PCL::ALLOCATE-FUNCALLABLE-INSTANCE-SLOTS
+         PCL::EMIT-DEFAULT-ONLY-MACRO PCL::NO-SLOT
+         PCL::MAYBE-CHECK-CACHE PCL::FUNCALLABLE-INSTANCE-DATA-POSITION
+         PCL::MAKE-FAST-METHOD-CALL-LAMBDA-LIST
+         PCL::DO-STANDARD-DEFSETF PCL::SAUT-NOT-CLASS
+         PCL::DFUN-INFO-ACCESSOR-TYPE PCL::DEFINE-CACHED-READER
+         PCL::SET-STANDARD-SVUC-METHOD PCL::CLASS-TEST
+         PCL::MAKE-PV-TABLE-INTERNAL PCL::PROCLAIM-DEFGENERIC
+         PCL::GF-MAKE-FUNCTION-FROM-EMF PCL::COMPUTE-PV
+         PCL::EMIT-1-NIL-DLAP PCL::FIND-STANDARD-II-METHOD
+         PCL::BIND-FAST-LEXICAL-METHOD-MACROS PCL::DO-SATISFIES-DEFTYPE
+         PCL::FAST-LEXICAL-METHOD-FUNCTIONS PCL::COMPUTE-CALLS
+         PCL::COPY-INSTANCE-INTERNAL COMMON-LISP::SYMBOL-MACROLET
+         PCL::FSC-INSTANCE-P PCL::MAKE-PLIST PCL::%SVREF
+         PCL::PCL-DESTRUCTURING-BIND
+         SYSTEM::%SET-COMPILED-FUNCTION-NAME ITERATE::JOINING
+         ITERATE::MINIMIZING PCL::METHOD-FUNCTION-CLOSURE-GENERATOR
+         PCL::PV-WRAPPERS-FROM-ALL-ARGS PCL::*LIST-ELEMENTS
+         PCL::ADD-FORMS
+         PCL::INITIALIZE-INFO-SHARED-INITIALIZE-NIL-FUNCTION
+         ITERATE::INTERVAL PCL::INSTANCE-BOUNDP PCL::FSC-INSTANCE-CLASS
+         WALKER::WITH-AUGMENTED-ENVIRONMENT
+         PCL::CACHE-NUMBER-VECTOR-REF
+         PCL::INVOKE-EFFECTIVE-METHOD-FUNCTION PCL::ASSQ
+         PCL::SET-FUNCALLABLE-INSTANCE-FUNCTION
+         PCL::WRAPPER-CLASS-SLOTS PCL::MEC-ALL-CLASSES
+         ITERATE::GATHERING PCL::INSTANCE-READ PCL::COMPUTE-STD-CPL
+         PCL::PROCLAIM-DEFMETHOD
+         PCL::%ALLOCATE-STATIC-SLOT-STORAGE--CLASS PCL::*LIST-TAILS
+         PCL::|SETF PCL METHOD-FUNCTION-PLIST|
+         PCL::FUNCALLABLE-STANDARD-INSTANCE-ACCESS
+         PCL::DFUN-INFO-WRAPPER1 PCL::INVOKE-FAST-METHOD-CALL)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::*)
              COMMON-LISP::*)
+         PCL::COMPILE-LAMBDA PCL::COERCE-TO-CLASS
          PCL::MAKE-METHOD-FUNCTION-INTERNAL
-         PCL::MAKE-FINAL-DFUN-INTERNAL WALKER::MACROEXPAND-ALL
-         COMMON-LISP::ENSURE-GENERIC-FUNCTION
-         PCL::MAKE-METHOD-LAMBDA-INTERNAL PCL::MAKE-CONSTANT-VALUE-DFUN
-         PCL::GET-FUNCTION PCL::EXTRACT-DECLARATIONS
-         PCL::COERCE-TO-CLASS PCL::PARSE-METHOD-OR-SPEC
-         PCL::DISPATCH-DFUN-COST PCL::PARSE-SPECIALIZED-LAMBDA-LIST
-         PCL::MAP-ALL-CLASSES PCL::COMPILE-LAMBDA PCL::ENSURE-CLASS
-         PCL::GET-METHOD-FUNCTION WALKER::WALK-FORM
-         PCL::ALLOCATE-STRUCTURE-INSTANCE PCL::GET-FUNCTION1
+         PCL::MAKE-CONSTANT-VALUE-DFUN PCL::GET-FUNCTION
          PCL::MAKE-CACHING-DFUN PCL::MAKE-INSTANCE-1
-         PCL::GET-DFUN-CONSTRUCTOR)) 
+         PCL::MAKE-FINAL-DFUN-INTERNAL WALKER::MACROEXPAND-ALL
+         COMMON-LISP::ENSURE-GENERIC-FUNCTION PCL::MAP-ALL-CLASSES
+         PCL::GET-METHOD-FUNCTION PCL::MAKE-METHOD-LAMBDA-INTERNAL
+         PCL::PARSE-SPECIALIZED-LAMBDA-LIST PCL::GET-FUNCTION1
+         WALKER::WALK-FORM PCL::ALLOCATE-STRUCTURE-INSTANCE
+         PCL::ENSURE-CLASS PCL::GET-DFUN-CONSTRUCTOR
+         PCL::EXTRACT-DECLARATIONS PCL::DISPATCH-DFUN-COST
+         PCL::PARSE-METHOD-OR-SPEC)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
-             (COMMON-LISP::VALUES COMMON-LISP::T COMMON-LISP::T))
-         PCL::MAKE-CLASS-PREDICATE-NAME PCL::MAKE-KEYWORD)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
+             COMMON-LISP::*)
+         PCL::SDFUN-FOR-CACHING PCL::SAUT-AND PCL::EMIT-CHECKING
+         PCL::SPLIT-DECLARATIONS
+         PCL::COMPUTE-APPLICABLE-METHODS-USING-TYPES PCL::COMPUTE-CODE
+         PCL::*SUBTYPEP ITERATE::PARSE-DECLARATIONS
+         PCL::GENERATE-FAST-CLASS-SLOT-ACCESS-P
+         PCL::SLOT-NAME-LISTS-FROM-SLOTS COMMON-LISP::SLOT-VALUE
+         PCL::COMPUTE-STD-CPL-PHASE-1 PCL::SAUT-CLASS
+         PCL::FORM-LIST-TO-LISP PCL::INITIAL-DFUN
+         PCL::FIND-SUPERCLASS-CHAIN PCL::EMIT-CACHING PCL::SAUT-NOT
+         PCL::CHECK-INITARGS-VALUES PCL::REAL-REMOVE-METHOD
+         PCL::CPL-INCONSISTENT-ERROR COMMON-LISP::SLOT-BOUNDP
+         PCL::SPECIALIZER-APPLICABLE-USING-TYPE-P
+         PCL::MAKE-INSTANCE-FUNCTION-TRAP PCL::SAUT-CLASS-EQ
+         PCL::SLOT-UNBOUND-INTERNAL PCL::SAUT-PROTOTYPE
+         PCL::CPL-FORWARD-REFERENCED-CLASS-ERROR
+         PCL::GET-NEW-FUNCTION-GENERATOR-INTERNAL
+         PCL::EMIT-DEFAULT-ONLY PCL::CLASS-APPLICABLE-USING-CLASS-P
+         PCL::COMPUTE-TEST PCL::MUTATE-SLOTS-AND-CALLS
+         PCL::EMIT-DEFAULT-ONLY-FUNCTION PCL::ENSURE-CLASS-VALUES
+         PCL::INVOKE-EMF COMMON-LISP::SLOT-MAKUNBOUND
+         PCL::MAKE-DIRECT-SLOTD PCL::INSURE-DFUN PCL::SET-FUNCTION-NAME
+         PCL::DESTRUCTURE PCL::SAUT-EQL PCL::UPDATE-SLOT-VALUE-GF-INFO)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::*)
-             (COMMON-LISP::VECTOR COMMON-LISP::CHARACTER
-                 COMMON-LISP::*))
-         PCL::CAPITALIZE-WORDS)) 
+             COMMON-LISP::T)
+         WALKER::RELIST* PCL::UPDATE-DFUN
+         PCL::ALLOCATE-FUNCALLABLE-INSTANCE PCL::MAKE-SPECIALIZABLE
+         PCL::TRACE-METHOD PCL::ALLOCATE-STANDARD-INSTANCE
+         WALKER::RELIST COMMON-LISP::FIND-CLASS PCL::MAKE-WRAPPER
+         PCL::PV-TABLE-LOOKUP-PV-ARGS ITERATE::FUNCTION-LAMBDA-P
+         PCL::SET-DFUN PCL::EARLY-METHOD-SPECIALIZERS
+         WALKER::WALKER-ENVIRONMENT-BIND-1
+         PCL::INITIALIZE-METHOD-FUNCTION PCL::MAKE-TYPE-PREDICATE-NAME
+         PCL::MAKE-FINAL-DFUN PCL::FIND-CLASS-CELL
+         PCL::INITIALIZE-INTERNAL-SLOT-GFS PCL::MAKE-EARLY-GF
+         PCL::USE-DISPATCH-DFUN-P ITERATE::MAYBE-WARN
+         PCL::USE-CONSTANT-VALUE-DFUN-P PCL::FIND-CLASS-PREDICATE
+         PCL::SET-ARG-INFO PCL::CAPITALIZE-WORDS)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION COMMON-LISP::NIL COMMON-LISP::T)
-         PCL::ALLOCATE-FUNCALLABLE-INSTANCE-1 PCL::SHOW-EMF-CALL-TRACE
-         PCL::CACHES-TO-ALLOCATE PCL::MAKE-CACHE
-         PCL::SHOW-FREE-CACHE-VECTORS PCL::MAKE-ARG-INFO
-         PCL::NO-METHODS-DFUN-INFO PCL::STRUCTURE-FUNCTIONS-EXIST-P
-         PCL::INITIALIZE-CHECKING-OR-CACHING-FUNCTION-LIST
-         PCL::BOOTSTRAP-BUILT-IN-CLASSES
-         PCL::%%ALLOCATE-INSTANCE--CLASS PCL::DISPATCH-DFUN-INFO
-         PCL::INITIAL-DISPATCH-DFUN-INFO PCL::BOOTSTRAP-META-BRAID
-         PCL::UPDATE-DISPATCH-DFUNS PCL::LIST-ALL-DFUNS
-         PCL::DEFAULT-METHOD-ONLY-DFUN-INFO PCL::RENEW-SYS-FILES
-         PCL::IN-THE-COMPILER-P PCL::GET-EFFECTIVE-METHOD-GENSYM
-         PCL::MAKE-CPD PCL::INITIAL-DFUN-INFO
-         PCL::SHOW-DFUN-CONSTRUCTORS
-         PCL::ALLOCATE-FUNCALLABLE-INSTANCE-2)) 
+         (COMMON-LISP::FUNCTION
+             (COMMON-LISP::T COMMON-LISP::STREAM COMMON-LISP::T)
+             COMMON-LISP::T)
+         PCL::PRINT-DFUN-INFO)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::*) COMMON-LISP::FIXNUM)
-         PCL::ZERO)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
+             COMMON-LISP::SIMPLE-VECTOR)
+         PCL::CACHE-VECTOR)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::STREAM COMMON-LISP::T)
-             COMMON-LISP::T)
-         PCL::PRINT-DFUN-INFO)) 
+             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
+             (COMMON-LISP::VALUES COMMON-LISP::T COMMON-LISP::T))
+         PCL::SYMBOL-APPEND)) 
+(COMMON-LISP::PROCLAIM
+    '(COMMON-LISP::FTYPE
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
+             (COMMON-LISP::OR PCL::CACHE COMMON-LISP::NULL))
+         PCL::PV-TABLE-CACHE)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
@@ -412,70 +1019,11 @@
          PCL::COMPUTE-CACHE-PARAMETERS)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION COMMON-LISP::NIL COMMON-LISP::*)
-         PCL::COUNT-ALL-DFUNS PCL::EMIT-N-N-WRITERS
-         PCL::EMIT-N-N-READERS)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::*)
-             COMMON-LISP::T)
-         PCL::MAKE-FINAL-DFUN PCL::SET-ARG-INFO PCL::TRACE-METHOD
-         PCL::MAKE-SPECIALIZABLE WALKER::WALKER-ENVIRONMENT-BIND-1
-         ITERATE::FUNCTION-LAMBDA-P COMMON-LISP::FIND-CLASS
-         PCL::MAKE-WRAPPER PCL::UPDATE-DFUN
-         PCL::MAKE-TYPE-PREDICATE-NAME PCL::PV-TABLE-LOOKUP-PV-ARGS
-         PCL::USE-CONSTANT-VALUE-DFUN-P WALKER::RELIST
-         PCL::MAKE-EARLY-GF PCL::INITIALIZE-METHOD-FUNCTION
-         PCL::FIND-CLASS-CELL PCL::USE-DISPATCH-DFUN-P
-         PCL::FIND-CLASS-PREDICATE PCL::ALLOCATE-STANDARD-INSTANCE
-         PCL::INITIALIZE-INTERNAL-SLOT-GFS ITERATE::MAYBE-WARN
-         PCL::ALLOCATE-FUNCALLABLE-INSTANCE
-         PCL::EARLY-METHOD-SPECIALIZERS WALKER::RELIST* PCL::SET-DFUN)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T COMMON-LISP::T)
-             COMMON-LISP::*)
-         PCL::SLOT-UNBOUND-INTERNAL ITERATE::PARSE-DECLARATIONS
-         PCL::EMIT-CACHING PCL::COMPUTE-STD-CPL-PHASE-1
-         PCL::INITIAL-DFUN PCL::INSURE-DFUN PCL::EMIT-CHECKING
-         PCL::COMPUTE-TEST PCL::COMPUTE-CODE PCL::MAKE-DIRECT-SLOTD
-         PCL::SAUT-CLASS COMMON-LISP::SLOT-MAKUNBOUND
-         PCL::CPL-FORWARD-REFERENCED-CLASS-ERROR PCL::INVOKE-EMF
-         PCL::*SUBTYPEP PCL::SPECIALIZER-APPLICABLE-USING-TYPE-P
-         PCL::COMPUTE-APPLICABLE-METHODS-USING-TYPES
-         PCL::REAL-REMOVE-METHOD PCL::SAUT-PROTOTYPE
-         PCL::MUTATE-SLOTS-AND-CALLS PCL::FIND-SUPERCLASS-CHAIN
-         COMMON-LISP::SLOT-BOUNDP PCL::FORM-LIST-TO-LISP
-         PCL::CPL-INCONSISTENT-ERROR PCL::EMIT-DEFAULT-ONLY-FUNCTION
-         PCL::ENSURE-CLASS-VALUES PCL::CHECK-INITARGS-VALUES
-         PCL::SAUT-EQL PCL::SPLIT-DECLARATIONS
-         PCL::UPDATE-SLOT-VALUE-GF-INFO PCL::SAUT-AND
-         PCL::SLOT-NAME-LISTS-FROM-SLOTS
-         PCL::MAKE-INSTANCE-FUNCTION-TRAP PCL::EMIT-DEFAULT-ONLY
-         PCL::SAUT-NOT PCL::SAUT-CLASS-EQ COMMON-LISP::SLOT-VALUE
-         PCL::DESTRUCTURE PCL::GENERATE-FAST-CLASS-SLOT-ACCESS-P
-         PCL::GET-NEW-FUNCTION-GENERATOR-INTERNAL
-         PCL::CLASS-APPLICABLE-USING-CLASS-P PCL::SDFUN-FOR-CACHING
-         PCL::SET-FUNCTION-NAME)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::FIXNUM)
-         PCL::ARG-INFO-NUMBER-REQUIRED PCL::CACHING-LIMIT-FN
-         PCL::PV-CACHE-LIMIT-FN PCL::ONE-INDEX-LIMIT-FN
-         PCL::PV-TABLE-PV-SIZE PCL::CACHE-COUNT PCL::DEFAULT-LIMIT-FN
-         PCL::CPD-COUNT PCL::CHECKING-LIMIT-FN
-         PCL::N-N-ACCESSORS-LIMIT-FN PCL::EARLY-CLASS-SIZE
-         PCL::FAST-INSTANCE-BOUNDP-INDEX)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::FIXNUM) COMMON-LISP::T)
-         PCL::POWER-OF-TWO-CEILING)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
              (COMMON-LISP::T COMMON-LISP::FIXNUM COMMON-LISP::*)
              COMMON-LISP::T)
-         PCL::GET-CACHE-FROM-CACHE)) 
+         PCL::GET-CACHE-FROM-CACHE
+         PCL::COMPUTE-PRIMARY-CACHE-LOCATION-FROM-LOCATION)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
          (COMMON-LISP::FUNCTION
@@ -484,544 +1032,81 @@
          PCL::COMPUTE-PRIMARY-CACHE-LOCATION)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T) PCL::FIELD-TYPE)
-         PCL::CACHE-FIELD)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
-             (COMMON-LISP::OR PCL::CACHE COMMON-LISP::NULL))
-         PCL::PV-TABLE-CACHE)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T)
-             COMMON-LISP::T)
-         PCL::|(FAST-METHOD PRINT-OBJECT (GENERIC-FUNCTION T))|
-         WALKER::WALK-TEMPLATE PCL::|(FAST-METHOD PRINT-OBJECT (T T))|
-         WALKER::WALK-DO/DO* PCL::LOAD-PRECOMPILED-DFUN-CONSTRUCTOR
-         PCL::|(FAST-METHOD DOCUMENTATION (DOCUMENTATION-MIXIN))|
-         WALKER::WALK-LET/LET*
-         PCL::|(FAST-METHOD PRINT-OBJECT (STANDARD-METHOD-COMBINATION T))|
-         PCL::|(FAST-METHOD REMOVE-DIRECT-METHOD (CLASS METHOD))|
-         PCL::MAKE-EFFECTIVE-METHOD-FUNCTION-TYPE
-         PCL::|(FAST-METHOD CHANGE-CLASS (STANDARD-OBJECT FUNCALLABLE-STANDARD-CLASS))|
-         PCL::|(FAST-METHOD REINITIALIZE-INSTANCE :BEFORE (SLOT-CLASS))|
-         PCL::|(FAST-METHOD ADD-DIRECT-METHOD (CLASS METHOD))|
-         PCL::INITIALIZE-INSTANCE-SIMPLE
-         PCL::|(FAST-METHOD VALIDATE-SUPERCLASS (CLASS CLASS))|
-         PCL::EXPAND-SYMBOL-MACROLET-INTERNAL
-         PCL::|(FAST-METHOD REMOVE-WRITER-METHOD (SLOT-CLASS T))|
-         PCL::MAKE-EFFECTIVE-METHOD-FUNCTION1
-         PCL::|(FAST-METHOD VALIDATE-SUPERCLASS (SLOT-CLASS FORWARD-REFERENCED-CLASS))|
-         PCL::|(FAST-METHOD ALLOCATE-INSTANCE (STANDARD-CLASS))|
-         PCL::|(FAST-METHOD MAKE-WRITER-METHOD-FUNCTION (FUNCALLABLE-STANDARD-CLASS T))|
-         PCL::|(FAST-METHOD SAME-SPECIALIZER-P (EQL-SPECIALIZER EQL-SPECIALIZER))|
-         PCL::|(FAST-METHOD REINITIALIZE-INSTANCE :AFTER (STANDARD-GENERIC-FUNCTION))|
-         PCL::|(FAST-METHOD REMOVE-DIRECT-METHOD (SPECIALIZER-WITH-OBJECT METHOD))|
-         PCL::|(FAST-METHOD LEGAL-SLOT-NAME-P (STANDARD-METHOD T))|
-         PCL::|(FAST-METHOD EFFECTIVE-SLOT-DEFINITION-CLASS (STRUCTURE-CLASS T))|
-         PCL::|(FAST-METHOD ADD-DEPENDENT (DEPENDENT-UPDATE-MIXIN T))|
-         PCL::|(FAST-METHOD COMPUTE-APPLICABLE-METHODS (GENERIC-FUNCTION T))|
-         PCL::|(FAST-METHOD MAP-DEPENDENTS (DEPENDENT-UPDATE-MIXIN T))|
-         PCL::|(FAST-METHOD REMOVE-READER-METHOD (SLOT-CLASS T))|
-         PCL::|(FAST-METHOD UPDATE-GF-DFUN (STD-CLASS T))|
-         PCL::|(FAST-METHOD LEGAL-QUALIFIER-P (STANDARD-METHOD T))|
-         PCL::|(FAST-METHOD MAKE-WRITER-METHOD-FUNCTION (SLOT-CLASS T))|
-         PCL::|(FAST-METHOD VALIDATE-SUPERCLASS (CLASS BUILT-IN-CLASS))|
-         PCL::|(FAST-METHOD ADD-DIRECT-SUBCLASS (CLASS CLASS))|
-         PCL::|(FAST-METHOD REMOVE-DIRECT-SUBCLASS (CLASS CLASS))|
-         PCL::MAKE-DISPATCH-LAMBDA
-         PCL::|(FAST-METHOD EFFECTIVE-SLOT-DEFINITION-CLASS (STD-CLASS T))|
-         PCL::EXPAND-DEFCLASS
-         PCL::|(FAST-METHOD DIRECT-SLOT-DEFINITION-CLASS (STD-CLASS T))|
-         PCL::|(FAST-METHOD LEGAL-METHOD-FUNCTION-P (STANDARD-METHOD T))|
-         PCL::OPTIMIZE-WRITER
-         PCL::|(FAST-METHOD LEGAL-LAMBDA-LIST-P (STANDARD-METHOD T))|
-         PCL::|(FAST-METHOD PRINT-OBJECT (STANDARD-METHOD T))|
-         PCL::|(FAST-METHOD DOCUMENTATION (T))|
-         PCL::|(FAST-METHOD CHANGE-CLASS (STANDARD-OBJECT STANDARD-CLASS))|
-         PCL::|(FAST-METHOD PRINT-OBJECT (STANDARD-ACCESSOR-METHOD T))|
-         PCL::OPTIMIZE-READER WALKER::WALK-PROG/PROG*
-         PCL::BOOTSTRAP-SET-SLOT
-         PCL::EMIT-CHECKING-OR-CACHING-FUNCTION-PRELIMINARY
-         PCL::|(FAST-METHOD COMPUTE-EFFECTIVE-SLOT-DEFINITION-INITARGS :AROUND (STRUCTURE-CLASS T))|
-         PCL::|(FAST-METHOD MAKE-READER-METHOD-FUNCTION (FUNCALLABLE-STANDARD-CLASS T))|
-         PCL::TWO-CLASS-DFUN-INFO
-         PCL::|(FAST-METHOD MAKE-INSTANCE (CLASS))|
-         PCL::|(FAST-METHOD REMOVE-DEPENDENT (DEPENDENT-UPDATE-MIXIN T))|
-         PCL::ADJUST-CACHE
-         PCL::|(FAST-METHOD SLOT-ACCESSOR-STD-P (EFFECTIVE-SLOT-DEFINITION T))|
-         PCL::|(FAST-METHOD REMOVE-BOUNDP-METHOD (SLOT-CLASS T))|
-         PCL::EXPAND-CACHE
-         PCL::|(FAST-METHOD INFORM-TYPE-SYSTEM-ABOUT-CLASS (STD-CLASS T))|
-         PCL::|(FAST-METHOD REINITIALIZE-INSTANCE (STANDARD-METHOD))|
-         PCL::|(FAST-METHOD LEGAL-DOCUMENTATION-P (STANDARD-METHOD T))|
-         PCL::|(FAST-METHOD PRINT-OBJECT (SLOT-DEFINITION T))|
-         PCL::|(FAST-METHOD PRINT-OBJECT (CLASS T))|
-         PCL::|(FAST-METHOD DIRECT-SLOT-DEFINITION-CLASS (STRUCTURE-CLASS T))|
-         PCL::|(FAST-METHOD COMPUTE-EFFECTIVE-SLOT-DEFINITION-INITARGS (SLOT-CLASS T))|
-         PCL::|(FAST-METHOD ADD-DIRECT-METHOD (SPECIALIZER-WITH-OBJECT METHOD))|
-         PCL::|(FAST-METHOD INITIALIZE-INSTANCE :AFTER (STANDARD-GENERIC-FUNCTION))|
-         PCL::|(FAST-METHOD SAME-SPECIALIZER-P (CLASS CLASS))|
-         PCL::|(FAST-METHOD COMPATIBLE-META-CLASS-CHANGE-P (T T))|
-         PCL::|(FAST-METHOD SAME-SPECIALIZER-P (CLASS-EQ-SPECIALIZER CLASS-EQ-SPECIALIZER))|
-         PCL::|(FAST-METHOD MAKE-READER-METHOD-FUNCTION (SLOT-CLASS T))|
-         PCL::|(FAST-METHOD ALLOCATE-INSTANCE (FUNCALLABLE-STANDARD-CLASS))|
-         PCL::GET-WRAPPERS-FROM-CLASSES
-         PCL::|(FAST-METHOD VALIDATE-SUPERCLASS (FUNCALLABLE-STANDARD-CLASS STANDARD-CLASS))|
-         PCL::MAYBE-EXPAND-ACCESSOR-FORM WALKER::WALK-BINDINGS-2
-         PCL::FILL-CACHE-P PCL::MAKE-EFFECTIVE-METHOD-FUNCTION-INTERNAL
-         PCL::|(FAST-METHOD MAKE-BOUNDP-METHOD-FUNCTION (SLOT-CLASS T))|
-         PCL::|(FAST-METHOD LEGAL-SPECIALIZER-P (STANDARD-METHOD T))|
-         PCL::|(FAST-METHOD SAME-SPECIALIZER-P (SPECIALIZER SPECIALIZER))|
-         PCL::|(FAST-METHOD INFORM-TYPE-SYSTEM-ABOUT-CLASS (STRUCTURE-CLASS T))|
-         PCL::LOAD-PRECOMPILED-IIS-ENTRY PCL::MEMF-TEST-CONVERTER
-         PCL::|(FAST-METHOD REINITIALIZE-INSTANCE (SLOT-OBJECT))|)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::*)
-             COMMON-LISP::T)
-         PCL::REAL-ADD-NAMED-METHOD PCL::EARLY-ADD-NAMED-METHOD
-         PCL::FILL-DFUN-CACHE)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
-             COMMON-LISP::T)
-         PCL::OBSOLETE-INSTANCE-TRAP
-         PCL::|(FAST-METHOD SPECIALIZER-DIRECT-GENERIC-FUNCTIONS (SPECIALIZER-WITH-OBJECT))|
-         WALKER::WALK-TAGBODY
-         PCL::|(FAST-METHOD CLASS-DIRECT-DEFAULT-INITARGS (BUILT-IN-CLASS))|
-         PCL::ENTRY-IN-CACHE-P WALKER::WALK-COMPILER-LET
-         PCL::|(FAST-METHOD METHOD-QUALIFIERS (STANDARD-METHOD))|
-         PCL::NOTE-PV-TABLE-REFERENCE PCL::COMPUTE-EFFECTIVE-METHOD
-         PCL::MAKE-DFUN-CALL PCL::|SETF PCL PLIST-VALUE|
-         PCL::|(FAST-METHOD SPECIALIZER-DIRECT-METHODS (SPECIALIZER-WITH-OBJECT))|
-         PCL::|(FAST-METHOD SPECIALIZER-METHOD-TABLE (CLASS-EQ-SPECIALIZER))|
-         PCL::|(FAST-METHOD SPECIALIZER-CLASS (EQL-SPECIALIZER))|
-         PCL::|(FAST-METHOD SLOTS-FETCHER (FUNCALLABLE-STANDARD-CLASS))|
-         WALKER::WALK-UNEXPECTED-DECLARE
-         PCL::MAKE-METHOD-INITARGS-FORM-INTERNAL
-         PCL::SKIP-FAST-SLOT-ACCESS-P PCL::SET-FUNCTION-NAME-1
-         WALKER::WALK-DO PCL::EMIT-1-T-DLAP PCL::PRINT-STD-INSTANCE
-         PCL::|(FAST-METHOD CLASS-DEFAULT-INITARGS (SLOT-CLASS))|
-         WALKER::WALK-LAMBDA PCL::MAKE-METHOD-SPEC
-         PCL::|(FAST-METHOD CLASS-PREDICATE-NAME (T))|
-         PCL::|(FAST-METHOD COMPUTE-SLOTS (STRUCTURE-CLASS))|
-         PCL::OPTIMIZE-SET-SLOT-VALUE
-         PCL::MAKE-OPTIMIZED-STD-SETF-SLOT-VALUE-USING-CLASS-METHOD-FUNCTION
-         PCL::EXPAND-DEFGENERIC WALKER::VARIABLE-DECLARATION
-         ITERATE::RENAME-AND-CAPTURE-VARIABLES
-         PCL::|(FAST-METHOD SLOT-DEFINITION-ALLOCATION (STRUCTURE-SLOT-DEFINITION))|
-         PCL::MAP-ALL-ORDERS
-         PCL::|(FAST-METHOD GF-FAST-METHOD-FUNCTION-P (STANDARD-GENERIC-FUNCTION))|
-         PCL::DECLARE-STRUCTURE WALKER::WALK-PROG
-         PCL::|(FAST-METHOD GENERIC-FUNCTION-PRETTY-ARGLIST (STANDARD-GENERIC-FUNCTION))|
-         PCL::OPTIMIZE-SLOT-VALUE WALKER::WALK-MULTIPLE-VALUE-BIND
-         PCL::|(FAST-METHOD CLASS-DIRECT-SLOTS (BUILT-IN-CLASS))|
-         PCL::STANDARD-COMPUTE-EFFECTIVE-METHOD WALKER::WALK-LOCALLY
-         PCL::|(FAST-METHOD ACCESSOR-METHOD-CLASS (STANDARD-ACCESSOR-METHOD))|
-         WALKER::WALK-DO*
-         PCL::|(FAST-METHOD INITIALIZE-INTERNAL-SLOT-FUNCTIONS (EFFECTIVE-SLOT-DEFINITION))|
-         PCL::MAKE-OPTIMIZED-STD-SLOT-VALUE-USING-CLASS-METHOD-FUNCTION
-         PCL::EMIT-BOUNDP-CHECK WALKER::RECONS
-         PCL::|(FAST-METHOD FINALIZE-INHERITANCE (STD-CLASS))|
-         PCL::|(FAST-METHOD SPECIALIZER-METHOD-TABLE (EQL-SPECIALIZER))|
-         WALKER::WALK-LET* WALKER::WALK-TAGBODY-1 PCL::FLUSH-CACHE-TRAP
-         WALKER::WALK-FLET
-         PCL::|(FAST-METHOD CLASS-DIRECT-DEFAULT-INITARGS (SLOT-CLASS))|
-         PCL::|(FAST-METHOD COMPUTE-DEFAULT-INITARGS (SLOT-CLASS))|
-         PCL::|(FAST-METHOD FINALIZE-INHERITANCE (STRUCTURE-CLASS))|
-         PCL::PRINT-CACHE
-         PCL::|(FAST-METHOD SLOTS-FETCHER (STANDARD-CLASS))|
-         PCL::INVALIDATE-WRAPPER PCL::GET-NEW-FUNCTION-GENERATOR
-         ITERATE::OPTIMIZE-ITERATE-FORM WALKER::RELIST-INTERNAL
-         PCL::CAN-OPTIMIZE-ACCESS PCL::MAKE-TOP-LEVEL-FORM
-         PCL::|(FAST-METHOD SPECIALIZER-DIRECT-METHODS (CLASS))|
-         WALKER::WALK-MULTIPLE-VALUE-SETQ WALKER::WALK-LABELS
-         PCL::|(FAST-METHOD RAW-INSTANCE-ALLOCATOR (STANDARD-CLASS))|
-         PCL::|(FAST-METHOD CLASS-SLOTS (BUILT-IN-CLASS))|
-         PCL::|(FAST-METHOD ACCESSOR-METHOD-CLASS (STANDARD-WRITER-METHOD))|
-         WALKER::WALK-SETQ  WALKER::WALK-LET
-         PCL::|SETF PCL METHOD-FUNCTION-GET| WALKER::WALK-IF
-         PCL::|(FAST-METHOD COMPUTE-SLOTS :AROUND (STD-CLASS))|
-         ITERATE::SIMPLE-EXPAND-GATHERING-FORM
-         PCL::|(FAST-METHOD CLASS-FINALIZED-P (PCL-CLASS))|
-         WALKER::WALK-NAMED-LAMBDA PCL::FIRST-FORM-TO-LISP
-         PCL::ONE-CLASS-DFUN-INFO
-         WALKER::WITH-AUGMENTED-ENVIRONMENT-INTERNAL
-         PCL::EMIT-GREATER-THAN-1-DLAP PCL::CONVERT-TABLE
-         PCL::|(FAST-METHOD CLASS-CONSTRUCTORS (SLOT-CLASS))|
-         PCL::INITIALIZE-INTERNAL-SLOT-GFS*
-         ITERATE::OPTIMIZE-GATHERING-FORM
-         PCL::|(FAST-METHOD SPECIALIZER-CLASS (CLASS))|
-         PCL::OPTIMIZE-SLOT-BOUNDP
-         PCL::|(FAST-METHOD CLASS-SLOT-CELLS (STD-CLASS))|
-         PCL::|(FAST-METHOD MAKE-INSTANCES-OBSOLETE (STD-CLASS))|
-         PCL::WRAP-METHOD-GROUP-SPECIFIER-BINDINGS
-         WALKER::WALK-SYMBOL-MACROLET ITERATE::VARIABLE-SAME-P
-         PCL::EMIT-SLOT-READ-FORM
-         PCL::SKIP-OPTIMIZE-SLOT-VALUE-BY-CLASS-P
-         PCL::|(FAST-METHOD WRAPPER-FETCHER (STANDARD-CLASS))|
-         PCL::GET-FUNCTION-GENERATOR
-         PCL::MAKE-OPTIMIZED-STD-SLOT-BOUNDP-USING-CLASS-METHOD-FUNCTION
-         PCL::FIX-SLOT-ACCESSORS
-         PCL::|(FAST-METHOD RAW-INSTANCE-ALLOCATOR (FUNCALLABLE-STANDARD-CLASS))|
-         PCL::|(FAST-METHOD SPECIALIZER-DIRECT-GENERIC-FUNCTIONS (CLASS))|
-         PCL::OPTIMIZE-GF-CALL-INTERNAL
-         PCL::|(FAST-METHOD COMPUTE-SLOTS :AROUND (STRUCTURE-CLASS))|
-         PCL::|(FAST-METHOD COMPUTE-CLASS-PRECEDENCE-LIST (SLOT-CLASS))|
-         PCL::|(FAST-METHOD COMPUTE-SLOTS (STD-CLASS))|
-         PCL::|(FAST-METHOD GENERIC-FUNCTION-LAMBDA-LIST (GENERIC-FUNCTION))|
-         PCL::|(FAST-METHOD CLASS-DEFAULT-INITARGS (BUILT-IN-CLASS))|
-         PCL::|(FAST-METHOD WRAPPER-FETCHER (FUNCALLABLE-STANDARD-CLASS))|
-         WALKER::WALK-PROG* PCL::ONE-INDEX-DFUN-INFO
-         PCL::COMPUTE-PRECEDENCE PCL::TRACE-EMF-CALL-INTERNAL
-         WALKER::WALK-MACROLET)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::*)
-             COMMON-LISP::T)
-         PCL::MAKE-DEFMETHOD-FORM-INTERNAL PCL::LOAD-DEFMETHOD
-         PCL::EARLY-MAKE-A-METHOD PCL::MAKE-DEFMETHOD-FORM)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
-             COMMON-LISP::T)
-         PCL::GET-EFFECTIVE-METHOD-FUNCTION1
-         PCL::ENSURE-GENERIC-FUNCTION-USING-CLASS
-         PCL::MAKE-EMF-FROM-METHOD
-         PCL::REAL-ENSURE-GF-USING-CLASS--NULL PCL::PROBE-CACHE
-         PCL::MAP-CACHE PCL::GET-DECLARATION
-         PCL::REAL-ENSURE-GF-USING-CLASS--GENERIC-FUNCTION
-         WALKER::CONVERT-MACRO-TO-LAMBDA
-         PCL::EXPAND-EFFECTIVE-METHOD-FUNCTION PCL::EMIT-MISS
-         PCL::GET-METHOD-FUNCTION-PV-CELL PCL::METHOD-FUNCTION-GET
-         PCL::FIND-CLASS-FROM-CELL PCL::RECORD-DEFINITION
-         PCL::COMPUTE-SECONDARY-DISPATCH-FUNCTION1
-         PCL::FIND-CLASS-PREDICATE-FROM-CELL
-         PCL::NAMED-OBJECT-PRINT-FUNCTION
-         PCL::PRECOMPUTE-EFFECTIVE-METHODS PCL::INITIALIZE-INFO
-         PCL::MAKE-EFFECTIVE-METHOD-FUNCTION-SIMPLE)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T)
-             COMMON-LISP::T)
-         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (STD-CLASS T))|
-         PCL::MAKE-METHOD-INITARGS-FORM-INTERNAL1
-         PCL::GET-MAKE-INSTANCE-FUNCTION-INTERNAL
-         PCL::BOOTSTRAP-ACCESSOR-DEFINITIONS1 PCL::MAKE-EMF-CACHE
-         PCL::|(FAST-METHOD FIND-METHOD-COMBINATION (GENERIC-FUNCTION (EQL STANDARD) T))|
-         PCL::MAKE-FGEN
-         PCL::|(FAST-METHOD SHARED-INITIALIZE :BEFORE (BUILT-IN-CLASS T))|
-         PCL::BOOTSTRAP-MAKE-SLOT-DEFINITIONS
-         PCL::|(FAST-METHOD READER-METHOD-CLASS (SLOT-CLASS T))|
-         PCL::|(FAST-METHOD SLOT-MAKUNBOUND-USING-CLASS (STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
-         PCL::|(FAST-METHOD SLOT-MAKUNBOUND-USING-CLASS (STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
-         PCL::OPTIMIZE-ACCESSOR-CALL
-         PCL::MAKE-INSTANCE-FUNCTION-COMPLEX PCL::UPDATE-SLOTS-IN-PV
-         PCL::COMPUTE-PV-SLOT
-         PCL::|(FAST-METHOD (SETF SLOT-ACCESSOR-STD-P) (T EFFECTIVE-SLOT-DEFINITION T))|
-         PCL::|(FAST-METHOD ENSURE-CLASS-USING-CLASS (T NULL))|
-         PCL::|(FAST-METHOD COMPUTE-EFFECTIVE-METHOD (GENERIC-FUNCTION SHORT-METHOD-COMBINATION T))|
-         PCL::|(FAST-METHOD (SETF DOCUMENTATION) (T T))|
-         PCL::OPTIMIZE-INSTANCE-ACCESS
-         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (STRUCTURE-CLASS T))|
-         PCL::MAKE-INSTANCE-FUNCTION-SIMPLE
-         PCL::|(FAST-METHOD SLOT-BOUNDP-USING-CLASS (STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
-         PCL::OPTIMIZE-GENERIC-FUNCTION-CALL
-         PCL::LOAD-FUNCTION-GENERATOR WALKER::WALK-BINDINGS-1
-         PCL::|(FAST-METHOD ENSURE-CLASS-USING-CLASS (T PCL-CLASS))|
-         PCL::REAL-MAKE-METHOD-INITARGS-FORM
-         PCL::|(FAST-METHOD COMPUTE-SLOT-ACCESSOR-INFO (EFFECTIVE-SLOT-DEFINITION T T))|
-         PCL::|(FAST-METHOD REMOVE-NAMED-METHOD (T T))|
-         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (STRUCTURE-SLOT-DEFINITION T))|
-         WALKER::WALK-TEMPLATE-HANDLE-REPEAT
-         PCL::MAKE-PARAMETER-REFERENCES
-         PCL::|(FAST-METHOD SLOT-UNBOUND (T T T))|
-         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (STANDARD-METHOD T))|
-         PCL::EXPAND-EMF-CALL-METHOD
-         PCL::|(FAST-METHOD WRITER-METHOD-CLASS (SLOT-CLASS T))|
-         PCL::|(FAST-METHOD (SETF DOCUMENTATION) (T DOCUMENTATION-MIXIN))|
-         PCL::|(FAST-METHOD SHARED-INITIALIZE :BEFORE (STANDARD-ACCESSOR-METHOD T))|
-         PCL::|(FAST-METHOD SLOT-BOUNDP-USING-CLASS (STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
-         PCL::|(FAST-METHOD SHARED-INITIALIZE :AFTER (DOCUMENTATION-MIXIN T))|
-         PCL::MAKE-FINAL-ORDINARY-DFUN-INTERNAL)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::*)
-             COMMON-LISP::T)
-         PCL::GET-METHOD WALKER::WALK-ARGLIST PCL::REAL-GET-METHOD
-         PCL::EMIT-FETCH-WRAPPER PCL::CHECK-INITARGS-2-LIST
-         PCL::FILL-CACHE PCL::CHECK-INITARGS-2-PLIST PCL::MAKE-EMF-CALL
-         PCL::CHECK-INITARGS-1 PCL::CAN-OPTIMIZE-ACCESS1)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T)
-             COMMON-LISP::T)
-         PCL::GET-SECONDARY-DISPATCH-FUNCTION2)) 
+         (COMMON-LISP::FUNCTION COMMON-LISP::NIL COMMON-LISP::*)
+         PCL::EMIT-N-N-WRITERS PCL::COUNT-ALL-DFUNS
+         PCL::EMIT-N-N-READERS)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T)
-             COMMON-LISP::T)
-         PCL::REAL-LOAD-DEFCLASS PCL::LOAD-DEFCLASS PCL::SET-ARG-INFO1
-         PCL::BOOTSTRAP-MAKE-SLOT-DEFINITION PCL::EMIT-SLOT-ACCESS
-         WALKER::WALK-TEMPLATE-HANDLE-REPEAT-1 PCL::OPTIMIZE-GF-CALL
-         PCL::|(FAST-METHOD (SETF SLOT-VALUE-USING-CLASS) (T STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
-         PCL::MAKE-EARLY-CLASS-DEFINITION)) 
+         (COMMON-LISP::FUNCTION COMMON-LISP::NIL COMMON-LISP::T)
+         PCL::GET-EFFECTIVE-METHOD-GENSYM PCL::RENEW-SYS-FILES
+         PCL::UPDATE-DISPATCH-DFUNS PCL::IN-THE-COMPILER-P
+         PCL::SHOW-FREE-CACHE-VECTORS PCL::BOOTSTRAP-BUILT-IN-CLASSES
+         PCL::MAKE-CACHE PCL::ALLOCATE-FUNCALLABLE-INSTANCE-2
+         PCL::ALLOCATE-FUNCALLABLE-INSTANCE-1
+         PCL::STRUCTURE-FUNCTIONS-EXIST-P PCL::NO-METHODS-DFUN-INFO
+         PCL::SHOW-EMF-CALL-TRACE PCL::INITIAL-DFUN-INFO
+         PCL::DISPATCH-DFUN-INFO PCL::MAKE-ARG-INFO
+         PCL::INITIALIZE-CHECKING-OR-CACHING-FUNCTION-LIST
+         PCL::%%ALLOCATE-INSTANCE--CLASS
+         PCL::INITIAL-DISPATCH-DFUN-INFO PCL::CACHES-TO-ALLOCATE
+         PCL::MAKE-CPD PCL::LIST-ALL-DFUNS PCL::SHOW-DFUN-CONSTRUCTORS
+         PCL::BOOTSTRAP-META-BRAID PCL::DEFAULT-METHOD-ONLY-DFUN-INFO)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::FIXNUM)
-             COMMON-LISP::T)
-         PCL::GET-CACHE PCL::FILL-CACHE-FROM-CACHE-P)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::BOOLEAN)
+         PCL::CACHE-VALUEP)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::FIXNUM COMMON-LISP::*)
-             COMMON-LISP::FIXNUM)
-         PCL::COMPUTE-PRIMARY-CACHE-LOCATION-FROM-LOCATION)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T) PCL::FIELD-TYPE)
+         PCL::CACHE-FIELD)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::T)
-         PCL::EVAL-FORM PCL::EARLY-CLASS-NAME-OF PCL::DFUN-INFO-CACHE
-         PCL::MAKE-CONSTANT-FUNCTION PCL::EXPAND-SHORT-DEFCOMBIN
-         PCL::COPY-CACHE PCL::PROCLAIM-INCOMPATIBLE-SUPERCLASSES
-         PCL::MAKE-INITIAL-DFUN PCL::ECD-METACLASS
-         PCL::EXTRACT-SPECIALIZER-NAMES PCL::GBOUNDP
-         PCL::GET-SETF-FUNCTION-NAME PCL::USE-CACHING-DFUN-P
-         PCL::INITIALIZE-INFO-CACHED-CONSTANTS
-         PCL::STRUCTURE-TYPE-INTERNAL-SLOTDS COMMON-LISP::CLASS-OF
-         PCL::INITIALIZE-INFO-CACHED-SHARED-INITIALIZE-NIL-FUNCTION
-         PCL::ARG-INFO-KEY/REST-P PCL::METHOD-CALL-CALL-METHOD-ARGS
-         PCL::FGEN-GENSYMS PCL::EARLY-CLASS-PRECEDENCE-LIST
-         PCL::EARLY-SLOT-DEFINITION-LOCATION
-         PCL::EXPAND-MAKE-INSTANCE-FORM PCL::INTERN-EQL-SPECIALIZER
-         PCL::METHOD-FUNCTION-METHOD PCL::FGEN-GENERATOR-LAMBDA
-         PCL::SLOT-READER-SYMBOL PCL::CACHING-P
-         PCL::EARLY-METHOD-QUALIFIERS
-         PCL::EARLY-COLLECT-DEFAULT-INITARGS PCL::KEYWORD-SPEC-NAME
-         PCL::ONE-INDEX-P PCL::COMPLICATED-INSTANCE-CREATION-METHOD
-         PCL::DFUN-ARG-SYMBOL PCL::N-N-CACHE
-         PCL::ONE-INDEX-DFUN-INFO-INDEX PCL::INITIAL-DISPATCH-CACHE
-         PCL::CPD-CLASS PCL::FAST-METHOD-CALL-ARG-INFO
-         PCL::MAKE-PV-TYPE-DECLARATION PCL::COMPUTE-STD-CPL-PHASE-2
-         PCL::GET-BUILT-IN-CLASS-SYMBOL
-         PCL::INITIALIZE-INFO-CACHED-RI-VALID-P
-         PCL::UPDATE-GFS-OF-CLASS PCL::STRUCTURE-SVUC-METHOD
-         PCL::SLOT-BOUNDP-SYMBOL PCL::FGEN-SYSTEM
-         PCL::FIND-CYCLE-REASONS ITERATE::SEQUENCE-ACCESSOR
-         PCL::GF-INFO-C-A-M-EMF-STD-P PCL::STRUCTURE-TYPE-P
-         PCL::TWO-CLASS-CACHE PCL::METHOD-LL->GENERIC-FUNCTION-LL
-         PCL::ONE-CLASS-ACCESSOR-TYPE PCL::WRAPPER-FOR-STRUCTURE
-         PCL::ACCESSOR-DFUN-INFO-CACHE PCL::%SYMBOL-FUNCTION
-         PCL::STRUCTURE-TYPE PCL::NET-TEST-CONVERTER
-         PCL::CONSTANT-SYMBOL-P PCL::GMAKUNBOUND PCL::INITIAL-P
-         PCL::GF-DFUN-CACHE PCL::STRUCTURE-SLOTD-TYPE
-         PCL::%STD-INSTANCE-WRAPPER PCL::INITIALIZE-INFO-P
-         PCL::CACHING-DFUN-INFO
-         PCL::MAKE-OPTIMIZED-STRUCTURE-SLOT-VALUE-USING-CLASS-METHOD-FUNCTION
-         PCL::FAST-METHOD-CALL-P PCL::GF-DFUN-INFO
-         PCL::INITIALIZE-INFO-BOUND-SLOTS PCL::ECD-CLASS-NAME
-         PCL::MAKE-INSTANCE-FUNCTION-SYMBOL
-         PCL::INITIALIZE-INFO-CACHED-DEFAULT-INITARGS-FUNCTION
-         PCL::STD-INSTANCE-P PCL::EXTRACT-PARAMETERS
-         WALKER::GET-WALKER-TEMPLATE PCL::SYMBOL-PKG-NAME
-         PCL::CCLOSUREP PCL::LOOKUP-FGEN PCL::CPD-SUPERS
-         PCL::ARG-INFO-KEYWORDS PCL::DISPATCH-P
-         PCL::INITIALIZE-INFO-CACHED-NEW-KEYS
-         PCL::MAKE-CALLS-TYPE-DECLARATION PCL::INITIALIZE-INFO-WRAPPER
-         PCL::%FBOUNDP PCL::DEFAULT-STRUCTURE-INSTANCE-P
-         WALKER::ENV-WALK-FORM PCL::EARLY-CLASS-DEFINITION
-         PCL::SORT-CALLS PCL::EARLY-METHOD-STANDARD-ACCESSOR-SLOT-NAME
-         PCL::DISPATCH-CACHE PCL::INITIALIZE-INFO-KEY
-         PCL::MAKE-OPTIMIZED-STRUCTURE-SLOT-BOUNDP-USING-CLASS-METHOD-FUNCTION
-         PCL::ARG-INFO-METATYPES PCL::GF-LAMBDA-LIST
-         WALKER::ENV-LEXICAL-VARIABLES PCL::ACCESSOR-DFUN-INFO-P
-         PCL::GF-PRECOMPUTE-DFUN-AND-EMF-P PCL::COMPUTE-LINE-SIZE
-         PCL::INITIALIZE-INFO-CACHED-SHARED-INITIALIZE-T-FUNCTION
-         PCL::FORCE-CACHE-FLUSHES PCL::TWO-CLASS-P PCL::DFUN-INFO-P
-         PCL::MAP-SPECIALIZERS PCL::MAKE-PERMUTATION-VECTOR
-         WALKER::ENV-LOCK PCL::CPD-AFTER PCL::EARLY-CLASS-SLOTS
-         PCL::GET-PV-CELL-FOR-CLASS PCL::ARG-INFO-P
-         PCL::EXTRACT-REQUIRED-PARAMETERS
-         PCL::STRUCTURE-SLOTD-READER-FUNCTION PCL::COMPUTE-CLASS-SLOTS
-         PCL::INFORM-TYPE-SYSTEM-ABOUT-STD-CLASS
-         PCL::TWO-CLASS-WRAPPER0
-         PCL::INITIALIZE-INFO-CACHED-MAKE-INSTANCE-FUNCTION-SYMBOL
-         PCL::COMPILE-LAMBDA-UNCOMPILED PCL::EARLY-CLASS-NAME
-         PCL::SFUN-P PCL::EXTRACT-LAMBDA-LIST PCL::UNDEFMETHOD-1
-         PCL::ONE-INDEX-DFUN-INFO-ACCESSOR-TYPE PCL::WRAPPER-OF
-         PCL::ARG-INFO-LAMBDA-LIST PCL::LIST-DFUN
-         PCL::NEXT-WRAPPER-FIELD PCL::CHECK-WRAPPER-VALIDITY
-         PCL::STRUCTURE-SLOTD-NAME PCL::BUILT-IN-WRAPPER-OF
-         PCL::GET-MAKE-INSTANCE-FUNCTIONS
-         PCL::GENERIC-CLOBBERS-FUNCTION PCL::NO-METHODS-P
-         PCL::CONSTANT-VALUE-P WALKER::ENV-WALK-FUNCTION
-         PCL::INITIAL-CACHE PCL::SLOT-INITARGS-FROM-STRUCTURE-SLOTD
-         PCL::MAKE-CLASS-EQ-PREDICATE
-         PCL::GET-MAKE-INSTANCE-FUNCTION-SYMBOL
-         PCL::BOOTSTRAP-ACCESSOR-DEFINITIONS
-         PCL::FUNCTION-PRETTY-ARGLIST
-         PCL::MAKE-OPTIMIZED-STRUCTURE-SETF-SLOT-VALUE-USING-CLASS-METHOD-FUNCTION
-         PCL::FTYPE-DECLARATION-FROM-LAMBDA-LIST PCL::TYPE-CLASS
-         PCL::CHECK-CACHE PCL::STANDARD-SVUC-METHOD
-         PCL::STRUCTURE-SLOTD-ACCESSOR-SYMBOL PCL::GF-INFO-FAST-MF-P
-         PCL::STRUCTURE-SLOTD-WRITER-FUNCTION
-         PCL::BOOTSTRAP-CLASS-PREDICATES PCL::DEFAULT-METHOD-ONLY-CACHE
-         PCL::GET-CACHE-VECTOR PCL::SLOT-WRITER-SYMBOL
-         PCL::FGEN-GENERATOR PCL::DNET-METHODS-P
-         PCL::DEFAULT-STRUCTURE-TYPE
-         PCL::INITIALIZE-INFO-CACHED-COMBINED-INITARGS-FORM-LIST
-         PCL::N-N-ACCESSOR-TYPE
-         PCL::STRUCTURE-TYPE-SLOT-DESCRIPTION-LIST
-         WALKER::ENV-DECLARATIONS WALKER::VARIABLE-GLOBALLY-SPECIAL-P
-         PCL::ONE-INDEX-INDEX PCL::ONE-INDEX-DFUN-INFO-CACHE
-         PCL::EARLY-ACCESSOR-METHOD-SLOT-NAME PCL::EARLY-CLASS-SLOTDS
-         PCL::CANONICAL-SLOT-NAME PCL::EARLY-COLLECT-CPL
-         PCL::RESET-CLASS-INITIALIZE-INFO-1
-         PCL::BUILT-IN-OR-STRUCTURE-WRAPPER1 PCL::ONE-INDEX-CACHE
-         PCL::MAKE-STRUCTURE-SLOT-BOUNDP-FUNCTION
-         PCL::MAKE-TYPE-PREDICATE PCL::FREE-CACHE
-         ITERATE::VARIABLES-FROM-LET
-         PCL::EARLY-METHOD-STANDARD-ACCESSOR-P
-         PCL::DEFAULT-CONSTANT-CONVERTER PCL::CLASS-PREDICATE
-         PCL::CHECKING-CACHE PCL::ARG-INFO-PRECEDENCE
-         PCL::METHOD-FUNCTION-NEEDS-NEXT-METHODS-P
-         PCL::DEFAULT-METHOD-ONLY-P
-         PCL::COMPUTE-APPLICABLE-METHODS-EMF-STD-P
-         PCL::STRUCTURE-SLOT-BOUNDP PCL::ONE-INDEX-ACCESSOR-TYPE
-         PCL::TWO-CLASS-ACCESSOR-TYPE
-         PCL::USE-DEFAULT-METHOD-ONLY-DFUN-P PCL::METHOD-CALL-P
-         PCL::UPDATE-CLASS-CAN-PRECEDE-P PCL::CONSTANT-VALUE-DFUN-INFO
-         PCL::COMPILE-LAMBDA-DEFERRED PCL::SETFBOUNDP
-         PCL::CLASS-HAS-A-FORWARD-REFERENCED-SUPERCLASS-P
-         PCL::PV-TABLEP PCL::STRUCTURE-OBJECT-P PCL::TWO-CLASS-INDEX
-         PCL::METHOD-FUNCTION-PV-TABLE PCL::ECD-OTHER-INITARGS
-         WALKER::GET-IMPLEMENTATION-DEPENDENT-WALKER-TEMPLATE
-         PCL::EARLY-GF-P PCL::STRUCTURE-SLOTD-INIT-FORM
-         PCL::FUNCALLABLE-INSTANCE-P PCL::CHECKING-FUNCTION
-         PCL::FUNCTION-RETURNING-NIL PCL::FUNCTION-RETURNING-T
-         PCL::UPDATE-C-A-M-GF-INFO PCL::COUNT-DFUN
-         PCL::UNPARSE-SPECIALIZERS PCL::CACHE-OWNER
-         PCL::EARLY-METHOD-CLASS
-         PCL::INITIALIZE-INFO-CACHED-COMBINED-INITIALIZE-FUNCTION
-         PCL::EARLY-SLOT-DEFINITION-NAME
-         PCL::GET-MAKE-INSTANCE-FUNCTION
-         PCL::STRUCTURE-TYPE-INCLUDED-TYPE-NAME
-         PCL::ECD-SUPERCLASS-NAMES PCL::GFS-OF-TYPE PCL::SORT-SLOTS
-         PCL::DO-STANDARD-DEFSETFS-FOR-DEFCLASS
-         PCL::COMPUTE-MCASE-PARAMETERS PCL::METHOD-FUNCTION-PLIST
-         PCL::ARG-INFO-NKEYS PCL::FINAL-ACCESSOR-DFUN-TYPE
-         PCL::EARLY-COLLECT-SLOTS PCL::EARLY-METHOD-LAMBDA-LIST
-         PCL::FAST-INSTANCE-BOUNDP-P PCL::GDEFINITION
-         PCL::%CCLOSURE-ENV SYSTEM::%COMPILED-FUNCTION-NAME
-         PCL::RESET-INITIALIZE-INFO PCL::ARG-INFO-NUMBER-OPTIONAL
-         PCL::RESET-CLASS-INITIALIZE-INFO
-         PCL::INITIALIZE-INFO-CACHED-VALID-P PCL::INTERNED-SYMBOL-P
-         PCL::EARLY-GF-NAME PCL::FGEN-TEST PCL::MAKE-INITFUNCTION
-         PCL::MAP-ALL-GENERIC-FUNCTIONS PCL::SHOW-DFUN-COSTS
-         PCL::CLASS-FROM-TYPE PCL::EXPAND-LONG-DEFCOMBIN
-         PCL::MAKE-DEFAULT-METHOD-GROUP-DESCRIPTION
-         PCL::FREE-CACHE-VECTOR PCL::%STD-INSTANCE-SLOTS
-         PCL::ALLOCATE-CACHE-VECTOR PCL::ONE-CLASS-P
-         PCL::CLASS-PRECEDENCE-DESCRIPTION-P PCL::SLOT-VECTOR-SYMBOL
-         PCL::INITIALIZE-INFO-CACHED-MAKE-INSTANCE-FUNCTION
-         PCL::ONE-CLASS-WRAPPER0 PCL::N-N-P
-         PCL::UPDATE-ALL-C-A-M-GF-INFO PCL::CHECKING-P
-         PCL::TWO-CLASS-WRAPPER1 PCL::PARSE-SPECIALIZERS
-         PCL::FORMAT-CYCLE-REASONS PCL::FLUSH-CACHE-VECTOR-INTERNAL
-         PCL::UNENCAPSULATED-FDEFINITION PCL::ONE-CLASS-INDEX
-         PCL::DEFAULT-CONSTANTP PCL::UPDATE-GF-INFO
-         PCL::ACCESSOR-DFUN-INFO-ACCESSOR-TYPE
-         PCL::INITIALIZE-INFO-CACHED-INITARGS-FORM-LIST
-         PCL::MAKE-EQL-PREDICATE PCL::ARG-INFO-VALID-P
-         PCL::CACHING-CACHE PCL::METHOD-FUNCTION-FROM-FAST-FUNCTION
-         PCL::FAST-METHOD-CALL-NEXT-METHOD-CALL
-         PCL::DEFAULT-SECONDARY-DISPATCH-FUNCTION
-         PCL::MAKE-FUNCTION-INLINE PCL::STORE-FGEN
-         PCL::LIST-LARGE-CACHE PCL::METHODS-CONTAIN-EQL-SPECIALIZER-P
-         PCL::ARG-INFO-APPLYP SYSTEM::%STRUCTURE-NAME
-         PCL::GF-INFO-SIMPLE-ACCESSOR-TYPE PCL::ECD-SOURCE
-         PCL::EARLY-CLASS-DIRECT-SUBCLASSES
-         PCL::UPDATE-PV-TABLE-CACHE-INFO PCL::DEFAULT-TEST-CONVERTER
-         PCL::MAKE-CALL-METHODS PCL::GET-BUILT-IN-WRAPPER-SYMBOL
-         PCL::GF-INFO-STATIC-C-A-M-EMF PCL::DEFAULT-STRUCTUREP
-         PCL::CONSTANT-VALUE-CACHE PCL::INITIAL-DISPATCH-P
-         PCL::ECD-CANONICAL-SLOTS PCL::WRAPPER-FIELD
-         PCL::UPDATE-GF-SIMPLE-ACCESSOR-TYPE PCL::ONE-CLASS-CACHE
-         PCL::CACHING-DFUN-COST PCL::LEGAL-CLASS-NAME-P
-         PCL::INTERN-FUNCTION-NAME PCL::FAST-METHOD-CALL-PV-CELL
-         PCL::CACHE-P PCL::ONE-INDEX-DFUN-INFO-P
-         PCL::MAKE-PV-TABLE-TYPE-DECLARATION PCL::NO-METHODS-CACHE)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::FIXNUM)
+         PCL::ONE-INDEX-LIMIT-FN PCL::EARLY-CLASS-SIZE PCL::CACHE-COUNT
+         PCL::PV-TABLE-PV-SIZE PCL::DEFAULT-LIMIT-FN
+         PCL::CHECKING-LIMIT-FN PCL::CACHING-LIMIT-FN
+         PCL::N-N-ACCESSORS-LIMIT-FN PCL::CPD-COUNT
+         PCL::FAST-INSTANCE-BOUNDP-INDEX PCL::ARG-INFO-NUMBER-REQUIRED
+         PCL::PV-CACHE-LIMIT-FN)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::*) COMMON-LISP::*)
-         PCL::UPDATE-MAKE-INSTANCE-FUNCTION-TABLE PCL::UNTRACE-METHOD
-         COMMON-LISP::METHOD-COMBINATION-ERROR
-         COMMON-LISP::INVALID-METHOD-ERROR PCL::LIST-LARGE-CACHES)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::FIXNUM) COMMON-LISP::T)
+         PCL::POWER-OF-TWO-CEILING)) 
+(COMMON-LISP::MAPC
+    (COMMON-LISP::LAMBDA (COMPILER::X)
+      (COMMON-LISP::SETF
+          (COMMON-LISP::GET COMPILER::X 'COMPILER::PROCLAIMED-CLOSURE)
+          COMMON-LISP::T))
+    '(PCL::TRACE-METHOD-INTERNAL PCL::FDEFINE-CAREFULLY
+         PCL::REDEFINE-FUNCTION PCL::DO-STANDARD-DEFSETF-1)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::*)
-             COMMON-LISP::T)
-         PCL::EMIT-DLAP PCL::GET-SECONDARY-DISPATCH-FUNCTION1)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
+             (COMMON-LISP::VALUES COMMON-LISP::T COMMON-LISP::T))
+         PCL::MAKE-CLASS-PREDICATE-NAME PCL::MAKE-KEYWORD)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T
-                 (COMMON-LISP::INTEGER -9223372036854775808
-                     9223372036854775807))
-             COMMON-LISP::T)
-         PCL::COMPUTE-STD-CPL-PHASE-3)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
+             (COMMON-LISP::INTEGER 1 255))
+         PCL::CACHE-NKEYS)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T)
-             COMMON-LISP::T)
-         PCL::EXPAND-DEFMETHOD PCL::LOAD-DEFMETHOD-INTERNAL)) 
+         (COMMON-LISP::FUNCTION (COMMON-LISP::T)
+             (COMMON-LISP::INTEGER 1 256))
+         PCL::CACHE-LINE-SIZE)) 
 (COMMON-LISP::PROCLAIM
     '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION
-             (COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::T COMMON-LISP::T COMMON-LISP::T
-                 COMMON-LISP::*)
+         (COMMON-LISP::FUNCTION (COMMON-LISP::FIXNUM COMMON-LISP::T)
              COMMON-LISP::T)
-         PCL::BOOTSTRAP-INITIALIZE-CLASS)) 
-(COMMON-LISP::PROCLAIM
-    '(COMMON-LISP::FTYPE
-         (COMMON-LISP::FUNCTION (COMMON-LISP::T) COMMON-LISP::LIST)
-         PCL::PV-TABLE-CALL-LIST PCL::CACHE-OVERFLOW
-         PCL::PV-TABLE-SLOT-NAME-LISTS)) 
+         PCL::%CCLOSURE-ENV-NTHCDR)) 
 (IN-PACKAGE "PCL")
 
-(DOLIST (V '(|(FAST-WRITER-METHOD SLOT-OBJECT DIRECT-METHODS)|
+(DOLIST (V '(|(FAST-WRITER-METHOD SLOT-OBJECT FROM-DEFCLASS-P)|
+                |(FAST-WRITER-METHOD SLOT-OBJECT DIRECT-METHODS)|
                 |(FAST-WRITER-METHOD SLOT-OBJECT SLOTS)|
                 |(FAST-WRITER-METHOD SLOT-CLASS SLOTS)|
                 |(FAST-WRITER-METHOD SLOT-OBJECT DIRECT-SLOTS)|
                 |(FAST-WRITER-METHOD SLOT-CLASS DIRECT-SLOTS)|
-                |(FAST-WRITER-METHOD SLOT-OBJECT FROM-DEFCLASS-P)|
                 |(FAST-WRITER-METHOD SLOT-OBJECT METHODS)|
                 |(FAST-WRITER-METHOD STANDARD-GENERIC-FUNCTION METHODS)|
                 |(FAST-WRITER-METHOD SLOT-OBJECT OPTIONS)|
@@ -1063,16 +1148,17 @@
                 COMPATIBLE-META-CLASS-CHANGE-P
                 |(FAST-READER-METHOD SLOT-OBJECT CLASS-EQ-SPECIALIZER)|
                 |(FAST-READER-METHOD CLASS CLASS-EQ-SPECIALIZER)|
-                |(BOUNDP READER-FUNCTION)| |(BOUNDP PREDICATE-NAME)|
-                |(BOUNDP READERS)| UPDATE-GF-DFUN
-                |(BOUNDP CLASS-PRECEDENCE-LIST)|
+                |(BOUNDP READER-FUNCTION)| TRACE-METHOD-INTERNAL
+                |(BOUNDP PREDICATE-NAME)| |(BOUNDP READERS)|
+                UPDATE-GF-DFUN |(BOUNDP CLASS-PRECEDENCE-LIST)|
                 |(BOUNDP ACCESSOR-FLAGS)| |(BOUNDP LOCATION)|
                 |(BOUNDP DOCUMENTATION)| SPECIALIZER-OBJECT
                 |(BOUNDP INCOMPATIBLE-SUPERCLASS-LIST)|
                 ACCESSOR-METHOD-SLOT-NAME |(BOUNDP SPECIALIZERS)|
                 |(BOUNDP IDENTITY-WITH-ONE-ARGUMENT)|
                 |(FAST-BOUNDP-METHOD SLOT-OBJECT DEFSTRUCT-ACCESSOR-SYMBOL)|
-                SPECIALIZER-CLASS |(BOUNDP PRETTY-ARGLIST)|
+                REDEFINE-FUNCTION SPECIALIZER-CLASS
+                |(BOUNDP PRETTY-ARGLIST)|
                 |PCL::PCL-CLASS class predicate|
                 |PCL::STD-CLASS class predicate|
                 |(BOUNDP DEFSTRUCT-FORM)|
@@ -1110,104 +1196,104 @@
                 |(BOUNDP OPTIONS)| |(WRITER METHOD)|
                 |PCL::DEPENDENT-UPDATE-MIXIN class predicate|
                 GENERIC-FUNCTION-PRETTY-ARGLIST |(WRITER SOURCE)|
-                |(FAST-METHOD SLOTS-TO-INSPECT (SLOT-CLASS SLOT-OBJECT))|
-                |(FAST-METHOD SPECIALIZER-DIRECT-GENERIC-FUNCTIONS (SPECIALIZER-WITH-OBJECT))|
                 |(FAST-METHOD SPECIALIZER-DIRECT-METHODS (SPECIALIZER-WITH-OBJECT))|
-                |(FAST-METHOD UPDATE-INSTANCE-FOR-DIFFERENT-CLASS (STANDARD-OBJECT STANDARD-OBJECT))|
+                |(FAST-METHOD SPECIALIZER-DIRECT-GENERIC-FUNCTIONS (SPECIALIZER-WITH-OBJECT))|
                 |(FAST-METHOD REINITIALIZE-INSTANCE (SLOT-OBJECT))|
+                |(FAST-METHOD UPDATE-INSTANCE-FOR-DIFFERENT-CLASS (STANDARD-OBJECT STANDARD-OBJECT))|
+                |(FAST-METHOD SLOTS-TO-INSPECT (SLOT-CLASS SLOT-OBJECT))|
                 |(FAST-METHOD INITIALIZE-INSTANCE (SLOT-OBJECT))|
+                |(FAST-METHOD SPECIALIZER-METHOD-TABLE (EQL-SPECIALIZER))|
                 |(FAST-METHOD SPECIALIZER-CLASS (EQL-SPECIALIZER))|
-                |(FAST-METHOD SAME-SPECIALIZER-P (EQL-SPECIALIZER EQL-SPECIALIZER))|
-                |(FAST-METHOD SAME-SPECIALIZER-P (CLASS-EQ-SPECIALIZER CLASS-EQ-SPECIALIZER))|
-                |(FAST-METHOD SAME-SPECIALIZER-P (SPECIALIZER SPECIALIZER))|
                 |(FAST-METHOD SPECIALIZER-METHOD-TABLE (CLASS-EQ-SPECIALIZER))|
-                |(FAST-METHOD SPECIALIZER-METHOD-TABLE (EQL-SPECIALIZER))|
+                |(FAST-METHOD SAME-SPECIALIZER-P (SPECIALIZER SPECIALIZER))|
+                |(FAST-METHOD SAME-SPECIALIZER-P (CLASS-EQ-SPECIALIZER CLASS-EQ-SPECIALIZER))|
+                |(FAST-METHOD SAME-SPECIALIZER-P (EQL-SPECIALIZER EQL-SPECIALIZER))|
                 MAKE-BOUNDP-METHOD-FUNCTION
                 |(FAST-METHOD (SETF DOCUMENTATION) (T DOCUMENTATION-MIXIN))|
                 |(FAST-METHOD DOCUMENTATION (DOCUMENTATION-MIXIN))|
                 |PCL::METAOBJECT class predicate|
-                |(FAST-METHOD ACCESSOR-METHOD-SLOT-NAME (TRACED-METHOD))|
-                |(FAST-METHOD METHOD-QUALIFIERS (TRACED-METHOD))|
-                |(FAST-METHOD METHOD-SPECIALIZERS (TRACED-METHOD))|
-                |(FAST-METHOD METHOD-LAMBDA-LIST (TRACED-METHOD))|
-                |(FAST-METHOD METHOD-PRETTY-ARGLIST (STANDARD-METHOD))|
+                |(FAST-METHOD (SETF SLOT-VALUE-USING-CLASS) (T STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
+                |(FAST-METHOD SLOT-BOUNDP-USING-CLASS (STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
+                |(FAST-METHOD SLOT-BOUNDP-USING-CLASS (STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
+                |(FAST-METHOD SLOT-MAKUNBOUND-USING-CLASS (STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
+                |(FAST-METHOD SLOT-MAKUNBOUND-USING-CLASS (STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
+                |(FAST-METHOD GENERIC-FUNCTION-LAMBDA-LIST (GENERIC-FUNCTION))|
+                |(FAST-METHOD ACCESSOR-METHOD-CLASS (STANDARD-WRITER-METHOD))|
+                |(FAST-METHOD INITIALIZE-INTERNAL-SLOT-FUNCTIONS (EFFECTIVE-SLOT-DEFINITION))|
+                |(FAST-METHOD ACCESSOR-METHOD-CLASS (STANDARD-ACCESSOR-METHOD))|
                 |(FAST-METHOD GENERIC-FUNCTION-PRETTY-ARGLIST (STANDARD-GENERIC-FUNCTION))|
-                |(FAST-METHOD FUNCTION-KEYWORDS (STANDARD-METHOD))|
-                |(FAST-METHOD COMPUTE-DISCRIMINATING-FUNCTION (STANDARD-GENERIC-FUNCTION))|
-                |(FAST-METHOD REINITIALIZE-INSTANCE :AFTER (STANDARD-GENERIC-FUNCTION))|
-                |(FAST-METHOD INITIALIZE-INSTANCE :AFTER (STANDARD-GENERIC-FUNCTION))|
                 |(FAST-METHOD GF-FAST-METHOD-FUNCTION-P (STANDARD-GENERIC-FUNCTION))|
-                |(FAST-METHOD GENERIC-FUNCTION-LAMBDA-LIST (GENERIC-FUNCTION))|
-                |(FAST-METHOD COMPUTE-DISCRIMINATING-FUNCTION-ARGLIST-INFO (STANDARD-GENERIC-FUNCTION))|
+                |(FAST-METHOD SLOT-DEFINITION-ALLOCATION (STRUCTURE-SLOT-DEFINITION))|
                 |(FAST-METHOD METHOD-QUALIFIERS (STANDARD-METHOD))|
+                |(FAST-METHOD INITIALIZE-INSTANCE :AFTER (STANDARD-GENERIC-FUNCTION))|
+                |(FAST-METHOD ADD-DIRECT-METHOD (SPECIALIZER-WITH-OBJECT METHOD))|
                 |(FAST-METHOD REINITIALIZE-INSTANCE (STANDARD-METHOD))|
-                |(FAST-METHOD ACCESSOR-METHOD-CLASS (STANDARD-WRITER-METHOD))|
-                |(FAST-METHOD ACCESSOR-METHOD-CLASS (STANDARD-ACCESSOR-METHOD))|
-                |(FAST-METHOD METHOD-FUNCTION (STANDARD-METHOD))|
-                |(FAST-METHOD CHANGE-CLASS (T SYMBOL))|
-                |(FAST-METHOD MAKE-INSTANCES-OBSOLETE (SYMBOL))|
                 |(FAST-METHOD REMOVE-DIRECT-METHOD (SPECIALIZER-WITH-OBJECT METHOD))|
-                |(FAST-METHOD ADD-DIRECT-METHOD (SPECIALIZER-WITH-OBJECT METHOD))|
-                |(FAST-METHOD REMOVE-DIRECT-METHOD (CLASS METHOD))|
+                |(FAST-METHOD REINITIALIZE-INSTANCE :AFTER (STANDARD-GENERIC-FUNCTION))|
                 |(FAST-METHOD ADD-DIRECT-METHOD (CLASS METHOD))|
+                |(FAST-METHOD REMOVE-DIRECT-METHOD (CLASS METHOD))|
+                |(FAST-METHOD METHOD-SPECIALIZERS (TRACED-METHOD))|
+                |(FAST-METHOD ACCESSOR-METHOD-SLOT-NAME (TRACED-METHOD))|
+                |(FAST-METHOD COMPUTE-DISCRIMINATING-FUNCTION-ARGLIST-INFO (STANDARD-GENERIC-FUNCTION))|
+                |(FAST-METHOD METHOD-FUNCTION (STANDARD-METHOD))|
+                |(FAST-METHOD METHOD-LAMBDA-LIST (TRACED-METHOD))|
+                |(FAST-METHOD METHOD-QUALIFIERS (TRACED-METHOD))|
+                |(FAST-METHOD FUNCTION-KEYWORDS (STANDARD-METHOD))|
+                |(FAST-METHOD COMPUTE-DISCRIMINATING-FUNCTION (STANDARD-GENERIC-FUNCTION))|
+                |(FAST-METHOD MAKE-INSTANCES-OBSOLETE (SYMBOL))|
+                |(FAST-METHOD METHOD-PRETTY-ARGLIST (STANDARD-METHOD))|
+                |(FAST-METHOD SLOT-VALUE-USING-CLASS (STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
                 |(FAST-METHOD (SETF DOCUMENTATION) (T STANDARD-SLOT-DEFINITION))|
-                |(FAST-METHOD DOCUMENTATION (STANDARD-SLOT-DEFINITION))|
-                |(FAST-METHOD SLOT-DEFINITION-ALLOCATION (STRUCTURE-SLOT-DEFINITION))|
-                |(FAST-METHOD INITIALIZE-INTERNAL-SLOT-FUNCTIONS (EFFECTIVE-SLOT-DEFINITION))|
+                |(FAST-METHOD SLOT-VALUE-USING-CLASS (STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
                 |(FAST-METHOD MAKE-INSTANCE (SYMBOL))|
-                |(FAST-METHOD SLOT-MAKUNBOUND-USING-CLASS (STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
-                |(FAST-METHOD SLOT-BOUNDP-USING-CLASS (STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
+                |(FAST-METHOD DOCUMENTATION (STANDARD-SLOT-DEFINITION))|
+                |(FAST-METHOD CHANGE-CLASS (T SYMBOL))|
                 |(FAST-METHOD (SETF SLOT-VALUE-USING-CLASS) (T STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
-                |(FAST-METHOD SLOT-VALUE-USING-CLASS (STRUCTURE-CLASS STRUCTURE-OBJECT STRUCTURE-EFFECTIVE-SLOT-DEFINITION))|
-                |(FAST-METHOD SLOT-MAKUNBOUND-USING-CLASS (STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
-                |(FAST-METHOD SLOT-BOUNDP-USING-CLASS (STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
-                |(FAST-METHOD (SETF SLOT-VALUE-USING-CLASS) (T STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
-                |(FAST-METHOD SLOT-VALUE-USING-CLASS (STD-CLASS STANDARD-OBJECT STANDARD-EFFECTIVE-SLOT-DEFINITION))|
-                |(FAST-METHOD SPECIALIZER-CLASS (CLASS))|
-                |(FAST-METHOD SAME-SPECIALIZER-P (CLASS CLASS))|
-                |(FAST-METHOD ALLOCATE-INSTANCE (FUNCALLABLE-STANDARD-CLASS))|
-                |(FAST-METHOD VALIDATE-SUPERCLASS (FUNCALLABLE-STANDARD-CLASS STANDARD-CLASS))|
-                |(FAST-METHOD RAW-INSTANCE-ALLOCATOR (FUNCALLABLE-STANDARD-CLASS))|
-                |(FAST-METHOD SLOTS-FETCHER (FUNCALLABLE-STANDARD-CLASS))|
+                |(FAST-METHOD ENSURE-CLASS-USING-CLASS (T PCL-CLASS))|
                 |(FAST-METHOD WRAPPER-FETCHER (FUNCALLABLE-STANDARD-CLASS))|
-                |(FAST-METHOD COMPUTE-CLASS-PRECEDENCE-LIST (SLOT-CLASS))|
-                |(FAST-METHOD VALIDATE-SUPERCLASS (SLOT-CLASS FORWARD-REFERENCED-CLASS))|
-                |(FAST-METHOD VALIDATE-SUPERCLASS (CLASS BUILT-IN-CLASS))|
                 |(FAST-METHOD CLASS-DEFAULT-INITARGS (BUILT-IN-CLASS))|
-                |(FAST-METHOD CLASS-DIRECT-DEFAULT-INITARGS (BUILT-IN-CLASS))|
-                |(FAST-METHOD CLASS-SLOTS (BUILT-IN-CLASS))|
-                |(FAST-METHOD CLASS-DIRECT-SLOTS (BUILT-IN-CLASS))|
-                |(FAST-METHOD CHANGE-CLASS (STANDARD-OBJECT FUNCALLABLE-STANDARD-CLASS))|
-                |(FAST-METHOD CHANGE-CLASS (STANDARD-OBJECT STANDARD-CLASS))|
-                |(FAST-METHOD MAKE-INSTANCES-OBSOLETE (STD-CLASS))|
-                |(FAST-METHOD VALIDATE-SUPERCLASS (CLASS CLASS))|
+                |(FAST-METHOD COMPUTE-SLOTS (STD-CLASS))|
+                |(FAST-METHOD COMPUTE-CLASS-PRECEDENCE-LIST (SLOT-CLASS))|
                 |(FAST-METHOD COMPUTE-SLOTS :AROUND (STRUCTURE-CLASS))|
-                |(FAST-METHOD COMPUTE-SLOTS (STRUCTURE-CLASS))|
+                |(FAST-METHOD SPECIALIZER-DIRECT-GENERIC-FUNCTIONS (CLASS))|
+                |(FAST-METHOD RAW-INSTANCE-ALLOCATOR (FUNCALLABLE-STANDARD-CLASS))|
+                |(FAST-METHOD WRAPPER-FETCHER (STANDARD-CLASS))|
+                |(FAST-METHOD MAKE-INSTANCES-OBSOLETE (STD-CLASS))|
+                |(FAST-METHOD CLASS-SLOT-CELLS (STD-CLASS))|
+                |(FAST-METHOD SPECIALIZER-CLASS (CLASS))|
+                |(FAST-METHOD CLASS-CONSTRUCTORS (SLOT-CLASS))|
+                |(FAST-METHOD CLASS-FINALIZED-P (PCL-CLASS))|
                 |(FAST-METHOD COMPUTE-SLOTS :AROUND (STD-CLASS))|
-                |(FAST-METHOD COMPUTE-SLOTS (STD-CLASS))|
+                |(FAST-METHOD CLASS-SLOTS (BUILT-IN-CLASS))|
+                |(FAST-METHOD RAW-INSTANCE-ALLOCATOR (STANDARD-CLASS))|
+                |(FAST-METHOD SPECIALIZER-DIRECT-METHODS (CLASS))|
+                |(FAST-METHOD SLOTS-FETCHER (STANDARD-CLASS))|
+                |(FAST-METHOD FINALIZE-INHERITANCE (STRUCTURE-CLASS))|
                 |(FAST-METHOD COMPUTE-DEFAULT-INITARGS (SLOT-CLASS))|
+                |(FAST-METHOD CLASS-DIRECT-DEFAULT-INITARGS (SLOT-CLASS))|
                 |(FAST-METHOD FINALIZE-INHERITANCE (STD-CLASS))|
-                |(FAST-METHOD FINALIZE-INHERITANCE (STRUCTURE-CLASS))|
-                |(FAST-METHOD REINITIALIZE-INSTANCE :AFTER (SLOT-CLASS))|
-                |(FAST-METHOD REINITIALIZE-INSTANCE :BEFORE (SLOT-CLASS))|
-                |(FAST-METHOD ENSURE-CLASS-USING-CLASS (T PCL-CLASS))|
-                |(FAST-METHOD SPECIALIZER-DIRECT-GENERIC-FUNCTIONS (CLASS))|
-                |(FAST-METHOD SPECIALIZER-DIRECT-METHODS (CLASS))|
+                |(FAST-METHOD CLASS-DIRECT-SLOTS (BUILT-IN-CLASS))|
+                |(FAST-METHOD COMPUTE-SLOTS (STRUCTURE-CLASS))|
+                |(FAST-METHOD CLASS-DEFAULT-INITARGS (SLOT-CLASS))|
+                |(FAST-METHOD SLOTS-FETCHER (FUNCALLABLE-STANDARD-CLASS))|
+                |(FAST-METHOD CLASS-DIRECT-DEFAULT-INITARGS (BUILT-IN-CLASS))|
+                |(FAST-METHOD VALIDATE-SUPERCLASS (FUNCALLABLE-STANDARD-CLASS STANDARD-CLASS))|
+                |(FAST-METHOD ALLOCATE-INSTANCE (FUNCALLABLE-STANDARD-CLASS))|
+                |(FAST-METHOD SAME-SPECIALIZER-P (CLASS CLASS))|
+                |(FAST-METHOD MAKE-INSTANCE (CLASS))|
+                |(FAST-METHOD CHANGE-CLASS (STANDARD-OBJECT STANDARD-CLASS))|
                 |(FAST-METHOD REMOVE-DIRECT-SUBCLASS (CLASS CLASS))|
                 |(FAST-METHOD ADD-DIRECT-SUBCLASS (CLASS CLASS))|
-                |(FAST-METHOD CLASS-SLOT-CELLS (STD-CLASS))|
-                |(FAST-METHOD CLASS-CONSTRUCTORS (SLOT-CLASS))|
-                |(FAST-METHOD CLASS-DEFAULT-INITARGS (SLOT-CLASS))|
-                |(FAST-METHOD CLASS-DIRECT-DEFAULT-INITARGS (SLOT-CLASS))|
-                |(FAST-METHOD CLASS-PROTOTYPE (STRUCTURE-CLASS))|
+                |(FAST-METHOD VALIDATE-SUPERCLASS (CLASS BUILT-IN-CLASS))|
+                |(FAST-METHOD ALLOCATE-INSTANCE (STANDARD-CLASS))|
+                |(FAST-METHOD VALIDATE-SUPERCLASS (SLOT-CLASS FORWARD-REFERENCED-CLASS))|
+                |(FAST-METHOD VALIDATE-SUPERCLASS (CLASS CLASS))|
+                |(FAST-METHOD REINITIALIZE-INSTANCE :BEFORE (SLOT-CLASS))|
+                |(FAST-METHOD CHANGE-CLASS (STANDARD-OBJECT FUNCALLABLE-STANDARD-CLASS))|
                 |(FAST-METHOD CLASS-PROTOTYPE (STD-CLASS))|
-                |(FAST-METHOD CLASS-FINALIZED-P (PCL-CLASS))|
-                |(FAST-METHOD MAKE-INSTANCE (CLASS))|
+                |(FAST-METHOD CLASS-PROTOTYPE (STRUCTURE-CLASS))|
                 |(FAST-METHOD ALLOCATE-INSTANCE (STRUCTURE-CLASS))|
-                |(FAST-METHOD ALLOCATE-INSTANCE (STANDARD-CLASS))|
-                |(FAST-METHOD RAW-INSTANCE-ALLOCATOR (STANDARD-CLASS))|
-                |(FAST-METHOD SLOTS-FETCHER (STANDARD-CLASS))|
-                |(FAST-METHOD WRAPPER-FETCHER (STANDARD-CLASS))|
+                |(FAST-METHOD REINITIALIZE-INSTANCE :AFTER (SLOT-CLASS))|
                 CLASS-PREDICATE-NAME
                 |PCL::STRUCTURE-SLOT-DEFINITION class predicate|
                 |PCL::STRUCTURE-DIRECT-SLOT-DEFINITION class predicate|
@@ -1233,8 +1319,8 @@
                 |(WRITER PREDICATE-NAME)| |(WRITER READERS)|
                 |(READER WRITER-FUNCTION)| |(READER INITFUNCTION)|
                 INITIALIZE-INTERNAL-SLOT-FUNCTIONS
-                |SETF PCL SLOT-DEFINITION-TYPE|
-                |(WRITER CLASS-PRECEDENCE-LIST)| |(READER WRITERS)|
+                |SETF PCL SLOT-DEFINITION-TYPE| |(READER WRITERS)|
+                |(WRITER CLASS-PRECEDENCE-LIST)|
                 |(WRITER ACCESSOR-FLAGS)| |(READER INITFORM)|
                 METHOD-COMBINATION-P |(WRITER LOCATION)|
                 |(WRITER DOCUMENTATION)|
@@ -1248,11 +1334,11 @@
                 |(READER ALLOCATION)| |(WRITER SPECIALIZERS)|
                 |(CALL REAL-ENSURE-GF-USING-CLASS--NULL)|
                 |(WRITER IDENTITY-WITH-ONE-ARGUMENT)|
-                |(SETF METHOD-GENERIC-FUNCTION)| LEGAL-SPECIALIZERS-P
-                |(WRITER PRETTY-ARGLIST)| |SETF PCL OBJECT-PLIST|
-                |(WRITER DEFSTRUCT-FORM)| |(READER FUNCTION)|
-                |(READER GENERIC-FUNCTION)| |(READER LAMBDA-LIST)|
-                |(READER SLOT-DEFINITION)|
+                |(SETF METHOD-GENERIC-FUNCTION)|
+                |(WRITER PRETTY-ARGLIST)| LEGAL-SPECIALIZERS-P
+                |SETF PCL OBJECT-PLIST| |(WRITER DEFSTRUCT-FORM)|
+                |(READER FUNCTION)| |(READER GENERIC-FUNCTION)|
+                |(READER LAMBDA-LIST)| |(READER SLOT-DEFINITION)|
                 |PCL::CLASS-PROTOTYPE-SPECIALIZER class predicate|
                 |SETF PCL SLOT-DEFINITION-INITFORM|
                 |SETF PCL CLASS-DEFSTRUCT-FORM|
@@ -1273,17 +1359,16 @@
                 |SETF PCL SLOT-DEFINITION-ALLOCATION|
                 |SETF PCL SLOT-DEFINITION-INITFUNCTION|
                 |(WRITER SLOT-NAME)| |(BOUNDP NAME)|
-                |(WRITER ALLOCATION)| |(READER FAST-FUNCTION)|
+                |(READER FAST-FUNCTION)| |(WRITER ALLOCATION)|
                 |(READER METHOD-CLASS)| |(SETF OBJECT-PLIST)|
                 |(READER INTERNAL-WRITER-FUNCTION)|
                 |(READER INTERNAL-READER-FUNCTION)|
                 |(READER METHOD-COMBINATION)|
                 METHOD-COMBINATION-OPTIONS |(READER DIRECT-SLOTS)|
                 |(READER DIRECT-METHODS)|
-                |SETF PCL SLOT-DEFINITION-READERS|
-                |(READER BOUNDP-FUNCTION)| |(WRITER FUNCTION)|
-                |(WRITER GENERIC-FUNCTION)| |SETF PCL DOCUMENTATION|
-                |(READER DIRECT-SUBCLASSES)|
+                |SETF PCL SLOT-DEFINITION-READERS| |(WRITER FUNCTION)|
+                |(WRITER GENERIC-FUNCTION)| |(READER BOUNDP-FUNCTION)|
+                |SETF PCL DOCUMENTATION| |(READER DIRECT-SUBCLASSES)|
                 |(READER DIRECT-SUPERCLASSES)| |(WRITER LAMBDA-LIST)|
                 FUNCALLABLE-STANDARD-CLASS-P
                 |(FAST-WRITER-METHOD SLOT-OBJECT METHOD)|
@@ -1294,7 +1379,7 @@
                 |SETF PCL SLOT-VALUE-USING-CLASS|
                 |(FAST-WRITER-METHOD SLOT-OBJECT DEFSTRUCT-ACCESSOR-SYMBOL)|
                 |(FAST-WRITER-METHOD STRUCTURE-SLOT-DEFINITION DEFSTRUCT-ACCESSOR-SYMBOL)|
-                |(WRITER PROTOTYPE)| |(BOUNDP OBJECT)| |(BOUNDP TYPE)|
+                |(WRITER PROTOTYPE)| |(BOUNDP TYPE)| |(BOUNDP OBJECT)|
                 CLASS-CAN-PRECEDE-LIST |SETF PCL CLASS-DIRECT-SLOTS|
                 |SETF PCL CLASS-SLOTS| SLOT-ACCESSOR-FUNCTION
                 |(BOUNDP PLIST)|
@@ -1309,11 +1394,11 @@
                 |(FAST-WRITER-METHOD SLOT-OBJECT ARG-INFO)|
                 |PCL::PLIST-MIXIN class predicate|
                 |(WRITER FAST-FUNCTION)| |(WRITER METHOD-CLASS)|
-                |(FAST-WRITER-METHOD SLOT-OBJECT WRAPPER)|
+                |(FAST-WRITER-METHOD SLOT-OBJECT WRAPPER)| GET-METHOD
                 |(WRITER INTERNAL-WRITER-FUNCTION)|
                 |(WRITER INTERNAL-READER-FUNCTION)|
-                |(WRITER METHOD-COMBINATION)| GET-METHOD
-                |(WRITER DIRECT-SLOTS)| |(WRITER DIRECT-METHODS)|
+                |(WRITER METHOD-COMBINATION)| |(WRITER DIRECT-SLOTS)|
+                |(WRITER DIRECT-METHODS)|
                 |(FAST-WRITER-METHOD SLOT-OBJECT INITARGS)|
                 |(FAST-WRITER-METHOD SLOT-DEFINITION INITARGS)|
                 |(FAST-WRITER-METHOD SLOT-OBJECT OPERATOR)|
@@ -1383,18 +1468,18 @@
                 |(FAST-READER-METHOD SLOT-DEFINITION READERS)|
                 |(FAST-READER-METHOD SLOT-OBJECT SPECIALIZERS)|
                 |(FAST-READER-METHOD STANDARD-METHOD SPECIALIZERS)|
-                |(FAST-READER-METHOD SHORT-METHOD-COMBINATION IDENTITY-WITH-ONE-ARGUMENT)|
-                |(FAST-READER-METHOD SLOT-OBJECT IDENTITY-WITH-ONE-ARGUMENT)|
                 |(FAST-READER-METHOD SPECIALIZER TYPE)|
                 |(FAST-READER-METHOD SLOT-OBJECT PROTOTYPE)|
                 |(FAST-READER-METHOD PCL-CLASS PROTOTYPE)|
+                |(FAST-READER-METHOD SLOT-DEFINITION TYPE)|
+                |(FAST-READER-METHOD SLOT-OBJECT TYPE)|
+                |(FAST-READER-METHOD STANDARD-METHOD-COMBINATION TYPE)|
+                |(FAST-READER-METHOD SHORT-METHOD-COMBINATION IDENTITY-WITH-ONE-ARGUMENT)|
+                |(FAST-READER-METHOD SLOT-OBJECT IDENTITY-WITH-ONE-ARGUMENT)|
                 |(FAST-READER-METHOD CLASS-EQ-SPECIALIZER OBJECT)|
                 |(FAST-READER-METHOD CLASS-PROTOTYPE-SPECIALIZER OBJECT)|
                 |(FAST-READER-METHOD SLOT-OBJECT OBJECT)|
                 |(FAST-READER-METHOD EQL-SPECIALIZER OBJECT)|
-                |(FAST-READER-METHOD SLOT-DEFINITION TYPE)|
-                |(FAST-READER-METHOD SLOT-OBJECT TYPE)|
-                |(FAST-READER-METHOD STANDARD-METHOD-COMBINATION TYPE)|
                 |(FAST-READER-METHOD SLOT-OBJECT DEFSTRUCT-FORM)|
                 |(FAST-READER-METHOD STRUCTURE-CLASS DEFSTRUCT-FORM)|
                 |(FAST-READER-METHOD SLOT-OBJECT INITFORM)|
@@ -1416,11 +1501,11 @@
                 |(FAST-READER-METHOD SLOT-CLASS SLOTS)|
                 |(FAST-READER-METHOD SLOT-OBJECT DIRECT-SLOTS)|
                 |(FAST-READER-METHOD SLOT-CLASS DIRECT-SLOTS)|
-                |(FAST-READER-METHOD SLOT-OBJECT FROM-DEFCLASS-P)|
                 |(FAST-READER-METHOD SLOT-OBJECT METHODS)|
                 |(FAST-READER-METHOD STANDARD-GENERIC-FUNCTION METHODS)|
                 |(FAST-READER-METHOD SLOT-OBJECT OPTIONS)|
                 |(FAST-READER-METHOD STANDARD-METHOD-COMBINATION OPTIONS)|
+                |(FAST-READER-METHOD SLOT-OBJECT FROM-DEFCLASS-P)|
                 |(FAST-READER-METHOD SLOT-OBJECT DIRECT-SUBCLASSES)|
                 |(FAST-READER-METHOD CLASS DIRECT-SUBCLASSES)|
                 |(FAST-READER-METHOD SLOT-OBJECT DIRECT-SUPERCLASSES)|
@@ -1458,8 +1543,8 @@
                 |(FAST-BOUNDP-METHOD SLOT-OBJECT READERS)|
                 |(FAST-BOUNDP-METHOD SLOT-OBJECT SPECIALIZERS)|
                 |(FAST-BOUNDP-METHOD SLOT-OBJECT PROTOTYPE)|
-                |(FAST-BOUNDP-METHOD SLOT-OBJECT OBJECT)|
                 |(FAST-BOUNDP-METHOD SLOT-OBJECT TYPE)|
+                |(FAST-BOUNDP-METHOD SLOT-OBJECT OBJECT)|
                 |(FAST-BOUNDP-METHOD SLOT-OBJECT DEFSTRUCT-FORM)|
                 |(FAST-BOUNDP-METHOD SLOT-OBJECT INITFORM)|
                 |(SETF SLOT-VALUE-USING-CLASS)|
@@ -1485,10 +1570,10 @@
                 |(SETF SLOT-DEFINITION-TYPE)|
                 |(SETF SLOT-DEFINITION-INITFORM)|
                 |(BOUNDP INITIALIZE-INFO)|
+                |(FAST-BOUNDP-METHOD SLOT-OBJECT FROM-DEFCLASS-P)|
                 |(FAST-BOUNDP-METHOD SLOT-OBJECT DIRECT-METHODS)|
                 |(FAST-BOUNDP-METHOD SLOT-OBJECT SLOTS)|
                 |(FAST-BOUNDP-METHOD SLOT-OBJECT DIRECT-SLOTS)|
-                |(FAST-BOUNDP-METHOD SLOT-OBJECT FROM-DEFCLASS-P)|
                 |(FAST-BOUNDP-METHOD SLOT-OBJECT METHODS)|
                 |(FAST-BOUNDP-METHOD SLOT-OBJECT OPTIONS)|
                 |(FAST-BOUNDP-METHOD SLOT-OBJECT DIRECT-SUBCLASSES)|
@@ -1498,94 +1583,94 @@
                 GENERIC-FUNCTION-P
                 |PCL::SLOT-DEFINITION class predicate| |(READER NAME)|
                 |(READER CLASS)|
-                |(FAST-METHOD DESCRIBE-OBJECT (CLASS T))|
-                |(FAST-METHOD DESCRIBE-OBJECT (STANDARD-GENERIC-FUNCTION T))|
-                |(FAST-METHOD DESCRIBE-OBJECT (SLOT-OBJECT T))|
-                |(FAST-METHOD DESCRIBE-OBJECT (T T))|
-                |(FAST-METHOD COMPUTE-EFFECTIVE-METHOD (GENERIC-FUNCTION LONG-METHOD-COMBINATION T))|
+                |(FAST-METHOD SHARED-INITIALIZE :AFTER (DOCUMENTATION-MIXIN T))|
+                |(FAST-METHOD SHARED-INITIALIZE :BEFORE (STANDARD-ACCESSOR-METHOD T))|
+                |(FAST-METHOD WRITER-METHOD-CLASS (SLOT-CLASS T))|
+                |(FAST-METHOD SHARED-INITIALIZE :AFTER (STANDARD-METHOD T))|
+                |(FAST-METHOD SLOT-UNBOUND (T T T))|
+                |(FAST-METHOD SHARED-INITIALIZE :AFTER (STRUCTURE-SLOT-DEFINITION T))|
+                |(FAST-METHOD REMOVE-NAMED-METHOD (T T))|
+                |(FAST-METHOD COMPUTE-SLOT-ACCESSOR-INFO (EFFECTIVE-SLOT-DEFINITION T T))|
+                |(FAST-METHOD SHARED-INITIALIZE :AFTER (STRUCTURE-CLASS T))|
+                |(FAST-METHOD (SETF DOCUMENTATION) (T T))|
                 |(FAST-METHOD COMPUTE-EFFECTIVE-METHOD (GENERIC-FUNCTION SHORT-METHOD-COMBINATION T))|
+                |(FAST-METHOD (SETF SLOT-ACCESSOR-STD-P) (T EFFECTIVE-SLOT-DEFINITION T))|
+                |(FAST-METHOD READER-METHOD-CLASS (SLOT-CLASS T))|
+                |(FAST-METHOD SHARED-INITIALIZE :BEFORE (BUILT-IN-CLASS T))|
                 |(FAST-METHOD FIND-METHOD-COMBINATION (GENERIC-FUNCTION (EQL STANDARD) T))|
-                |(FAST-METHOD UPDATE-GF-DFUN (STD-CLASS T))|
-                |(FAST-METHOD COMPUTE-APPLICABLE-METHODS-USING-CLASSES (GENERIC-FUNCTION T))|
-                |(FAST-METHOD COMPUTE-APPLICABLE-METHODS (GENERIC-FUNCTION T))|
-                |(FAST-METHOD REMOVE-NAMED-METHOD (T T))|
-                |(FAST-METHOD SHARED-INITIALIZE :BEFORE (STANDARD-GENERIC-FUNCTION T))|
-                |(FAST-METHOD PRINT-OBJECT (GENERIC-FUNCTION T))|
-                |(FAST-METHOD SHARED-INITIALIZE :AFTER (STANDARD-ACCESSOR-METHOD T))|
-                |(FAST-METHOD SHARED-INITIALIZE :AFTER (STANDARD-METHOD T))|
-                |(FAST-METHOD SHARED-INITIALIZE :BEFORE (STANDARD-ACCESSOR-METHOD T))|
-                |(FAST-METHOD SHARED-INITIALIZE :BEFORE (STANDARD-METHOD T))|
+                |(FAST-METHOD SHARED-INITIALIZE :AFTER (STD-CLASS T))|
+                |(FAST-METHOD INFORM-TYPE-SYSTEM-ABOUT-CLASS (STRUCTURE-CLASS T))|
                 |(FAST-METHOD LEGAL-SPECIALIZER-P (STANDARD-METHOD T))|
-                |(FAST-METHOD LEGAL-SPECIALIZERS-P (STANDARD-METHOD T))|
-                |(FAST-METHOD LEGAL-SLOT-NAME-P (STANDARD-METHOD T))|
-                |(FAST-METHOD LEGAL-QUALIFIER-P (STANDARD-METHOD T))|
-                |(FAST-METHOD LEGAL-QUALIFIERS-P (STANDARD-METHOD T))|
-                |(FAST-METHOD LEGAL-METHOD-FUNCTION-P (STANDARD-METHOD T))|
-                |(FAST-METHOD LEGAL-LAMBDA-LIST-P (STANDARD-METHOD T))|
+                |(FAST-METHOD MAKE-BOUNDP-METHOD-FUNCTION (SLOT-CLASS T))|
+                |(FAST-METHOD MAKE-READER-METHOD-FUNCTION (SLOT-CLASS T))|
+                |(FAST-METHOD COMPATIBLE-META-CLASS-CHANGE-P (T T))|
+                |(FAST-METHOD COMPUTE-EFFECTIVE-SLOT-DEFINITION-INITARGS (SLOT-CLASS T))|
+                |(FAST-METHOD DIRECT-SLOT-DEFINITION-CLASS (STRUCTURE-CLASS T))|
+                |(FAST-METHOD PRINT-OBJECT (CLASS T))|
+                |(FAST-METHOD PRINT-OBJECT (SLOT-DEFINITION T))|
                 |(FAST-METHOD LEGAL-DOCUMENTATION-P (STANDARD-METHOD T))|
+                |(FAST-METHOD INFORM-TYPE-SYSTEM-ABOUT-CLASS (STD-CLASS T))|
+                |(FAST-METHOD REMOVE-BOUNDP-METHOD (SLOT-CLASS T))|
+                |(FAST-METHOD SLOT-ACCESSOR-STD-P (EFFECTIVE-SLOT-DEFINITION T))|
+                |(FAST-METHOD REMOVE-DEPENDENT (DEPENDENT-UPDATE-MIXIN T))|
+                |(FAST-METHOD MAKE-READER-METHOD-FUNCTION (FUNCALLABLE-STANDARD-CLASS T))|
+                |(FAST-METHOD COMPUTE-EFFECTIVE-SLOT-DEFINITION-INITARGS :AROUND (STRUCTURE-CLASS T))|
                 |(FAST-METHOD PRINT-OBJECT (STANDARD-ACCESSOR-METHOD T))|
                 |(FAST-METHOD PRINT-OBJECT (STANDARD-METHOD T))|
-                |(FAST-METHOD INFORM-TYPE-SYSTEM-ABOUT-CLASS (STRUCTURE-CLASS T))|
-                |(FAST-METHOD SHARED-INITIALIZE :AFTER (STRUCTURE-SLOT-DEFINITION T))|
-                |(FAST-METHOD SHARED-INITIALIZE :AFTER (STANDARD-SLOT-DEFINITION T))|
-                |(FAST-METHOD PRINT-OBJECT (STANDARD-METHOD-COMBINATION T))|
-                |(FAST-METHOD PRINT-OBJECT (SLOT-DEFINITION T))|
-                |(FAST-METHOD PRINT-OBJECT (CLASS T))|
-                |(FAST-METHOD PRINT-OBJECT (T T))|
-                |(FAST-METHOD MAKE-WRITER-METHOD-FUNCTION (FUNCALLABLE-STANDARD-CLASS T))|
-                |(FAST-METHOD MAKE-READER-METHOD-FUNCTION (FUNCALLABLE-STANDARD-CLASS T))|
+                |(FAST-METHOD LEGAL-LAMBDA-LIST-P (STANDARD-METHOD T))|
+                |(FAST-METHOD LEGAL-METHOD-FUNCTION-P (STANDARD-METHOD T))|
+                |(FAST-METHOD DIRECT-SLOT-DEFINITION-CLASS (STD-CLASS T))|
+                |(FAST-METHOD EFFECTIVE-SLOT-DEFINITION-CLASS (STD-CLASS T))|
+                |(FAST-METHOD MAKE-WRITER-METHOD-FUNCTION (SLOT-CLASS T))|
+                |(FAST-METHOD LEGAL-QUALIFIER-P (STANDARD-METHOD T))|
+                |(FAST-METHOD UPDATE-GF-DFUN (STD-CLASS T))|
+                |(FAST-METHOD REMOVE-READER-METHOD (SLOT-CLASS T))|
                 |(FAST-METHOD MAP-DEPENDENTS (DEPENDENT-UPDATE-MIXIN T))|
-                |(FAST-METHOD REMOVE-DEPENDENT (DEPENDENT-UPDATE-MIXIN T))|
+                |(FAST-METHOD COMPUTE-APPLICABLE-METHODS (GENERIC-FUNCTION T))|
                 |(FAST-METHOD ADD-DEPENDENT (DEPENDENT-UPDATE-MIXIN T))|
-                |(FAST-METHOD SHARED-INITIALIZE :BEFORE (BUILT-IN-CLASS T))|
-                |(FAST-METHOD COMPATIBLE-META-CLASS-CHANGE-P (T T))|
-                |(FAST-METHOD INFORM-TYPE-SYSTEM-ABOUT-CLASS (STD-CLASS T))|
-                |(FAST-METHOD MAKE-BOUNDP-METHOD-FUNCTION (SLOT-CLASS T))|
-                |(FAST-METHOD MAKE-WRITER-METHOD-FUNCTION (SLOT-CLASS T))|
-                |(FAST-METHOD MAKE-READER-METHOD-FUNCTION (SLOT-CLASS T))|
-                |(FAST-METHOD REMOVE-BOUNDP-METHOD (SLOT-CLASS T))|
+                |(FAST-METHOD EFFECTIVE-SLOT-DEFINITION-CLASS (STRUCTURE-CLASS T))|
+                |(FAST-METHOD LEGAL-SLOT-NAME-P (STANDARD-METHOD T))|
+                |(FAST-METHOD MAKE-WRITER-METHOD-FUNCTION (FUNCALLABLE-STANDARD-CLASS T))|
                 |(FAST-METHOD REMOVE-WRITER-METHOD (SLOT-CLASS T))|
-                |(FAST-METHOD REMOVE-READER-METHOD (SLOT-CLASS T))|
-                |(FAST-METHOD ADD-BOUNDP-METHOD (SLOT-CLASS T T))|
-                |(FAST-METHOD ADD-WRITER-METHOD (SLOT-CLASS T T))|
-                |(FAST-METHOD WRITER-METHOD-CLASS (SLOT-CLASS T))|
+                |(FAST-METHOD PRINT-OBJECT (STANDARD-METHOD-COMBINATION T))|
+                |(FAST-METHOD PRINT-OBJECT (T T))|
+                |(FAST-METHOD PRINT-OBJECT (GENERIC-FUNCTION T))|
                 |(FAST-METHOD ADD-READER-METHOD (SLOT-CLASS T T))|
-                |(FAST-METHOD READER-METHOD-CLASS (SLOT-CLASS T))|
-                |(FAST-METHOD COMPUTE-EFFECTIVE-SLOT-DEFINITION-INITARGS :AROUND (STRUCTURE-CLASS T))|
-                |(FAST-METHOD COMPUTE-EFFECTIVE-SLOT-DEFINITION-INITARGS (SLOT-CLASS T))|
-                |(FAST-METHOD EFFECTIVE-SLOT-DEFINITION-CLASS (STRUCTURE-CLASS T))|
-                |(FAST-METHOD EFFECTIVE-SLOT-DEFINITION-CLASS (STD-CLASS T))|
-                |(FAST-METHOD COMPUTE-EFFECTIVE-SLOT-DEFINITION (SLOT-CLASS T))|
-                |(FAST-METHOD DIRECT-SLOT-DEFINITION-CLASS (STD-CLASS T))|
-                |(FAST-METHOD DIRECT-SLOT-DEFINITION-CLASS (STRUCTURE-CLASS T))|
-                |(FAST-METHOD SHARED-INITIALIZE :AFTER (STRUCTURE-CLASS T))|
-                |(FAST-METHOD SHARED-INITIALIZE :BEFORE (CLASS T))|
-                |(FAST-METHOD SHARED-INITIALIZE :AFTER (STD-CLASS T))|
-                |(FAST-METHOD SHARED-INITIALIZE :AFTER (EQL-SPECIALIZER T))|
+                |(FAST-METHOD COMPUTE-EFFECTIVE-METHOD (GENERIC-FUNCTION LONG-METHOD-COMBINATION T))|
                 |(FAST-METHOD SHARED-INITIALIZE :AFTER (CLASS-EQ-SPECIALIZER T))|
-                |(FAST-METHOD (SETF DOCUMENTATION) (T T))|
-                |(FAST-METHOD SHARED-INITIALIZE :AFTER (DOCUMENTATION-MIXIN T))|
-                |(FAST-METHOD COMPUTE-SLOT-ACCESSOR-INFO (EFFECTIVE-SLOT-DEFINITION T T))|
-                |(FAST-METHOD (SETF SLOT-ACCESSOR-STD-P) (T EFFECTIVE-SLOT-DEFINITION T))|
-                |(FAST-METHOD SLOT-ACCESSOR-STD-P (EFFECTIVE-SLOT-DEFINITION T))|
+                |(FAST-METHOD ADD-WRITER-METHOD (SLOT-CLASS T T))|
+                |(FAST-METHOD ADD-BOUNDP-METHOD (SLOT-CLASS T T))|
+                |(FAST-METHOD SHARED-INITIALIZE (SLOT-OBJECT T))|
+                |(FAST-METHOD SHARED-INITIALIZE :AFTER (EQL-SPECIALIZER T))|
+                |(FAST-METHOD SHARED-INITIALIZE :AFTER (STANDARD-ACCESSOR-METHOD T))|
                 |(FAST-METHOD (SETF SLOT-ACCESSOR-FUNCTION) (T EFFECTIVE-SLOT-DEFINITION T))|
+                |(FAST-METHOD SHARED-INITIALIZE :AFTER (STANDARD-SLOT-DEFINITION T))|
+                |(FAST-METHOD (SETF CLASS-SLOT-VALUE) (T STD-CLASS T))|
+                |(FAST-METHOD SHARED-INITIALIZE :BEFORE (CLASS T))|
+                |(FAST-METHOD SHARED-INITIALIZE :BEFORE (STANDARD-METHOD T))|
+                |(FAST-METHOD SHARED-INITIALIZE :BEFORE (STANDARD-GENERIC-FUNCTION T))|
+                |(FAST-METHOD LEGAL-SPECIALIZERS-P (STANDARD-METHOD T))|
+                |(FAST-METHOD LEGAL-QUALIFIERS-P (STANDARD-METHOD T))|
+                |(FAST-METHOD CLASS-SLOT-VALUE (STD-CLASS T))|
+                |(FAST-METHOD DESCRIBE-OBJECT (CLASS T))|
                 |(FAST-METHOD SLOT-ACCESSOR-FUNCTION (EFFECTIVE-SLOT-DEFINITION T))|
-                |(FAST-METHOD SHARED-INITIALIZE (SLOT-OBJECT T))|
-                |(FAST-METHOD UPDATE-INSTANCE-FOR-REDEFINED-CLASS (STANDARD-OBJECT T T T))|
+                |(FAST-METHOD COMPUTE-EFFECTIVE-SLOT-DEFINITION (SLOT-CLASS T))|
+                |(FAST-METHOD DESCRIBE-OBJECT (T T))|
                 |(FAST-METHOD DEFAULT-INITARGS (SLOT-CLASS T))|
-                |(FAST-METHOD SLOT-UNBOUND (T T T))|
+                |(FAST-METHOD DESCRIBE-OBJECT (STANDARD-GENERIC-FUNCTION T))|
+                |(FAST-METHOD DESCRIBE-OBJECT (SLOT-OBJECT T))|
+                |(FAST-METHOD COMPUTE-APPLICABLE-METHODS-USING-CLASSES (GENERIC-FUNCTION T))|
                 |(FAST-METHOD SLOT-MISSING (T T T T))|
-                |(FAST-METHOD (SETF CLASS-SLOT-VALUE) (T STD-CLASS T))|
-                |(FAST-METHOD CLASS-SLOT-VALUE (STD-CLASS T))|
-                LEGAL-SLOT-NAME-P |(READER OBJECT)| |(READER TYPE)|
+                |(FAST-METHOD UPDATE-INSTANCE-FOR-REDEFINED-CLASS (STANDARD-OBJECT T T T))|
+                LEGAL-SLOT-NAME-P |(READER TYPE)| |(READER OBJECT)|
                 CLASS-WRAPPER |(READER PLIST)|
                 |(FAST-METHOD CLASS-PREDICATE-NAME (T))|
                 |(FAST-METHOD DOCUMENTATION (T))|
                 |(FAST-METHOD NO-APPLICABLE-METHOD (T))|
                 |(READER SLOTS)| |(WRITER NAME)| DEFINITION-SOURCE
                 |PCL::SLOT-OBJECT class predicate| DEFAULT-INITARGS
-                |(WRITER CLASS)| CLASS-SLOT-VALUE |(WRITER OBJECT)|
-                |(WRITER TYPE)|
+                |(WRITER CLASS)| CLASS-SLOT-VALUE |(WRITER TYPE)|
+                |(WRITER OBJECT)|
                 |(FAST-METHOD ENSURE-CLASS-USING-CLASS (T NULL))|
                 |(WRITER PLIST)| |(WRITER SLOTS)|
                 |PCL::DOCUMENTATION-MIXIN class predicate|
@@ -1625,10 +1710,10 @@
                 |COMMON-LISP::STANDARD-OBJECT class predicate|
                 |COMMON-LISP::BUILT-IN-CLASS class predicate|
                 |SETF PCL CLASS-SLOT-VALUE| |(SETF CLASS-SLOTS)|
-                |(SETF CLASS-DIRECT-SLOTS)| |(READER OPERATOR)|
-                |(CALL REAL-GET-METHOD)| |(CALL REAL-REMOVE-METHOD)|
-                |(CALL REAL-ADD-METHOD)| |(READER ARG-INFO)|
-                METHOD-COMBINATION-TYPE
+                |(SETF CLASS-DIRECT-SLOTS)| DO-STANDARD-DEFSETF-1
+                |(READER OPERATOR)| |(CALL REAL-GET-METHOD)|
+                |(CALL REAL-REMOVE-METHOD)| |(CALL REAL-ADD-METHOD)|
+                |(READER ARG-INFO)| METHOD-COMBINATION-TYPE
                 |(READER DEFSTRUCT-CONSTRUCTOR)|
                 |(INTERNAL-READER-METHOD STANDARD-GENERIC-FUNCTION ARG-INFO)|
                 |(READER INITIALIZE-INFO)| |(WRITER WRAPPER)|
@@ -1637,8 +1722,8 @@
                 |(WRITER DEFSTRUCT-ACCESSOR-SYMBOL)|
                 COMPUTE-SLOT-ACCESSOR-INFO |(READER INITARGS)|
                 |(WRITER CLASS-EQ-SPECIALIZER)|
-                STANDARD-BOUNDP-METHOD-P |(SETF DOCUMENTATION)|
-                RAW-INSTANCE-ALLOCATOR
+                STANDARD-BOUNDP-METHOD-P FDEFINE-CAREFULLY
+                |(SETF DOCUMENTATION)| RAW-INSTANCE-ALLOCATOR
                 |SETF PCL SLOT-DEFINITION-DEFSTRUCT-ACCESSOR-SYMBOL|
                 |SETF PCL CLASS-INITIALIZE-INFO| |(WRITER OPERATOR)|
                 |(WRITER ARG-INFO)|
@@ -1651,9 +1736,8 @@
                 METHOD-COMBINATION-DOCUMENTATION
                 |SETF PCL SLOT-DEFINITION-INITARGS|
                 REMOVE-BOUNDP-METHOD ADD-NAMED-METHOD
-                |(WRITER INITARGS)|
                 |SETF PCL CLASS-DEFSTRUCT-CONSTRUCTOR|
-                |(BOUNDP METHOD)|
+                |(WRITER INITARGS)| |(BOUNDP METHOD)|
                 |(FAST-WRITER-METHOD SLOT-OBJECT PREDICATE-NAME)|
                 |(FAST-WRITER-METHOD CLASS NAME)|
                 |(FAST-WRITER-METHOD SLOT-DEFINITION NAME)|
@@ -1699,11 +1783,11 @@
                 |(FAST-WRITER-METHOD SLOT-OBJECT READERS)|
                 |(FAST-WRITER-METHOD SLOT-DEFINITION READERS)|
                 |(FAST-WRITER-METHOD SLOT-OBJECT SPECIALIZERS)|
-                |(FAST-WRITER-METHOD SLOT-OBJECT IDENTITY-WITH-ONE-ARGUMENT)|
                 |(FAST-WRITER-METHOD SLOT-OBJECT PROTOTYPE)|
-                |(FAST-WRITER-METHOD SLOT-OBJECT OBJECT)|
                 |(FAST-WRITER-METHOD SLOT-DEFINITION TYPE)|
                 |(FAST-WRITER-METHOD SLOT-OBJECT TYPE)|
+                |(FAST-WRITER-METHOD SLOT-OBJECT IDENTITY-WITH-ONE-ARGUMENT)|
+                |(FAST-WRITER-METHOD SLOT-OBJECT OBJECT)|
                 REMOVE-NAMED-METHOD
                 |(FAST-WRITER-METHOD SLOT-OBJECT DEFSTRUCT-FORM)|
                 |(FAST-WRITER-METHOD STRUCTURE-CLASS DEFSTRUCT-FORM)|
@@ -1756,5 +1840,6 @@
                 ENSURE-CLASS-USING-CLASS NO-APPLICABLE-METHOD
                 SLOT-DEFINITION-WRITERS
                 COMPUTE-APPLICABLE-METHODS-USING-CLASSES
-                CLASS-PRECEDENCE-LIST DESCRIBE-OBJECT))
+                CLASS-PRECEDENCE-LIST DISASSEMBLE DESCRIBE-OBJECT
+                COMPILE))
   (SETF (GET V 'COMPILER::PROCLAIMED-CLOSURE) T)) 
--- gcl-2.6.12.orig/unixport/sys_init.lsp.in
+++ gcl-2.6.12/unixport/sys_init.lsp.in
@@ -79,7 +79,7 @@
 #+ansi-cl (use-package :pcl :user)
 
 (import 'si::(clines defentry defcfun object void int double quit bye gbc system
-		     *lib-directory* *system-directory*) :user)
+		     *lib-directory* *system-directory* while) :user)
 
 (let* ((i 4096)(j (si::equal-tail-recursion-check i)))
   (unless (<= (ash i -1) j)
